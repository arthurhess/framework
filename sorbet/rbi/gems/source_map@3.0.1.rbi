# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `source_map` gem.
# Please instead update this file by running `bin/tapioca gem source_map`.

# source://source_map//lib/source_map/vlq.rb#1
class SourceMap
  include ::SourceMap::Generator
  include ::SourceMap::Parser

  # Create a new blank SourceMap
  #
  # Options may include:
  #
  # :file => String           # See {#file}
  # :source_root => String    # See {#source_root}
  # :generated_output => IO   # See {#generated_output}
  #
  # :sources => Array[String] # See {#sources}
  # :names => Array[String]   # See {#names}
  #
  # :version => 3             # Which version of SourceMap to use (only 3 is allowed)
  #
  # @return [SourceMap] a new instance of SourceMap
  #
  # source://source_map//lib/source_map.rb#25
  def initialize(opts = T.unsafe(nil)); end

  # The name of the file containing the code that this SourceMap describes.
  # (default "")
  #
  # source://source_map//lib/source_map.rb#41
  def file; end

  # The name of the file containing the code that this SourceMap describes.
  # (default "")
  #
  # source://source_map//lib/source_map.rb#41
  def file=(_arg0); end

  # A list of mapping objects.
  #
  # source://source_map//lib/source_map.rb#63
  def mappings; end

  # A list of mapping objects.
  #
  # source://source_map//lib/source_map.rb#63
  def mappings=(_arg0); end

  # A list of names (used during parsing/generating)
  # (default [])
  #
  # source://source_map//lib/source_map.rb#60
  def names; end

  # A list of names (used during parsing/generating)
  # (default [])
  #
  # source://source_map//lib/source_map.rb#60
  def names=(_arg0); end

  # The URL/directory that contains the original source files.
  #
  # This is prefixed to the entries in ['sources']
  # (default "")
  #
  # source://source_map//lib/source_map.rb#47
  def source_root; end

  # The URL/directory that contains the original source files.
  #
  # This is prefixed to the entries in ['sources']
  # (default "")
  #
  # source://source_map//lib/source_map.rb#47
  def source_root=(_arg0); end

  # The list of sources (used during parsing/generating)
  # These are relative to the source_root.
  # (default [])
  #
  # source://source_map//lib/source_map.rb#56
  def sources; end

  # The list of sources (used during parsing/generating)
  # These are relative to the source_root.
  # (default [])
  #
  # source://source_map//lib/source_map.rb#56
  def sources=(_arg0); end

  # The version of the SourceMap spec we're using.
  # (default 3)
  #
  # source://source_map//lib/source_map.rb#51
  def version; end

  # The version of the SourceMap spec we're using.
  # (default 3)
  #
  # source://source_map//lib/source_map.rb#51
  def version=(_arg0); end

  class << self
    # Load a SourceMap from a Hash such as might be returned by
    # {SourceMap#as_json}.
    #
    # @raise [ParserError]
    #
    # source://source_map//lib/source_map/parser.rb#8
    def from_json(json); end

    # Load a SourceMap from a String.
    #
    # source://source_map//lib/source_map/parser.rb#21
    def from_s(str); end

    # Load a SourceMap from a file.
    #
    # source://source_map//lib/source_map/parser.rb#26
    def load(filename); end
  end
end

# source://source_map//lib/source_map/generator.rb#2
module SourceMap::Generator
  # Add the mapping for generated code to this source map.
  #
  # The first parameter is the generated text that you're going to add to the output, if
  # it contains multiple lines of code then it will be added to the source map as
  # several mappings.
  #
  # If present, the second parameter represents the original source of the generated
  # fragment, and may contain:
  #
  # :source => String,           # The filename of the source fille that contains this fragment.
  # :source_line => Integer,     # The line in that file that contains this fragment
  # :source_col => Integer,      # The column in that line at which this fragment starts
  # :name => String              # The original name for this variable.
  # :exact_position => Bool      # Whether all lines in the generated fragment came from
  #                                the same position in the source.
  #
  # The :source key is required to set :source_line, :source_col or :name.
  #
  # If unset :source_line and :source_col default to 1,0 for the first line of the
  # generated fragment.
  #
  # Normally :source_line is incremented and :source_col reset at every line break in
  # the generated code (because we assume that you're copying a verbatim fragment from
  # the source into the generated code). If that is not the case, you can set
  # :exact_position => true, and then all lines in the generated output will be given
  # the same :source_line and :source_col.
  #
  # The :name property is used if the fragment you are adding contains only a name that
  # you have renamed in the source transformation.
  #
  # If you'd like to ensure that the source map stays in sync with the generated
  # source, consider calling {source_map.generated_output = StringIO.new} and then
  # accessing your generated javascript with {source_map.generated_output.string},
  # otherwise be careful to always write to both.
  #
  # NOTE: By long-standing convention, the first line of a file is numbered 1, not 0.
  #
  # NOTE: when generating a source map, you should either use this method always, or use
  # the {#add_mapping} method always.
  #
  # source://source_map//lib/source_map/generator.rb#58
  def add_generated(text, opts = T.unsafe(nil)); end

  # Add a mapping to the list for this object.
  #
  # A mapping identifies a fragment of code that has been moved around during
  # transformation from the source file to the generated file. The fragment should
  # be contiguous and not contain any line breaks.
  #
  # Mappings are Hashes with a valid subset of the following 6 keys:
  #
  # :generated_line => Integer,  # The line in the generated file that contains this fragment.
  # :generated_col  => Integer,  # The column in the generated_line that this mapping starts on
  # :source => String,           # The filename of the source fille that contains this fragment.
  # :source_line => Integer,     # The line in that file that contains this fragment.
  # :source_col => Integer,      # The column in that line at which this fragment starts.
  # :name => String              # The original name for this variable (if applicable).
  #
  #
  # The only 3 valid subsets of keys are:
  #   [:generated_line, :generated_col] To indicate that this is a fragment in the
  #   output file that you don't have the source for.
  #
  #   [:generated_line, :generated_col, :source, :source_line, :source_col] To indicate
  #   that this is a fragment in the output file that you do have the source for.
  #
  #   [:generated_line, :generated_col, :source, :source_line, :source_col, :name] To
  #   indicate that this is a particular identifier at a particular location in the original.
  #
  # Any other combination of keys would produce an invalid source map.
  #
  # NOTE: By long-standing convention, the first line of a file is numbered 1, not 0.
  #
  # NOTE: when generating a source map, you should either use this method always,
  # or use the {#add_generated} method always.
  #
  # source://source_map//lib/source_map/generator.rb#135
  def add_mapping(map); end

  # Convert the map into an object suitable for direct serialisation.
  #
  # source://source_map//lib/source_map/generator.rb#156
  def as_json; end

  # An object (responding to <<) that will be written to whenever
  # {add_generated} is called.
  #
  # @example
  #
  #   File.open("/var/www/a.js.min"){ |f|
  #   map = SourceMap.new(:generated_output => f)
  #   map.add_generated('function(a,b,c){minified=1}\n', :source => 'a.js')
  #   map.save('/var/www/a.js.map')
  #   }
  #   File.read('/var/www/a.js.min') == 'function(a,b,c){minified=1}\n'
  #
  # source://source_map//lib/source_map/generator.rb#16
  def generated_output; end

  # An object (responding to <<) that will be written to whenever
  # {add_generated} is called.
  #
  # @example
  #
  #   File.open("/var/www/a.js.min"){ |f|
  #   map = SourceMap.new(:generated_output => f)
  #   map.add_generated('function(a,b,c){minified=1}\n', :source => 'a.js')
  #   map.save('/var/www/a.js.map')
  #   }
  #   File.read('/var/www/a.js.min') == 'function(a,b,c){minified=1}\n'
  #
  # source://source_map//lib/source_map/generator.rb#16
  def generated_output=(_arg0); end

  # Write this map to a file.
  #
  # source://source_map//lib/source_map/generator.rb#175
  def save(file); end

  # Convert the map to a string.
  #
  # source://source_map//lib/source_map/generator.rb#170
  def to_s; end

  protected

  # Returns the value of attribute generated_col.
  #
  # source://source_map//lib/source_map/generator.rb#182
  def generated_col; end

  # Sets the attribute generated_col
  #
  # @param value the value to set the attribute generated_col to.
  #
  # source://source_map//lib/source_map/generator.rb#182
  def generated_col=(_arg0); end

  # Returns the value of attribute generated_line.
  #
  # source://source_map//lib/source_map/generator.rb#182
  def generated_line; end

  # Sets the attribute generated_line
  #
  # @param value the value to set the attribute generated_line to.
  #
  # source://source_map//lib/source_map/generator.rb#182
  def generated_line=(_arg0); end

  # Get the id for the given name. If we've not
  # seen this name before, add it to the list.
  #
  # source://source_map//lib/source_map/generator.rb#195
  def name_id(name); end

  # Returns the value of attribute name_ids.
  #
  # source://source_map//lib/source_map/generator.rb#181
  def name_ids; end

  # source://source_map//lib/source_map/generator.rb#236
  def serialize_mapping(map); end

  # Serialize the list of mappings into the string of base64 variable length
  # quanities. As a side-effect, regenerate the sources and names arrays.
  #
  # source://source_map//lib/source_map/generator.rb#212
  def serialize_mappings!; end

  # Get the id for the given file. If we've not
  # seen this file before, add it to the list.
  #
  # source://source_map//lib/source_map/generator.rb#186
  def source_id(file); end

  # Returns the value of attribute source_ids.
  #
  # source://source_map//lib/source_map/generator.rb#181
  def source_ids; end

  # Encode a vlq. As each field in the output should be relative to the
  # previous occurance of that field, we keep track of each one.
  #
  # source://source_map//lib/source_map/generator.rb#204
  def vlq(num, type); end
end

# source://source_map//lib/source_map/parser.rb#30
module SourceMap::Parser
  # Parse an individual mapping.
  #
  # This is a list of variable-length-quanitity, with 1, 4 or 5 items. See the spec
  # https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
  # for more details.
  #
  # source://source_map//lib/source_map/parser.rb#62
  def parse_mapping(segment, line_num); end

  # Parse the mapping string from a SourceMap.
  #
  # The mappings string contains one comma-separated list of segments per line
  # in the output file, these lists are joined by semi-colons.
  #
  # source://source_map//lib/source_map/parser.rb#36
  def parse_mappings(string); end

  # All the numbers in SourceMaps are stored as differences from each other,
  # so we need to remove the difference every time we read a number.
  #
  # source://source_map//lib/source_map/parser.rb#53
  def undiff(int, type); end
end

# source://source_map//lib/source_map/parser.rb#3
class SourceMap::ParserError < ::RuntimeError; end

# source://source_map//lib/source_map/vlq.rb#10
module SourceMap::VLQ
  class << self
    # source://source_map//lib/source_map/vlq.rb#92
    def base64_decode(char); end

    # source://source_map//lib/source_map/vlq.rb#88
    def base64_encode(int); end

    # Decodes the next base 64 VLQ value from the given string and returns the
    # value and the rest of the string.
    #
    # source://source_map//lib/source_map/vlq.rb#56
    def decode(str); end

    # Decode an array of variable length quantities from the given string and
    # return them.
    #
    # source://source_map//lib/source_map/vlq.rb#77
    def decode_array(str); end

    # Returns the base 64 VLQ encoded value.
    #
    # source://source_map//lib/source_map/vlq.rb#39
    def encode(int); end

    # Converts to a two's-complement value from a value where the sign bit is
    # placed in the least significant bit. For example, as decimals:
    #
    #  2 (10 binary) becomes 1, 3 (11 binary) becomes -1
    #  4 (100 binary) becomes 2, 5 (101 binary) becomes -2
    #
    # source://source_map//lib/source_map/vlq.rb#113
    def from_vlq_signed(vlq); end

    # Converts from a two's-complement integer to an integer where the
    # sign bit is placed in the least significant bit. For example, as decimals:
    #  1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
    #  2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
    #
    # source://source_map//lib/source_map/vlq.rb#100
    def to_vlq_signed(int); end
  end
end

# source://source_map//lib/source_map/vlq.rb#35
SourceMap::VLQ::BASE64_DIGITS = T.let(T.unsafe(nil), Array)

# source://source_map//lib/source_map/vlq.rb#36
SourceMap::VLQ::BASE64_VALUES = T.let(T.unsafe(nil), Hash)

# binary: 100000
#
# source://source_map//lib/source_map/vlq.rb#27
SourceMap::VLQ::VLQ_BASE = T.let(T.unsafe(nil), Integer)

# binary: 011111
#
# source://source_map//lib/source_map/vlq.rb#30
SourceMap::VLQ::VLQ_BASE_MASK = T.let(T.unsafe(nil), Integer)

# A single base 64 digit can contain 6 bits of data. For the base 64 variable
# length quantities we use in the source map spec, the first bit is the sign,
# the next four bits are the actual value, and the 6th bit is the
# continuation bit. The continuation bit tells us whether there are more
# digits in this value following this digit.
#
#   Continuation
#   |    Sign
#   |    |
#   V    V
#   101011
#
# source://source_map//lib/source_map/vlq.rb#24
SourceMap::VLQ::VLQ_BASE_SHIFT = T.let(T.unsafe(nil), Integer)

# binary: 100000
#
# source://source_map//lib/source_map/vlq.rb#33
SourceMap::VLQ::VLQ_CONTINUATION_BIT = T.let(T.unsafe(nil), Integer)
