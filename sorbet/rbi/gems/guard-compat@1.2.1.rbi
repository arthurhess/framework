# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `guard-compat` gem.
# Please instead update this file by running `bin/tapioca gem guard-compat`.

# Provided empty definition so requiring the plugin without Guard won't crash
# (e.g. when added to a Gemfile without `require: false`)
module Guard
  class << self
    # Asynchronously trigger changes
    #
    # Currently supported args:
    #
    #   @example Old style hash:
    #     async_queue_add(modified: ['foo'], added: ['bar'], removed: [])
    #
    #   @example New style signals with args:
    #     async_queue_add([:guard_pause, :unpaused ])
    def async_queue_add(changes); end

    def init(cmdline_options); end

    # Returns the value of attribute interactor.
    def interactor; end

    # Returns the value of attribute listener.
    def listener; end

    # Returns the value of attribute queue.
    def queue; end

    # Initializes the Guard singleton:
    #
    # * Initialize the internal Guard state;
    # * Create the interactor
    # * Select and initialize the file change listener.
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param options [Hash] a customizable set of options
    # @return [Guard] the Guard singleton
    def setup(cmdline_options = T.unsafe(nil)); end

    # Returns the value of attribute state.
    def state; end

    private

    def _evaluate(options); end

    # TODO: remove at some point
    # TODO: not tested because collides with ongoing refactoring
    def _guardfile_deprecated_check(modified); end

    def _listener_callback; end

    # TODO: obsoleted? (move to Dsl?)
    #
    # @return [Boolean]
    def _pluginless_guardfile?; end

    def _relative_pathnames(paths); end

    # Check if any of the changes are actually watched for
    # TODO: why iterate twice? reuse this info when running tasks
    #
    # @return [Boolean]
    def _relevant_changes?(changes); end
  end
end

module Guard::Compat
  class << self
    # TODO: this is just a temporary workaround to allow plugins
    # to use watcher patterns in run_all
    def matching_files(plugin, files); end

    def watched_directories; end
  end
end

module Guard::Compat::Test; end

class Guard::Compat::Test::Template
  # @return [Template] a new instance of Template
  def initialize(plugin_class); end

  def changed(file); end
end

class Guard::Compat::Test::Template::Session
  # @return [Session] a new instance of Session
  def initialize(path, content); end

  def guard(name, _options = T.unsafe(nil)); end
  def match(file); end
  def watch(expr, &block); end

  private

  def _watches; end
end

class Guard::Compat::Test::Template::Session::GlobalWatchesNotImplemented < ::NotImplementedError
  def message; end
end

class Guard::Compat::Test::Template::Session::MultipleGuardNotImplemented < ::NotImplementedError
  def message; end
end

module Guard::Compat::UI
  class << self
    def color(text, *colors); end

    # @return [Boolean]
    def color_enabled?; end

    def debug(message, options = T.unsafe(nil)); end
    def deprecation(message, options = T.unsafe(nil)); end
    def error(message, options = T.unsafe(nil)); end
    def info(message, options = T.unsafe(nil)); end
    def notify(msg, options = T.unsafe(nil)); end
    def warning(message, options = T.unsafe(nil)); end
  end
end

Guard::Compat::VERSION = T.let(T.unsafe(nil), String)

class Guard::MyPlugin < ::Guard::Plugin
  def run_all; end
  def run_on_modifications; end
  def start; end
end

# Monkey patch Plugin to just keep the interface
class Guard::Plugin
  # Initializes a Guard plugin.
  # Don't do any work here, especially as Guard plugins get initialized even
  # if they are not in an active group!
  #
  # @option options
  # @option options
  # @option options
  # @param options [Hash] the Guard plugin options
  # @return [Plugin] a new instance of Plugin
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute callbacks.
  def callbacks; end

  # Sets the attribute callbacks
  #
  # @param value the value to set the attribute callbacks to.
  def callbacks=(_arg0); end

  # Returns the value of attribute group.
  def group; end

  # Sets the attribute group
  #
  # @param value the value to set the attribute group to.
  def group=(_arg0); end

  # When event is a Symbol, {#hook} will generate a hook name
  # by concatenating the method name from where {#hook} is called
  # with the given Symbol.
  #
  # Here, when {Guard::Plugin#run_all} is called, {#hook} will notify
  # callbacks registered for the "run_all_foo" event.
  #
  # When event is a String, {#hook} will directly turn the String
  # into a Symbol.
  #
  # When {Guard::Plugin::run_all} is called, {#hook} will notify
  # callbacks registered for the "foo_bar" event.
  #
  # @example Add a hook with a Symbol
  #
  #   def run_all
  #   hook :foo
  #   end
  # @example Add a hook with a String
  #
  #   def run_all
  #   hook "foo_bar"
  #   end
  # @param event [Symbol, String] the name of the Guard event
  # @param args [Array] the parameters are passed as is to the callbacks
  #   registered for the given event.
  def hook(event, *args); end

  # Returns the plugin's name (without "guard-").
  #
  # @example Name for Guard::RSpec
  #   Guard::RSpec.new.name
  #   #=> "rspec"
  # @return [String]
  def name; end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # Returns the plugin's class name without the Guard:: namespace.
  #
  # @example Title for Guard::RSpec
  #   Guard::RSpec.new.title
  #   #=> "RSpec"
  # @return [String]
  def title; end

  # String representation of the plugin.
  #
  # @example String representation of an instance of the Guard::RSpec plugin
  #
  #   Guard::RSpec.new.title
  #   #=> "#<Guard::RSpec @name=rspec @group=#<Guard::Group @name=default
  #   @options={}> @watchers=[] @callbacks=[] @options={all_after_pass:
  #   true}>"
  # @return [String] the string representation
  def to_s; end

  # Returns the value of attribute watchers.
  def watchers; end

  # Sets the attribute watchers
  #
  # @param value the value to set the attribute watchers to.
  def watchers=(_arg0); end

  private

  # Add all the Guard::Plugin's callbacks to the global @callbacks array
  # that's used by Guard to know which callbacks to notify.
  def _register_callbacks; end

  class << self
    # Add a callback.
    #
    # @param listener [Block] the listener to notify
    # @param guard_plugin [Guard::Plugin] the Guard plugin to add the callback
    # @param events [Array<Symbol>] the events to register
    def add_callback(listener, guard_plugin, events); end

    # Get all callbacks registered for all Guard plugins present in the
    # Guardfile.
    def callbacks; end

    # Returns the non-namespaced class name of the plugin
    #
    # @example Non-namespaced class name for Guard::RSpec
    #   Guard::RSpec.non_namespaced_classname
    #   #=> "RSpec"
    # @return [String]
    def non_namespaced_classname; end

    # Returns the non-namespaced name of the plugin
    #
    # @example Non-namespaced name for Guard::RSpec
    #   Guard::RSpec.non_namespaced_name
    #   #=> "rspec"
    # @return [String]
    def non_namespaced_name; end

    # Notify a callback.
    #
    # @param guard_plugin [Guard::Plugin] the Guard plugin to add the callback
    # @param event [Symbol] the event to trigger
    # @param args [Array] the arguments for the listener
    def notify(guard_plugin, event, *args); end

    # Reset all callbacks.
    #
    # TODO: remove (not used anywhere)
    def reset_callbacks!; end

    # Specify the source for the Guardfile template.
    # Each Guard plugin can redefine this method to add its own logic.
    #
    # @param plugin_location [String] the plugin location
    def template(plugin_location); end
  end
end

Guard::Plugin::TEMPLATE_FORMAT = T.let(T.unsafe(nil), String)
Guard::VERSION = T.let(T.unsafe(nil), String)
