# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async` gem.
# Please instead update this file by running `bin/tapioca gem async`.

module Async
  class << self
    def logger; end
  end
end

# A list of children tasks.
class Async::Children < ::Async::List
  # @return [Children] a new instance of Children
  def initialize; end

  def delete(item); end

  # @return [Boolean]
  def finished?; end

  def insert(item); end

  # Does this node have (direct) transient children?
  #
  # @return [Boolean]
  def transients?; end
end

# A convenient wrapper around the internal monotonic clock.
class Async::Clock
  # Create a new clock with the initial total time.
  #
  # @return [Clock] a new instance of Clock
  def initialize(total = T.unsafe(nil)); end

  # Start measuring a duration.
  def start!; end

  # Stop measuring a duration and append the duration to the current total.
  def stop!; end

  # The total elapsed time including any current duration.
  def total; end

  class << self
    # Measure the execution of a block of code.
    def measure; end

    # Get the current elapsed monotonic time.
    def now; end

    # Start measuring elapsed time from now.
    def start; end
  end
end

# A synchronization primitive, which allows fibers to wait until a particular condition is (edge) triggered.
class Async::Condition
  # @return [Condition] a new instance of Condition
  def initialize; end

  # Is any fiber waiting on this notification?
  #
  # @return [Boolean]
  def empty?; end

  # Signal to a given task that it should resume operations.
  def signal(value = T.unsafe(nil)); end

  # Queue up the current fiber and wait on yielding the task.
  def wait; end
end

class Async::Condition::Queue < ::Struct
  # @return [Boolean]
  def alive?; end

  # Returns the value of attribute fiber
  #
  # @return [Object] the current value of fiber
  def fiber; end

  # Sets the attribute fiber
  #
  # @param value [Object] the value to set the attribute fiber to.
  # @return [Object] the newly set value
  def fiber=(_); end

  def nullify; end
  def transfer(*arguments); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Async::LimitedQueue < ::Async::Queue
  # @return [LimitedQueue] a new instance of LimitedQueue
  def initialize(limit = T.unsafe(nil), **options); end

  def <<(item); end
  def dequeue; end
  def enqueue(*items); end

  # Returns the value of attribute limit.
  def limit; end

  # @return [Boolean]
  def limited?; end
end

# A double linked list used for managing tasks.
class Async::List
  # @return [List] a new instance of List
  def initialize; end

  def delete(item); end
  def each(&block); end

  # @return [Boolean]
  def empty?; end

  def first; end

  # Returns the value of attribute head.
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  def head=(_arg0); end

  # @return [Boolean]
  def include?(needle); end

  # Inserts an item at the end of the list.
  def insert(item); end

  def last; end

  # @return [Boolean]
  def nil?; end

  # Returns the value of attribute size.
  def size; end

  # Returns the value of attribute tail.
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  def tail=(_arg0); end
end

# A node in a tree, used for implementing the task hierarchy.
class Async::Node
  # Create a new node in the tree.
  #
  # @return [Node] a new instance of Node
  def initialize(parent = T.unsafe(nil), annotation: T.unsafe(nil), transient: T.unsafe(nil)); end

  def annotate(annotation); end

  # A useful identifier for the current node.
  def annotation; end

  def backtrace(*arguments); end

  # Returns the value of attribute children.
  def children; end

  # Whether there are children?
  #
  # @return [Boolean]
  def children?; end

  # If the node has a parent, and is {finished?}, then remove this node from
  # the parent.
  def consume; end

  def description; end

  # Whether the node can be consumed safely. By default, checks if the
  # children set is empty.
  #
  # @return [Boolean]
  def finished?; end

  # @private
  def head; end

  # @private
  def head=(_arg0); end

  def inspect; end

  # Returns the value of attribute parent.
  def parent; end

  # Change the parent of this node.
  def parent=(parent); end

  def print_hierarchy(out = T.unsafe(nil), backtrace: T.unsafe(nil)); end
  def root; end

  # Attempt to stop the current node immediately, including all non-transient children.
  # Invokes {#stop_children} to stop all children.
  def stop(later = T.unsafe(nil)); end

  # @return [Boolean]
  def stopped?; end

  # @private
  def tail; end

  # @private
  def tail=(_arg0); end

  # Immediately terminate all children tasks, including transient tasks.
  # Internally invokes `stop(false)` on all children.
  def terminate; end

  def to_s; end

  # Is this node transient?
  #
  # @return [Boolean]
  def transient?; end

  # Traverse the tree.
  #
  # @yield [_self, level]
  # @yieldparam _self [Async::Node] the object that the method was called on
  def traverse(level = T.unsafe(nil), &block); end

  protected

  def add_child(child); end
  def delete_child(child); end
  def set_parent(parent); end

  private

  def print_backtrace(out, indent, node); end

  # Attempt to stop all non-transient children.
  def stop_children(later = T.unsafe(nil)); end
end

# A synchronization primitive, which allows fibers to wait until a notification is received. Does not block the task which signals the notification. Waiting tasks are resumed on next iteration of the reactor.
class Async::Notification < ::Async::Condition
  # Signal to a given task that it should resume operations.
  def signal(value = T.unsafe(nil), task: T.unsafe(nil)); end
end

class Async::Notification::Signal < ::Struct
  # @return [Boolean]
  def alive?; end

  def transfer; end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  # Returns the value of attribute waiting
  #
  # @return [Object] the current value of waiting
  def waiting; end

  # Sets the attribute waiting
  #
  # @param value [Object] the value to set the attribute waiting to.
  # @return [Object] the newly set value
  def waiting=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# A queue which allows items to be processed in order.
class Async::Queue < ::Async::Notification
  # @return [Queue] a new instance of Queue
  def initialize(parent: T.unsafe(nil)); end

  def <<(item); end
  def async(parent: T.unsafe(nil), &block); end
  def dequeue; end
  def each; end

  # @return [Boolean]
  def empty?; end

  def enqueue(*items); end

  # Returns the value of attribute items.
  def items; end

  def size; end
end

# A wrapper around the the scheduler which binds it to the current thread automatically.
class Async::Reactor < ::Async::Scheduler
  # @return [Reactor] a new instance of Reactor
  def initialize(*_arg0, **_arg1, &_arg2); end

  class << self
    # @deprecated Replaced by {Kernel::Async}.
    def run(*_arg0, **_arg1, &_arg2); end
  end
end

# Handles scheduling of fibers. Implements the fiber scheduler interface.
class Async::Scheduler < ::Async::Node
  # @return [Scheduler] a new instance of Scheduler
  def initialize(parent = T.unsafe(nil), selector: T.unsafe(nil)); end

  def address_resolve(hostname); end

  # Start an asynchronous task within the specified reactor. The task will be
  # executed until the first blocking call, at which point it will yield and
  # and this method will return.
  #
  # This is the main entry point for scheduling asynchronus tasks.
  #
  # @deprecated With no replacement.
  def async(*arguments, **options, &block); end

  # Invoked when a fiber tries to perform a blocking operation which cannot continue. A corresponding call {unblock} must be performed to allow this fiber to continue.
  def block(blocker, timeout); end

  def close; end

  # @return [Boolean]
  def closed?; end

  def fiber(*_arg0, **_arg1, &_arg2); end

  # Interrupt the event loop and cause it to exit.
  def interrupt; end

  def io_read(io, buffer, length); end
  def io_wait(io, events, timeout = T.unsafe(nil)); end
  def io_write(io, buffer, length); end
  def kernel_sleep(duration = T.unsafe(nil)); end

  # Wait for the specified process ID to exit.
  def process_wait(pid, flags); end

  # Schedule a fiber (or equivalent object) to be resumed on the next loop through the reactor.
  def push(fiber); end

  def raise(*arguments); end
  def resume(fiber, *arguments); end

  # Run the reactor until all tasks are finished. Proxies arguments to {#async} immediately before entering the loop, if a block is provided.
  def run(*_arg0, **_arg1, &_arg2); end

  # Run one iteration of the event loop.
  def run_once(timeout = T.unsafe(nil)); end

  def timeout_after(duration, exception, message, &block); end
  def to_s; end

  # Transfer from the calling fiber to the event loop.
  def transfer; end

  def unblock(blocker, fiber); end

  # Invoke the block, but after the specified timeout, raise {TimeoutError} in any currenly blocking operation. If the block runs to completion before the timeout occurs or there are no non-blocking operations after the timeout expires, the code will complete without any exception.
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield the current fiber and resume it on the next iteration of the event loop.
  def yield; end

  class << self
    # Whether the fiber scheduler is supported.
    #
    # @return [Boolean]
    def supported?; end
  end
end

# A synchronization primitive, which limits access to a given resource.
class Async::Semaphore
  # @return [Semaphore] a new instance of Semaphore
  def initialize(limit = T.unsafe(nil), parent: T.unsafe(nil)); end

  # Acquire the semaphore, block if we are at the limit.
  # If no block is provided, you must call release manually.
  def acquire; end

  # Run an async task. Will wait until the semaphore is ready until spawning and running the task.
  def async(*arguments, parent: T.unsafe(nil), **options); end

  # Whether trying to acquire this semaphore would block.
  #
  # @return [Boolean]
  def blocking?; end

  # The current number of tasks that have acquired the semaphore.
  def count; end

  # Is the semaphore currently acquired?
  #
  # @return [Boolean]
  def empty?; end

  # The maximum number of tasks that can acquire the semaphore.
  def limit; end

  # Release the semaphore. Must match up with a corresponding call to `acquire`. Will release waiting fibers in FIFO order.
  def release; end

  # The tasks waiting on this semaphore.
  def waiting; end

  private

  # Wait until the semaphore becomes available.
  def wait; end
end

# Raised when a task is explicitly stopped.
class Async::Stop < ::Exception; end

class Async::Stop::Later
  # @return [Later] a new instance of Later
  def initialize(task); end

  # @return [Boolean]
  def alive?; end

  def transfer; end
end

# Encapsulates the state of a running task and it's result.
class Async::Task < ::Async::Node
  # Create a new task.
  #
  # @return [Task] a new instance of Task
  def initialize(parent = T.unsafe(nil), finished: T.unsafe(nil), **options, &block); end

  # @return [Boolean]
  def alive?; end

  def async(*arguments, **options, &block); end
  def backtrace(*arguments); end

  # @return [Boolean]
  def complete?; end

  # @return [Boolean]
  def current?; end

  # @return [Boolean]
  def failed?; end

  # @attr fiber [Fiber] The fiber which is being used for the execution of this task.
  def fiber; end

  # Whether we can remove this node from the reactor graph.
  #
  # @return [Boolean]
  def finished?; end

  def reactor; end

  # Access the result of the task without waiting. May be nil if the task is not completed.
  def result; end

  # Begin the execution of the task.
  def run(*arguments); end

  # Check if the task is running.
  #
  # @return [Boolean]
  def running?; end

  # @deprecated Prefer {Kernel#sleep} except when compatibility with `stable-v1` is required.
  def sleep(duration = T.unsafe(nil)); end

  # @attr status [Symbol] The status of the execution of the fiber, one of `:initialized`, `:running`, `:complete`, `:stopped` or `:failed`.
  def status; end

  # Stop the task and all of its children.
  def stop(later = T.unsafe(nil)); end

  # @return [Boolean]
  def stopped?; end

  def to_s; end

  # Retrieve the current result of the task. Will cause the caller to wait until result is available.
  # @raises[RuntimeError] If the task's fiber is the current fiber.
  def wait; end

  # Execute the given block of code, raising the specified exception if it exceeds the given duration during a non-blocking operation.
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield back to the reactor and allow other fibers to execute.
  def yield; end

  private

  # This is a very tricky aspect of tasks to get right. I've modelled it after `Thread` but it's slightly different in that the exception can propagate back up through the reactor. If the user writes code which raises an exception, that exception should always be visible, i.e. cause a failure. If it's not visible, such code fails silently and can be very difficult to debug.
  def fail!(exception = T.unsafe(nil), propagate = T.unsafe(nil)); end

  # Finish the current task, and all bound bound IO objects.
  def finish!; end

  def schedule(arguments); end

  # Set the current fiber's `:async_task` to this task.
  def set!; end

  def stop!; end

  class << self
    # Lookup the {Task} for the current fiber. Raise `RuntimeError` if none is available.
    # @raises[RuntimeError] If task was not {set!} for the current fiber.
    def current; end

    # Check if there is a task defined for the current fiber.
    #
    # @return [Boolean]
    def current?; end

    # @deprecated With no replacement.
    def yield; end
  end
end

# Raised if a timeout occurs on a specific Fiber. Handled gracefully by `Task`.
class Async::TimeoutError < ::StandardError
  # @return [TimeoutError] a new instance of TimeoutError
  def initialize(message = T.unsafe(nil)); end
end

Async::VERSION = T.let(T.unsafe(nil), String)

# Represents an asynchronous IO within a reactor.
#
# @deprecated With no replacement. Prefer native interfaces.
class Async::Wrapper
  # @return [Wrapper] a new instance of Wrapper
  def initialize(io, reactor = T.unsafe(nil)); end

  # Close the io and monitor.
  def close; end

  # @return [Boolean]
  def closed?; end

  def dup; end

  # The underlying native `io`.
  def io; end

  # Returns the value of attribute reactor.
  def reactor; end

  # Sets the attribute reactor
  #
  # @param value the value to set the attribute reactor to.
  def reactor=(_arg0); end

  # Wait fo the io to become either readable or writable.
  def wait_any(timeout = T.unsafe(nil)); end

  # Wait for the io to become writable.
  def wait_priority(timeout = T.unsafe(nil)); end

  # Wait for the io to become readable.
  def wait_readable(timeout = T.unsafe(nil)); end

  # Wait for the io to become writable.
  def wait_writable(timeout = T.unsafe(nil)); end
end

# An exception that occurs when the asynchronous operation was cancelled.
class Async::Wrapper::Cancelled < ::StandardError; end

# Extensions to all Ruby objects.
module Kernel
  # Run the given block of code in a task, asynchronously, creating a reactor if necessary.
  #
  # The preferred method to invoke asynchronous behavior at the top level.
  #
  # - When invoked within an existing reactor task, it will run the given block
  # asynchronously. Will return the task once it has been scheduled.
  # - When invoked at the top level, will create and run a reactor, and invoke
  # the block as an asynchronous task. Will block until the reactor finishes
  # running.
  def Async(*_arg0, **_arg1, &_arg2); end

  # Run the given block of code synchronously, but within a reactor if not already in one.
  def Sync(&block); end
end
