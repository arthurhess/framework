# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hanami-router` gem.
# Please instead update this file by running `bin/tapioca gem hanami-router`.

# Hanami
#
# @since 0.1.0
module Hanami; end

# Rack compatible, lightweight and fast HTTP Router.
#
# @example It offers an intuitive DSL, that supports most of the HTTP verbs:
#   require 'hanami/router'
#
#   endpoint = ->(env) { [200, {}, ['Welcome to Hanami::Router!']] }
#   router = Hanami::Router.new do
#   get     '/', to: endpoint # => get and head requests
#   post    '/', to: endpoint
#   put     '/', to: endpoint
#   patch   '/', to: endpoint
#   delete  '/', to: endpoint
#   options '/', to: endpoint
#   trace   '/', to: endpoint
#   end
# @example Specify an endpoint with `:to` (Rack compatible object)
#   require 'hanami/router'
#
#   endpoint = ->(env) { [200, {}, ['Welcome to Hanami::Router!']] }
#   router = Hanami::Router.new do
#   get '/', to: endpoint
#   end
#
#   # :to is mandatory for the default resolver (`Hanami::Routing::EndpointResolver.new`),
#   # This behavior can be changed by passing a custom resolver to `Hanami::Router#initialize`
# @example Specify an endpoint with `:to` (controller and action string)
#   require 'hanami/router'
#
#   router = Hanami::Router.new do
#   get '/', to: 'articles#show' # => Articles::Show
#   end
#
#   # This is a builtin feature for a Hanami::Controller convention.
# @example Specify a named route with `:as`
#   require 'hanami/router'
#
#   endpoint = ->(env) { [200, {}, ['Welcome to Hanami::Router!']] }
#   router = Hanami::Router.new(scheme: 'https', host: 'hanamirb.org') do
#   get '/', to: endpoint, as: :root
#   end
#
#   router.path(:root) # => '/'
#   router.url(:root)  # => 'https://hanamirb.org/'
#
#   # This isn't mandatory for the default route class (`Hanami::Routing::Route`),
#   # This behavior can be changed by passing a custom route to `Hanami::Router#initialize`
# @example Mount an application
#   require 'hanami/router'
#
#   router = Hanami::Router.new do
#   mount Api::App, at: '/api'
#   end
#
#   # All the requests starting with "/api" will be forwarded to Api::App
# @since 0.1.0
class Hanami::Router
  # Initialize the router.
  #
  # @example Basic example
  #   require 'hanami/router'
  #
  #   endpoint = ->(env) { [200, {}, ['Welcome to Hanami::Router!']] }
  #
  #   router = Hanami::Router.new
  #   router.get '/', to: endpoint
  #
  #   # or
  #
  #   router = Hanami::Router.new do
  #   get '/', to: endpoint
  #   end
  # @example Body parsers
  #   require 'json'
  #   require 'hanami/router'
  #
  #   # It parses JSON body and makes the attributes available to the params
  #
  #   endpoint = ->(env) { [200, {},[env['router.params'].inspect]] }
  #
  #   router = Hanami::Router.new(parsers: [:json]) do
  #   patch '/books/:id', to: endpoint
  #   end
  #
  #   # From the shell
  #
  #   curl http://localhost:2300/books/1    \
  #   -H "Content-Type: application/json" \
  #   -H "Accept: application/json"       \
  #   -d '{"published":"true"}'           \
  #   -X PATCH
  #
  #   # It returns
  #
  #   [200, {}, ["{:published=>\"true\",:id=>\"1\"}"]]
  # @example Custom body parser
  #   require 'hanami/router'
  #
  #   class XmlParser
  #   def mime_types
  #   ['application/xml', 'text/xml']
  #   end
  #
  #   # Parse body and return a Hash
  #   def parse(body)
  #   # ...
  #   end
  #   end
  #
  #   # It parses XML body and makes the attributes available to the params
  #
  #   endpoint = ->(env) { [200, {},[env['router.params'].inspect]] }
  #
  #   router = Hanami::Router.new(parsers: [XmlParser.new]) do
  #   patch '/authors/:id', to: endpoint
  #   end
  #
  #   # From the shell
  #
  #   curl http://localhost:2300/authors/1 \
  #   -H "Content-Type: application/xml" \
  #   -H "Accept: application/xml"       \
  #   -d '<name>LG</name>'               \
  #   -X PATCH
  #
  #   # It returns
  #
  #   [200, {}, ["{:name=>\"LG\",:id=>\"1\"}"]]
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] the options to initialize the router
  # @param blk [Proc] the optional block to define the routes
  # @return [Hanami::Router] self
  # @since 0.1.0
  def initialize(options = T.unsafe(nil), &blk); end

  # Resolve the given Rack env to a registered endpoint and invoke it.
  #
  # @param env [Hash] a Rack env instance
  # @return [Rack::Response, Array]
  # @since 0.1.0
  def call(env); end

  # To support defining routes in the `define` wrapper.
  #
  # @example In Hanami framework
  #   class Application < Hanami::Application
  #   configure do
  #   routes 'config/routes'
  #   end
  #   end
  #
  #   # In `config/routes`
  #
  #   define do
  #   get # ...
  #   end
  # @param blk [Proc] the block to define the routes
  # @return [Hanami::Routing::Route]
  # @since 0.2.0
  def define(&blk); end

  # Check if there are defined routes
  #
  # @api private
  # @example
  #
  #   router = Hanami::Router.new
  #   router.defined? # => false
  #
  #   router = Hanami::Router.new { get '/', to: ->(env) { } }
  #   router.defined? # => true
  # @return [TrueClass, FalseClass] the result of the check
  # @since 0.2.0
  def defined?; end

  # Defines a route that accepts a DELETE request for the given path.
  #
  # @option options
  # @param path [String] the relative URL to be matched
  # @param options [Hash] the options to customize the route
  # @param blk [Proc] the anonymous proc to be used as endpoint for the route
  # @return [Hanami::Routing::Route] this may vary according to the :route
  #   option passed to the constructor
  # @see Hanami::Router#get
  # @since 0.1.0
  def delete(path, options = T.unsafe(nil), &blk); end

  # Defines a route that accepts a GET request for the given path.
  #
  # @example Fixed matching string
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get '/hanami', to: ->(env) { [200, {}, ['Hello from Hanami!']] }
  # @example String matching with variables
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get '/flowers/:id',
  #   to: ->(env) {
  #   [
  #   200,
  #   {},
  #   ["Hello from Flower no. #{ env['router.params'][:id] }!"]
  #   ]
  #   }
  # @example Variables Constraints
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get '/flowers/:id',
  #   id: /\d+/,
  #   to: ->(env) { [200, {}, [":id must be a number!"]] }
  # @example String matching with globbling
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get '/*',
  #   to: ->(env) {
  #   [
  #   200,
  #   {},
  #   ["This is catch all: #{ env['router.params'].inspect }!"]
  #   ]
  #   }
  # @example String matching with optional tokens
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get '/hanami(.:format)',
  #   to: ->(env) {
  #   [200, {}, ["You've requested #{ env['router.params'][:format] }!"]]
  #   }
  # @example Named routes
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new(scheme: 'https', host: 'hanamirb.org')
  #   router.get '/hanami',
  #   to: ->(env) { [200, {}, ['Hello from Hanami!']] },
  #   as: :hanami
  #
  #   router.path(:hanami) # => "/hanami"
  #   router.url(:hanami)  # => "https://hanamirb.org/hanami"
  # @example Duck typed endpoints (Rack compatible objects)
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #
  #   router.get '/hanami',      to: ->(env) { [200, {}, ['Hello from Hanami!']] }
  #   router.get '/middleware', to: Middleware
  #   router.get '/rack-app',   to: RackApp.new
  #   router.get '/method',     to: ActionControllerSubclass.action(:new)
  #
  #   # Everything that responds to #call is invoked as it is
  # @example Duck typed endpoints (strings)
  #   require 'hanami/router'
  #
  #   class RackApp
  #   def call(env)
  #   # ...
  #   end
  #   end
  #
  #   router = Hanami::Router.new
  #   router.get '/hanami', to: 'rack_app' # it will map to RackApp.new
  # @example Duck typed endpoints (string: controller + action)
  #   require 'hanami/router'
  #
  #   module Flowers
  #   class Index
  #   def call(env)
  #   # ...
  #   end
  #   end
  #   end
  #
  #   router = Hanami::Router.new
  #   router.get '/flowers', to: 'flowers#index'
  #
  #   # It will map to Flowers::Index.new, which is the
  #   # Hanami::Controller convention.
  # @option options
  # @param path [String] the relative URL to be matched
  # @param options [Hash] the options to customize the route
  # @param blk [Proc] the anonymous proc to be used as endpoint for the route
  # @return [Hanami::Routing::Route] this may vary according to the :route
  #   option passed to the constructor
  # @since 0.1.0
  def get(path, options = T.unsafe(nil), &blk); end

  # Returns an routes inspector
  #
  # @example
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new do
  #   get    '/',       to: 'home#index'
  #   get    '/login',  to: 'sessions#new',     as: :login
  #   post   '/login',  to: 'sessions#create'
  #   delete '/logout', to: 'sessions#destroy', as: :logout
  #   end
  #
  #   puts router.inspector
  #   # =>        GET, HEAD  /                        Home::Index
  #   login  GET, HEAD  /login                   Sessions::New
  #   POST       /login                   Sessions::Create
  #   logout GET, HEAD  /logout                  Sessions::Destroy
  # @see Hanami::Routing::RoutesInspector
  # @since 0.2.0
  def inspector; end

  # Defines a route that accepts a LINK request for the given path.
  #
  # @option options
  # @param path [String] the relative URL to be matched
  # @param options [Hash] the options to customize the route
  # @param blk [Proc] the anonymous proc to be used as endpoint for the route
  # @return [Hanami::Routing::Route] this may vary according to the :route
  #   option passed to the constructor
  # @see Hanami::Router#get
  # @since 0.8.0
  def link(path, options = T.unsafe(nil), &blk); end

  # Mount a Rack application at the specified path.
  # All the requests starting with the specified path, will be forwarded to
  # the given application.
  #
  # All the other methods (eg #get) support callable objects, but they
  # restrict the range of the acceptable HTTP verb. Mounting an application
  # with #mount doesn't apply this kind of restriction at the router level,
  # but let the application to decide.
  #
  # @example Basic usage
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   mount Api::App.new, at: '/api'
  #   end
  #
  #   # Requests:
  #   #
  #   # GET  /api          # => 200
  #   # GET  /api/articles # => 200
  #   # POST /api/articles # => 200
  #   # GET  /api/unknown  # => 404
  # @example Difference between #get and #mount
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   get '/rack1',      to: RackOne.new
  #   mount RackTwo.new, at: '/rack2'
  #   end
  #
  #   # Requests:
  #   #
  #   # # /rack1 will only accept GET
  #   # GET  /rack1        # => 200 (RackOne.new)
  #   # POST /rack1        # => 405
  #   #
  #   # # /rack2 accepts all the verbs and delegate the decision to RackTwo
  #   # GET  /rack2        # => 200 (RackTwo.new)
  #   # POST /rack2        # => 200 (RackTwo.new)
  # @example Types of mountable applications
  #   require 'hanami/router'
  #
  #   class RackOne
  #   def self.call(env)
  #   end
  #   end
  #
  #   class RackTwo
  #   def call(env)
  #   end
  #   end
  #
  #   class RackThree
  #   def call(env)
  #   end
  #   end
  #
  #   module Dashboard
  #   class Index
  #   def call(env)
  #   end
  #   end
  #   end
  #
  #   Hanami::Router.new do
  #   mount RackOne,                             at: '/rack1'
  #   mount RackTwo,                             at: '/rack2'
  #   mount RackThree.new,                       at: '/rack3'
  #   mount ->(env) {[200, {}, ['Rack Four']]},  at: '/rack4'
  #   mount 'dashboard#index',                   at: '/dashboard'
  #   end
  #
  #   # 1. RackOne is used as it is (class), because it respond to .call
  #   # 2. RackTwo is initialized, because it respond to #call
  #   # 3. RackThree is used as it is (object), because it respond to #call
  #   # 4. That Proc is used as it is, because it respond to #call
  #   # 5. That string is resolved as Dashboard::Index (Hanami::Controller)
  # @option options
  # @param app [#call] a class or an object that responds to #call
  # @param options [Hash] the options to customize the mount
  # @since 0.1.1
  def mount(app, options); end

  # Defines a Ruby block: all the routes defined within it will be namespaced
  # with the given relative path.
  #
  # Namespaces blocks can be nested multiple times.
  #
  # @example Nested namespaces
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   namespace 'animals' do
  #   namespace 'mammals' do
  #   get '/cats', to: endpoint # => '/animals/mammals/cats'
  #   end
  #   end
  #   end
  # @example Basic example
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   namespace 'trees' do
  #   get '/sequoia', to: endpoint # => '/trees/sequoia'
  #   end
  #   end
  # @example
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.namespace 'trees' do
  #   get '/sequoia', to: endpoint # => '/trees/sequoia'
  #   end
  # @param blk [Proc] the block that defines the resources
  # @param namespace [String] the relative path where the nested routes will
  #   be mounted
  # @return [Hanami::Routing::Namespace] the generated namespace.
  # @see Hanami::Router
  # @since 0.1.0
  def namespace(namespace, &blk); end

  # Defines a route that accepts a OPTIONS request for the given path.
  #
  # @option options
  # @param path [String] the relative URL to be matched
  # @param options [Hash] the options to customize the route
  # @param blk [Proc] the anonymous proc to be used as endpoint for the route
  # @return [Hanami::Routing::Route] this may vary according to the :route
  #   option passed to the constructor
  # @see Hanami::Router#get
  # @since 0.1.0
  def options(path, options = T.unsafe(nil), &blk); end

  # Defines a route that accepts a PATCH request for the given path.
  #
  # @option options
  # @param path [String] the relative URL to be matched
  # @param options [Hash] the options to customize the route
  # @param blk [Proc] the anonymous proc to be used as endpoint for the route
  # @return [Hanami::Routing::Route] this may vary according to the :route
  #   option passed to the constructor
  # @see Hanami::Router#get
  # @since 0.1.0
  def patch(path, options = T.unsafe(nil), &blk); end

  # Generate an relative URL for a specified named route.
  # The additional arguments will be used to compose the relative URL - in
  #   case it has tokens to match - and for compose the query string.
  #
  # @example
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new(scheme: 'https', host: 'hanamirb.org')
  #   router.get '/login', to: 'sessions#new',    as: :login
  #   router.get '/:name', to: 'frameworks#show', as: :framework
  #
  #   router.path(:login)                          # => "/login"
  #   router.path(:login, return_to: '/dashboard') # => "/login?return_to=%2Fdashboard"
  #   router.path(:framework, name: 'router')      # => "/router"
  # @param route [Symbol] the route name
  # @raise [Hanami::Routing::InvalidRouteException] when the router fails to
  #   recognize a route, because of the given arguments.
  # @return [String]
  # @since 0.1.0
  def path(route, *args); end

  # Defines a route that accepts a POST request for the given path.
  #
  # @option options
  # @param path [String] the relative URL to be matched
  # @param options [Hash] the options to customize the route
  # @param blk [Proc] the anonymous proc to be used as endpoint for the route
  # @return [Hanami::Routing::Route] this may vary according to the :route
  #   option passed to the constructor
  # @see Hanami::Router#get
  # @since 0.1.0
  def post(path, options = T.unsafe(nil), &blk); end

  # Defines a route that accepts a PUT request for the given path.
  #
  # @option options
  # @param path [String] the relative URL to be matched
  # @param options [Hash] the options to customize the route
  # @param blk [Proc] the anonymous proc to be used as endpoint for the route
  # @return [Hanami::Routing::Route] this may vary according to the :route
  #   option passed to the constructor
  # @see Hanami::Router#get
  # @since 0.1.0
  def put(path, options = T.unsafe(nil), &blk); end

  # Recognize the given env, path, or name and return a route for testing
  # inspection.
  #
  # If the route cannot be recognized, it still returns an object for testing
  # inspection.
  #
  # @example Successful Path Recognition
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new do
  #   get '/books/:id', to: 'books#show', as: :book
  #   end
  #
  #   route = router.recognize('/books/23')
  #   route.verb      # => "GET" (default)
  #   route.routable? # => true
  #   route.params    # => {:id=>"23"}
  # @example Successful Rack Env Recognition
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new do
  #   get '/books/:id', to: 'books#show', as: :book
  #   end
  #
  #   route = router.recognize(Rack::MockRequest.env_for('/books/23'))
  #   route.verb      # => "GET" (default)
  #   route.routable? # => true
  #   route.params    # => {:id=>"23"}
  # @example Successful Named Route Recognition
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new do
  #   get '/books/:id', to: 'books#show', as: :book
  #   end
  #
  #   route = router.recognize(:book, id: 23)
  #   route.verb      # => "GET" (default)
  #   route.routable? # => true
  #   route.params    # => {:id=>"23"}
  # @example Failing Recognition For Unknown Path
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new do
  #   get '/books/:id', to: 'books#show', as: :book
  #   end
  #
  #   route = router.recognize('/books')
  #   route.verb      # => "GET" (default)
  #   route.routable? # => false
  # @example Failing Recognition For Path With Wrong HTTP Verb
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new do
  #   get '/books/:id', to: 'books#show', as: :book
  #   end
  #
  #   route = router.recognize('/books/23', method: :post)
  #   route.verb      # => "POST"
  #   route.routable? # => false
  # @example Failing Recognition For Rack Env With Wrong HTTP Verb
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new do
  #   get '/books/:id', to: 'books#show', as: :book
  #   end
  #
  #   route = router.recognize(Rack::MockRequest.env_for('/books/23', method: :post))
  #   route.verb      # => "POST"
  #   route.routable? # => false
  # @example Failing Recognition Named Route With Wrong Params
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new do
  #   get '/books/:id', to: 'books#show', as: :book
  #   end
  #
  #   route = router.recognize(:book)
  #   route.verb      # => "GET" (default)
  #   route.routable? # => false
  # @example Failing Recognition Named Route With Wrong HTTP Verb
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new do
  #   get '/books/:id', to: 'books#show', as: :book
  #   end
  #
  #   route = router.recognize(:book, {method: :post}, {id: 1})
  #   route.verb      # => "POST"
  #   route.routable? # => false
  #   route.params    # => {:id=>"1"}
  # @param env [Hash, String, Symbol] Rack env, path or route name
  # @param options [Hash] a set of options for Rack env or route params
  # @param params [Hash] a set of params
  # @return [Hanami::Routing::RecognizedRoute] the recognized route
  # @see Hanami::Router#env_for
  # @see Hanami::Routing::RecognizedRoute
  # @since 0.5.0
  def recognize(env, options = T.unsafe(nil), params = T.unsafe(nil)); end

  # Defines an HTTP redirect
  #
  # @example
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.redirect '/legacy',  to: '/new_endpoint'
  # @example
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   redirect '/legacy',  to: '/new_endpoint'
  #   redirect '/legacy2', to: '/new_endpoint2', code: 302
  #   end
  # @option options
  # @param options [Hash] the options to customize the redirect behavior
  # @param path [String] the path that needs to be redirected
  # @return [Hanami::Routing::Route] the generated route.
  #   This may vary according to the `:route` option passed to the initializer
  # @see Hanami::Router
  # @since 0.1.0
  def redirect(path, options = T.unsafe(nil), &endpoint); end

  # Defines a set of named routes for a single RESTful resource.
  # It has a built-in integration for Hanami::Controller.
  #
  # @example Default usage
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resource 'identity'
  #   end
  #
  #   # It generates:
  #   #
  #   # +--------+----------------+-------------------+----------+----------------+
  #   # | Verb   | Path           | Action            | Name     | Named Route    |
  #   # +--------+----------------+-------------------+----------+----------------+
  #   # | GET    | /identity      | Identity::Show    | :show    | :identity      |
  #   # | GET    | /identity/new  | Identity::New     | :new     | :new_identity  |
  #   # | POST   | /identity      | Identity::Create  | :create  | :identity      |
  #   # | GET    | /identity/edit | Identity::Edit    | :edit    | :edit_identity |
  #   # | PATCH  | /identity      | Identity::Update  | :update  | :identity      |
  #   # | DELETE | /identity      | Identity::Destroy | :destroy | :identity      |
  #   # +--------+----------------+-------------------+----------+----------------+
  # @example Limit the generated routes with :only
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resource 'identity', only: [:show, :new, :create]
  #   end
  #
  #   # It generates:
  #   #
  #   # +--------+----------------+------------------+----------+----------------+
  #   # | Verb   | Path           | Action           | Name     | Named Route    |
  #   # +--------+----------------+------------------+----------+----------------+
  #   # | GET    | /identity      | Identity::Show   | :show    | :identity      |
  #   # | GET    | /identity/new  | Identity::New    | :new     | :new_identity  |
  #   # | POST   | /identity      | Identity::Create | :create  | :identity      |
  #   # +--------+----------------+------------------+----------+----------------+
  # @example Limit the generated routes with :except
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resource 'identity', except: [:edit, :update, :destroy]
  #   end
  #
  #   # It generates:
  #   #
  #   # +--------+----------------+------------------+----------+----------------+
  #   # | Verb   | Path           | Action           | Name     | Named Route    |
  #   # +--------+----------------+------------------+----------+----------------+
  #   # | GET    | /identity      | Identity::Show   | :show    | :identity      |
  #   # | GET    | /identity/new  | Identity::New    | :new     | :new_identity  |
  #   # | POST   | /identity      | Identity::Create | :create  | :identity      |
  #   # +--------+----------------+------------------+----------+----------------+
  # @example Additional single routes
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resource 'identity', only: [] do
  #   member do
  #   patch 'activate'
  #   end
  #   end
  #   end
  #
  #   # It generates:
  #   #
  #   # +--------+--------------------+--------------------+------+--------------------+
  #   # | Verb   | Path               | Action             | Name | Named Route        |
  #   # +--------+--------------------+--------------------+------+--------------------+
  #   # | PATCH  | /identity/activate | Identity::Activate |      | :activate_identity |
  #   # +--------+--------------------+--------------------+------+--------------------+
  # @example Additional collection routes
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resource 'identity', only: [] do
  #   collection do
  #   get 'keys'
  #   end
  #   end
  #   end
  #
  #   # It generates:
  #   #
  #   # +------+----------------+----------------+------+----------------+
  #   # | Verb | Path           | Action         | Name | Named Route    |
  #   # +------+----------------+----------------+------+----------------+
  #   # | GET  | /identity/keys | Identity::Keys |      | :keys_identity |
  #   # +------+----------------+----------------+------+----------------+
  # @option options
  # @option options
  # @param name [String] the name of the resource
  # @param options [Hash] a set of options to customize the routes
  # @param blk [Proc] a block of code to generate additional routes
  # @return [Hanami::Routing::Resource]
  # @see Hanami::Routing::Resource
  # @see Hanami::Routing::Resource::Action
  # @see Hanami::Routing::Resource::Options
  # @since 0.1.0
  def resource(name, options = T.unsafe(nil), &blk); end

  # Defines a set of named routes for a plural RESTful resource.
  # It has a built-in integration for Hanami::Controller.
  #
  # @example Default usage
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resources 'articles'
  #   end
  #
  #   # It generates:
  #   #
  #   # +--------+--------------------+-------------------+----------+----------------+
  #   # | Verb   | Path               | Action            | Name     | Named Route    |
  #   # +--------+--------------------+-------------------+----------+----------------+
  #   # | GET    | /articles          | Articles::Index   | :index   | :articles      |
  #   # | GET    | /articles/:id      | Articles::Show    | :show    | :articles      |
  #   # | GET    | /articles/new      | Articles::New     | :new     | :new_articles  |
  #   # | POST   | /articles          | Articles::Create  | :create  | :articles      |
  #   # | GET    | /articles/:id/edit | Articles::Edit    | :edit    | :edit_articles |
  #   # | PATCH  | /articles/:id      | Articles::Update  | :update  | :articles      |
  #   # | DELETE | /articles/:id      | Articles::Destroy | :destroy | :articles      |
  #   # +--------+--------------------+-------------------+----------+----------------+
  # @example Limit the generated routes with :only
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resources 'articles', only: [:index]
  #   end
  #
  #   # It generates:
  #   #
  #   # +------+-----------+-----------------+--------+-------------+
  #   # | Verb | Path      | Action          | Name   | Named Route |
  #   # +------+-----------+-----------------+--------+-------------+
  #   # | GET  | /articles | Articles::Index | :index | :articles   |
  #   # +------+-----------+-----------------+--------+-------------+
  # @example Limit the generated routes with :except
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resources 'articles', except: [:edit, :update]
  #   end
  #
  #   # It generates:
  #   #
  #   # +--------+--------------------+-------------------+----------+----------------+
  #   # | Verb   | Path               | Action            | Name     | Named Route    |
  #   # +--------+--------------------+-------------------+----------+----------------+
  #   # | GET    | /articles          | Articles::Index   | :index   | :articles      |
  #   # | GET    | /articles/:id      | Articles::Show    | :show    | :articles      |
  #   # | GET    | /articles/new      | Articles::New     | :new     | :new_articles  |
  #   # | POST   | /articles          | Articles::Create  | :create  | :articles      |
  #   # | DELETE | /articles/:id      | Articles::Destroy | :destroy | :articles      |
  #   # +--------+--------------------+-------------------+----------+----------------+
  # @example Additional single routes
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resources 'articles', only: [] do
  #   member do
  #   patch 'publish'
  #   end
  #   end
  #   end
  #
  #   # It generates:
  #   #
  #   # +--------+-----------------------+-------------------+------+-------------------+
  #   # | Verb   | Path                  | Action            | Name | Named Route       |
  #   # +--------+-----------------------+-------------------+------+-------------------+
  #   # | PATCH  | /articles/:id/publish | Articles::Publish |      | :publish_articles |
  #   # +--------+-----------------------+-------------------+------+-------------------+
  # @example Additional collection routes
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resources 'articles', only: [] do
  #   collection do
  #   get 'search'
  #   end
  #   end
  #   end
  #
  #   # It generates:
  #   #
  #   # +------+------------------+------------------+------+------------------+
  #   # | Verb | Path             | Action           | Name | Named Route      |
  #   # +------+------------------+------------------+------+------------------+
  #   # | GET  | /articles/search | Articles::Search |      | :search_articles |
  #   # +------+------------------+------------------+------+------------------+
  # @option options
  # @option options
  # @param name [String] the name of the resource
  # @param options [Hash] a set of options to customize the routes
  # @param blk [Proc] a block of code to generate additional routes
  # @return [Hanami::Routing::Resources]
  # @see Hanami::Routing::Resources
  # @see Hanami::Routing::Resources::Action
  # @see Hanami::Routing::Resource::Options
  # @since 0.1.0
  def resources(name, options = T.unsafe(nil), &blk); end

  # Defines a root route (a GET route for '/')
  #
  # @example Fixed matching string
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.root to: ->(env) { [200, {}, ['Hello from Hanami!']] }
  # @example Included names as `root` (for path and url helpers)
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new(scheme: 'https', host: 'hanamirb.org')
  #   router.root to: ->(env) { [200, {}, ['Hello from Hanami!']] }
  #
  #   router.path(:root) # => "/"
  #   router.url(:root)  # => "https://hanamirb.org/"
  # @option options
  # @param options [Hash] the options to customize the route
  # @param blk [Proc] the anonymous proc to be used as endpoint for the route
  # @return [Hanami::Routing::Route] this may vary according to the :route
  #   option passed to the constructor
  # @since 0.7.0
  def root(options = T.unsafe(nil), &blk); end

  # Returns self
  #
  # This is a duck-typing trick for compatibility with `Hanami::Application`.
  # It's used by `Hanami::Routing::RoutesInspector` to inspect both apps and
  # routers.
  #
  # @api private
  # @return [self]
  # @since 0.2.0
  def routes; end

  # Defines a route that accepts a TRACE request for the given path.
  #
  # @option options
  # @param path [String] the relative URL to be matched
  # @param options [Hash] the options to customize the route
  # @param blk [Proc] the anonymous proc to be used as endpoint for the route
  # @return [Hanami::Routing::Route] this may vary according to the :route
  #   option passed to the constructor
  # @see Hanami::Router#get
  # @since 0.1.0
  def trace(path, options = T.unsafe(nil), &blk); end

  # Defines a route that accepts an UNLINK request for the given path.
  #
  # @option options
  # @param path [String] the relative URL to be matched
  # @param options [Hash] the options to customize the route
  # @param blk [Proc] the anonymous proc to be used as endpoint for the route
  # @return [Hanami::Routing::Route] this may vary according to the :route
  #   option passed to the constructor
  # @see Hanami::Router#get
  # @since 0.8.0
  def unlink(path, options = T.unsafe(nil), &blk); end

  # Generate a URL for a specified named route.
  # The additional arguments will be used to compose the relative URL - in
  #   case it has tokens to match - and for compose the query string.
  #
  # @example
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new(scheme: 'https', host: 'hanamirb.org')
  #   router.get '/login', to: 'sessions#new', as: :login
  #   router.get '/:name', to: 'frameworks#show', as: :framework
  #
  #   router.url(:login)                          # => "https://hanamirb.org/login"
  #   router.url(:login, return_to: '/dashboard') # => "https://hanamirb.org/login?return_to=%2Fdashboard"
  #   router.url(:framework, name: 'router')      # => "https://hanamirb.org/router"
  # @param route [Symbol] the route name
  # @raise [Hanami::Routing::InvalidRouteException] when the router fails to
  #   recognize a route, because of the given arguments.
  # @return [String]
  # @since 0.1.0
  def url(route, *args); end

  protected

  # Fabricate Rack env for the given Rack env, path or named route
  #
  # @api private
  # @param env [Hash, String, Symbol] Rack env, path or route name
  # @param options [Hash] a set of options for Rack env or route params
  # @param params [Hash] a set of params
  # @return [Hash] Rack env
  # @see Hanami::Router#recognize
  # @see http://www.rubydoc.info/github/rack/rack/Rack%2FMockRequest.env_for
  # @since 0.5.0
  def env_for(env, options = T.unsafe(nil), params = T.unsafe(nil)); end

  class << self
    # Returns the given block as it is.
    #
    # When Hanami::Router is used as a standalone gem and the routes are defined
    # into a configuration file, some systems could raise an exception.
    #
    # Imagine the following file into a Ruby on Rails application:
    #
    #   get '/', to: 'api#index'
    #
    # Because Ruby on Rails in production mode use to eager load code and the
    # routes file uses top level method calls, it crashes the application.
    #
    # If we wrap these routes with <tt>Hanami::Router.define</tt>, the block
    # doesn't get yielded but just returned to the caller as it is.
    #
    # Usually the receiver of this block is <tt>Hanami::Router#initialize</tt>,
    # which finally evaluates the block.
    #
    # @example
    #   # apps/web/config/routes.rb
    #   Hanami::Router.define do
    #   get '/', to: 'home#index'
    #   end
    # @param blk [Proc] a set of route definitions
    # @return [Proc] the given block
    # @since 0.5.0
    def define(&blk); end
  end
end

# This error is raised when <tt>#call</tt> is invoked on a non-routable
# recognized route.
#
# @see Hanami::Router#recognize
# @see Hanami::Routing::RecognizedRoute
# @see Hanami::Routing::RecognizedRoute#call
# @see Hanami::Routing::RecognizedRoute#routable?
# @since 0.5.0
class Hanami::Router::NotRoutableEndpointError < ::Hanami::Routing::Error
  # @return [NotRoutableEndpointError] a new instance of NotRoutableEndpointError
  # @since 0.5.0
  def initialize(env); end
end

# @api private
# @since 0.5.0
Hanami::Router::NotRoutableEndpointError::PATH_INFO = T.let(T.unsafe(nil), String)

# @api private
# @since 0.5.0
Hanami::Router::NotRoutableEndpointError::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# Defines root path
#
# @api private
# @see Hanami::Router#root
# @since 0.7.0
Hanami::Router::ROOT_PATH = T.let(T.unsafe(nil), String)

# @since 0.1.0
module Hanami::Routing; end

# Routing endpoint
# This is the object that responds to an HTTP request made against a certain
# path.
#
# The router will use this class for:
#
#   * Classes
#   * Hanami::Action endpoints referenced as a class
#   * Hanami::Action endpoints referenced a string
#   * RESTful resource(s)
#
# @api private
# @example
#   require 'hanami/router'
#
#   Hanami::Router.new do
#   get '/class',               to: RackMiddleware
#   get '/hanami-action-class',  to: Dashboard::Index
#   get '/hanami-action-string', to: 'dashboard#index'
#
#   resource  'identity'
#   resources 'articles'
#   end
# @since 0.1.0
class Hanami::Routing::ClassEndpoint < ::Hanami::Routing::Endpoint
  # Rack interface
  #
  # @api private
  # @since 0.1.0
  def call(env); end
end

# Routing endpoint
# This is the object that responds to an HTTP request made against a certain
# path.
#
# The router will use this class for:
#
#   * Procs and any Rack compatible object (respond to #call)
#
# @api private
# @example
#   require 'hanami/router'
#
#   Hanami::Router.new do
#   get '/proc',     to: ->(env) { [200, {}, ['This will use Hanami::Routing::Endpoint']] }
#   get '/rack-app', to: RackApp.new
#   end
# @since 0.1.0
class Hanami::Routing::Endpoint < ::SimpleDelegator
  # @api private
  # @since 1.0.1
  def destination_path; end

  # @api private
  # @since 0.2.0
  def inspect; end

  # @api private
  # @return [Boolean]
  # @since 1.0.1
  def redirect?; end

  # @api private
  # @return [Boolean]
  # @since 1.0.0
  def routable?; end
end

# Endpoint not found
# This is raised when the router fails to load an endpoint at the runtime.
#
# @since 0.1.0
class Hanami::Routing::EndpointNotFound < ::Hanami::Routing::Error; end

# Resolve duck-typed endpoints
#
# @api private
# @since 0.1.0
class Hanami::Routing::EndpointResolver
  # Initialize an endpoint resolver
  #
  # @api private
  # @example Specify custom endpoint class
  #   require 'hanami/router'
  #
  #   resolver = Hanami::Routing::EndpointResolver.new(endpoint: CustomEndpoint)
  #   router   = Hanami::Router.new(resolver: resolver)
  #
  #   router.get('/', to: endpoint).dest # => #<CustomEndpoint:0x007f97f3359570 ...>
  # @example Specify custom Ruby namespace
  #   require 'hanami/router'
  #
  #   resolver = Hanami::Routing::EndpointResolver.new(namespace: MyApp)
  #   router   = Hanami::Router.new(resolver: resolver)
  #
  #   router.get('/', to: 'articles#show')
  #   # => Will look for: MyApp::Articles::Show
  # @example Specify custom pattern
  #   require 'hanami/router'
  #
  #   resolver = Hanami::Routing::EndpointResolver.new(pattern: '%{controller}Controller::%{action}')
  #   router   = Hanami::Router.new(resolver: resolver)
  #
  #   router.get('/', to: 'articles#show')
  #   # => Will look for: ArticlesController::Show
  # @example Specify custom controller-action separator
  #   require 'hanami/router'
  #
  #   resolver = Hanami::Routing::EndpointResolver.new(separator: '@')
  #   router   = Hanami::Router.new(resolver: resolver)
  #
  #   router.get('/', to: 'articles@show')
  #   # => Will look for: Articles::Show
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] the options used to customize lookup behavior
  # @return [Hanami::Routing::EndpointResolver] self
  # @since 0.1.0
  def initialize(options = T.unsafe(nil)); end

  # @api private
  # @since 0.1.0
  def action_separator; end

  # Finds a path from the given options.
  #
  # @api private
  # @option options
  # @option options
  # @param options [Hash] the path description
  # @return [Object]
  # @since 0.1.0
  def find(options); end

  # Resolve the given set of HTTP verb, path, endpoint and options.
  # If it fails to resolve, it will mount the default endpoint to the given
  # path, which returns an 404 (Not Found).
  #
  # @api private
  # @example Resolve to a Proc
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get '/', to: ->(env) { [200, {}, ['Hi!']] }
  # @example Resolve to a class
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get '/', to: RackMiddleware
  # @example Resolve to a Rack compatible object (respond to #call)
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get '/', to: AnotherMiddleware.new
  # @example Resolve to a Hanami::Action from a string (see Hanami::Controller framework)
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get '/', to: 'articles#show'
  # @example Resolve to a Hanami::Action (see Hanami::Controller framework)
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get '/', to: Articles::Show
  # @example Resolve a redirect with a namespace
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.namespace 'users' do
  #   get '/home',           to: ->(env) { ... }
  #   redirect '/dashboard', to: '/home'
  #   end
  #
  #   # GET /users/dashboard => 301 Location: "/users/home"
  # @option options
  # @option options
  # @param options [Hash] the options required to resolve the endpoint
  # @return [Endpoint] this may vary according to the :endpoint option
  #   passed to #initialize
  # @see #initialize
  # @see #find
  # @since 0.1.0
  def resolve(options, &endpoint); end

  protected

  # @api private
  # @since 0.1.0
  def classify(string); end

  # @api private
  # @since 0.1.0
  def constantize(string); end

  # @api private
  # @since 0.1.0
  def default; end

  private

  # @api private
  # @since 0.1.0
  def resolve_action(string); end

  # @api private
  # @since 0.1.0
  def resolve_callable(callable); end

  # @api private
  # @since 0.1.0
  def resolve_matchable(matchable); end
end

# Default separator for controller and action.
# A different separator can be passed to #initialize with the `:separator` option.
#
# @api private
# @example
#   require 'hanami/router'
#
#   router = Hanami::Router.new do
#   get '/', to: 'articles#show'
#   end
# @see #initialize
# @see #resolve
# @since 0.1.0
Hanami::Routing::EndpointResolver::ACTION_SEPARATOR = T.let(T.unsafe(nil), String)

# @api private
# @since 0.7.0
Hanami::Routing::EndpointResolver::DEFAULT_RESPONSE = T.let(T.unsafe(nil), Array)

# @api private
# @since 0.2.0
Hanami::Routing::EndpointResolver::NAMING_PATTERN = T.let(T.unsafe(nil), String)

# @since 0.5.0
class Hanami::Routing::Error < ::StandardError; end

# Force ssl
#
# Redirect response to the secure equivalent resource (https)
#
# @api private
# @since 0.4.1
class Hanami::Routing::ForceSsl
  # Initialize ForceSsl.
  #
  # @api private
  # @option options
  # @option options
  # @param active [Boolean] activate redirection to SSL
  # @param options [Hash] set of options
  # @return [ForceSsl] a new instance of ForceSsl
  # @since 0.4.1
  def initialize(active, options = T.unsafe(nil)); end

  # Set 301 status and Location header if this feature is activated.
  #
  # @api private
  # @param env [Hash] a Rack env instance
  # @return [Array]
  # @see Hanami::Routing::HttpRouter#call
  # @since 0.4.1
  def call(env); end

  # Check if router has to force the response with ssl
  #
  # @api private
  # @return [Boolean]
  # @since 0.4.1
  def force?(env); end

  private

  # @api private
  # @since 0.4.1
  def _redefine_call; end

  # Return full url to redirect
  #
  # @api private
  # @param env [Hash] Rack env
  # @return [String]
  # @since 0.4.1
  def full_url(env); end

  # @api private
  # @since 0.4.1
  def host; end

  # Return correct default port for full url
  #
  # @api private
  # @return [Integer]
  # @since 0.4.1
  def port; end

  # Return redirect code
  #
  # @api private
  # @param env [Hash] Rack env
  # @return [Integer]
  # @since 0.4.1
  def redirect_code(env); end

  # Adapted from Rack::Request#scheme
  #
  # @api private
  # @since 0.4.1
  def scheme(env); end

  # @api private
  # @return [Boolean]
  # @since 0.4.1
  def ssl?(env); end
end

# Default http port
#
# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::DEFAULT_HTTP_PORT = T.let(T.unsafe(nil), Integer)

# Default ssl port
#
# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::DEFAULT_SSL_PORT = T.let(T.unsafe(nil), Integer)

# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::EMPTY_BODY = T.let(T.unsafe(nil), Array)

# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::HTTPS = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::HTTP_X_FORWARDED_PROTO_SEPARATOR = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::IDEMPOTENT_METHODS = T.let(T.unsafe(nil), Array)

# Location header
#
# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::LOCATION_HEADER = T.let(T.unsafe(nil), String)

# Moved Permanently http code
#
# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::MOVED_PERMANENTLY_HTTP_CODE = T.let(T.unsafe(nil), Integer)

# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::ON = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# Https scheme
#
# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::SSL_SCHEME = T.let(T.unsafe(nil), String)

# Temporary Redirect http code
#
# @api private
# @since 0.4.1
Hanami::Routing::ForceSsl::TEMPORARY_REDIRECT_HTTP_CODE = T.let(T.unsafe(nil), Integer)

# HTTP router
#
# This implementation is based on ::HttpRouter (http_router gem).
#
# Hanami::Router wraps an instance of this class, in order to protect its
# public API from any future change of ::HttpRouter.
#
# @api private
# @since 0.1.0
class Hanami::Routing::HttpRouter < ::HttpRouter
  # Initialize the router.
  #
  # @api private
  # @return [HttpRouter] a new instance of HttpRouter
  # @see Hanami::Router#initialize
  # @since 0.1.0
  def initialize(options = T.unsafe(nil), &blk); end

  # Separator between controller and action name.
  #
  # @api private
  # @see Hanami::Routing::EndpointResolver::ACTION_SEPARATOR
  # @since 0.1.0
  def action_separator; end

  # Finds a path from the given options.
  #
  # @api private
  # @see Hanami::Routing::EndpointResolver#find
  # @since 0.1.0
  def find(options); end

  # Allow to mount a Rack app
  #
  # @api private
  # @see Hanami::Router#mount
  # @since 0.1.1
  def mount(app, options); end

  # @api private
  # @since 0.5.0
  def namespace; end

  # @api private
  # @since 0.1.0
  def no_response(request, env); end

  # Support for OPTIONS HTTP verb
  #
  # @api private
  # @see Hanami::Router#options
  # @since 0.1.0
  def options(path, options = T.unsafe(nil), &blk); end

  # @api private
  # @since 0.1.0
  def pass_on_response(response); end

  # @api private
  # @since 0.8.0
  def prefix; end

  # @api private
  # @since 0.1.0
  def raw_call(env, &blk); end

  # Generate a relative URL for a specified named route.
  #
  # @api private
  # @see Hanami::Router#path
  # @since 0.1.0
  def raw_path(route, *args); end

  # Generate an absolute URL for a specified named route.
  #
  # @api private
  # @see Hanami::Router#path
  # @since 0.1.0
  def raw_url(route, *args); end

  # @api private
  # @since 0.1.0
  def reset!; end

  # @api private
  # @since 0.1.0
  def rewrite_partial_path_info(env, request); end

  private

  # @api private
  # @since 0.1.0
  def _custom_path(uri_string); end

  # @api private
  # @since 0.1.0
  def _rescue_url_recognition; end

  # @api private
  # @since 0.1.0
  def add_with_request_method(path, method, opts = T.unsafe(nil), &app); end
end

# Default PATH_INFO for Rack requests
#
# @api private
# @since 0.7.0
Hanami::Routing::HttpRouter::DEFAULT_PATH_INFO = T.let(T.unsafe(nil), String)

# Path info - rack environment variable
#
# @api private
# @since 0.7.0
Hanami::Routing::HttpRouter::PATH_INFO = T.let(T.unsafe(nil), String)

# Script name - rack environment variable
#
# @api private
# @since 0.5.0
Hanami::Routing::HttpRouter::SCRIPT_NAME = T.let(T.unsafe(nil), String)

# URL separator
#
# @api private
# @since 0.7.0
Hanami::Routing::HttpRouter::URL_SEPARATOR = T.let(T.unsafe(nil), String)

# Invalid route
# This is raised when the router fails to recognize a route, because of the
# given arguments.
#
# @since 0.1.0
class Hanami::Routing::InvalidRouteException < ::Hanami::Routing::Error; end

# Routing endpoint
# This is the object that responds to an HTTP request made against a certain
# path.
#
# The router will use this class for the same use cases of `ClassEndpoint`,
# but when the target class can't be found, instead of raise a `LoadError`
# we reference in a lazy endpoint.
#
# For each incoming HTTP request, it will look for the referenced class,
# then it will instantiate and invoke #call on the object.
#
# This behavior is required to solve a chicken-egg situation when we try
# to load the router first and then the application with all its endpoints.
#
# @api private
# @see Hanami::Routing::ClassEndpoint
# @since 0.1.0
class Hanami::Routing::LazyEndpoint < ::Hanami::Routing::Endpoint
  # Initialize the lazy endpoint
  #
  # @api private
  # @return [LazyEndpoint] a new instance of LazyEndpoint
  # @since 0.1.0
  def initialize(name, namespace); end

  # Rack interface
  #
  # @api private
  # @raise [EndpointNotFound] when the endpoint can't be found.
  # @since 0.1.0
  def call(env); end

  # @api private
  # @since 0.2.0
  def inspect; end

  private

  # @api private
  # @since 0.2.0
  def klass; end

  # @api private
  # @since 0.1.0
  def obj; end
end

# Namespace for routes.
# Implementation of Hanami::Router#namespace
#
# @api private
# @see Hanami::Router#namespace
# @since 0.1.0
class Hanami::Routing::Namespace < ::SimpleDelegator
  # @api private
  # @return [Namespace] a new instance of Namespace
  # @since 0.1.0
  def initialize(router, name, &blk); end

  # @api private
  # @since 0.1.0
  def delete(path, options = T.unsafe(nil), &endpoint); end

  # @api private
  # @since 0.1.0
  def get(path, options = T.unsafe(nil), &endpoint); end

  # @api private
  # @since 1.1.0
  def mount(app, options); end

  # Supports nested namespaces
  #
  # @api private
  # @since 0.1.0
  def namespace(name, &blk); end

  # @api private
  # @since 0.1.0
  def options(path, options = T.unsafe(nil), &endpoint); end

  # @api private
  # @since 0.1.0
  def patch(path, options = T.unsafe(nil), &endpoint); end

  # @api private
  # @since 0.1.0
  def post(path, options = T.unsafe(nil), &endpoint); end

  # @api private
  # @since 0.1.0
  def put(path, options = T.unsafe(nil), &endpoint); end

  # @api private
  # @since 0.1.0
  def redirect(path, options = T.unsafe(nil), &endpoint); end

  # @api private
  # @since 0.1.0
  def resource(name, options = T.unsafe(nil)); end

  # @api private
  # @since 0.1.0
  def resources(name, options = T.unsafe(nil)); end

  # @api private
  # @since 0.1.0
  def trace(path, options = T.unsafe(nil), &endpoint); end
end

# @api private
# @since 0.2.0
class Hanami::Routing::Parsers
  # @api private
  # @return [Parsers] a new instance of Parsers
  # @since 0.2.0
  def initialize(parsers); end

  # @api private
  # @since 0.2.0
  def call(env); end

  private

  # @api private
  # @since 0.2.0
  def _parse(env, body); end

  # @api private
  # @since 0.2.0
  def _redefine_call; end

  # @api private
  # @since 0.2.0
  def _symbolize(body); end

  # @api private
  # @since 0.2.0
  def content_type(env); end

  # @api private
  # @since 0.2.0
  def media_type(env); end

  # @api private
  # @since 0.2.0
  def prepare(args); end
end

# @api private
# @since 0.2.0
Hanami::Routing::Parsers::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# @api private
# @since 0.2.0
Hanami::Routing::Parsers::FALLBACK_KEY = T.let(T.unsafe(nil), String)

# @api private
# @since 0.2.0
Hanami::Routing::Parsers::MEDIA_TYPE_MATCHER = T.let(T.unsafe(nil), Regexp)

# @api private
# @since 0.2.0
Hanami::Routing::Parsers::RACK_INPUT = T.let(T.unsafe(nil), String)

# @api private
# @since 0.2.0
Hanami::Routing::Parsers::ROUTER_PARAMS = T.let(T.unsafe(nil), String)

# @api private
# @since 0.2.0
Hanami::Routing::Parsers::ROUTER_PARSED_BODY = T.let(T.unsafe(nil), String)

# @since 0.1.0
module Hanami::Routing::Parsing; end

# Body parsing error
# This is raised when parser fails to parse the body
#
# @since 0.5.0
class Hanami::Routing::Parsing::BodyParsingError < ::Hanami::Routing::Error; end

# @since 0.2.0
class Hanami::Routing::Parsing::Parser
  # @raise [NotImplementedError]
  # @since 0.2.0
  def mime_types; end

  # @since 0.2.0
  def parse(body); end

  class << self
    # @api private
    # @since 0.2.0
    def for(parser); end

    # @api private
    # @since 0.2.0
    def require_parser(parser); end
  end
end

# @since 0.2.0
class Hanami::Routing::Parsing::UnknownParserError < ::Hanami::Routing::Error
  # @api private
  # @return [UnknownParserError] a new instance of UnknownParserError
  # @since 0.2.0
  def initialize(parser); end
end

# @api private
# @since 1.0.1
class Hanami::Routing::RedirectEndpoint < ::Hanami::Routing::Endpoint
  # @api private
  # @return [RedirectEndpoint] a new instance of RedirectEndpoint
  # @since 1.0.1
  def initialize(destination_path, destination); end

  # @api private
  # @since 1.0.1
  def destination_path; end

  # @api private
  # @return [Boolean]
  # @since 1.0.1
  def redirect?; end
end

# Set of RESTful resource routes
# Implementation of Hanami::Router#resource
#
# @api private
# @see Hanami::Router#resource
# @since 0.1.0
class Hanami::Routing::Resource
  include ::Hanami::Utils::ClassAttribute
  extend ::Hanami::Utils::ClassAttribute::ClassMethods

  # @api private
  # @return [Resource] a new instance of Resource
  # @since 0.1.0
  def initialize(router, name, options = T.unsafe(nil), parent = T.unsafe(nil), &blk); end

  # @api private
  # @since 0.4.0
  def parent; end

  # Allow nested resource inside resource or resources
  #
  # @api private
  # @see Hanami::Router#resource
  # @since 0.4.0
  def resource(name, options = T.unsafe(nil), &blk); end

  # Allow nested resources inside resource or resources
  #
  # @api private
  # @see Hanami::Router#resources
  # @since 0.4.0
  def resources(name, options = T.unsafe(nil), &blk); end

  # Return separator
  #
  # @api private
  # @since 0.4.0
  def wildcard_param(route_param = T.unsafe(nil)); end

  private

  # @api private
  # @since 0.4.0
  def _resource(klass, name, options, &blk); end

  # @api private
  # @since 0.1.0
  def collection(&blk); end

  # @api private
  # @since 0.1.0
  def generate(&blk); end

  # @api private
  # @since 0.1.0
  def member(&blk); end

  class << self
    def action; end
    def action=(_arg0); end
    def actions; end
    def actions=(_arg0); end
    def collection; end
    def collection=(_arg0); end
    def member; end
    def member=(_arg0); end
  end
end

# Action for RESTful resource
#
# @api private
# @see Hanami::Router#resource
# @since 0.1.0
class Hanami::Routing::Resource::Action
  include ::Hanami::Utils::ClassAttribute
  extend ::Hanami::Utils::ClassAttribute::ClassMethods

  # Initialize an action
  #
  # @api private
  # @param router [Hanami::Router]
  # @param options [Hash]
  # @param resource [Hanami::Routing::Resource, Hanami::Routing::Resources]
  # @param blk [Proc]
  # @return [Action] a new instance of Action
  # @since 0.1.0
  def initialize(router, options = T.unsafe(nil), resource = T.unsafe(nil), &blk); end

  # Generate an action for the given router
  #
  # @api private
  # @param blk [Proc]
  # @since 0.1.0
  def generate(&blk); end

  # Namespace
  #
  # @api private
  # @since 0.2.0
  def namespace; end

  # Resource name
  #
  # @api private
  # @example
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resource 'identity'
  #   end
  #
  #   # 'identity' is the name passed in the @options
  # @return [String]
  # @since 0.1.0
  def resource_name; end

  private

  # Create nested rest path
  #
  # @api private
  # @since 0.4.0
  def _nested_rest_path; end

  # Singularize as (helper route)
  #
  # @api private
  # @since 0.4.0
  def _singularized_as; end

  # The name of the RESTful action.
  #
  # @api private
  # @example
  #   'index'
  #   'new'
  #   'create'
  # @since 0.1.0
  def action_name; end

  # The namespaced name of the action within the whole context of the router.
  #
  # @api private
  # @example
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resources 'flowers'
  #
  #   namespace 'animals' do
  #   resources 'mammals'
  #   end
  #   end
  #
  #   # It will generate named routes like :flowers, :new_flowers ..
  #   # It will generate named routes like :animals_mammals, :animals_new_mammals ..
  # @since 0.1.0
  def as; end

  # Resource controller name
  #
  # @api private
  # @example
  #   Hanami::Router.new do
  #   resources 'flowers', controller: 'rocks'
  #   end
  #
  #   # It will mount path 'flowers/new' to Rocks::New instead of Flowers::New
  #   # Same for other action names
  # @since 0.4.0
  def controller_name; end

  # A string that represents the endpoint to be loaded.
  # It is composed by controller and action name.
  #
  # @api private
  # @example
  #   'flowers#index'
  # @see Hanami::Routing::Resource::Action#separator
  # @since 0.1.0
  def endpoint; end

  # The namespaced URL relative path
  #
  # @api private
  # @example
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resources 'flowers'
  #
  #   namespace 'animals' do
  #   resources 'mammals'
  #   end
  #   end
  #
  #   # It will generate paths like '/flowers', '/flowers/:id' ..
  #   # It will generate paths like '/animals/mammals', '/animals/mammals/:id' ..
  # @since 0.1.0
  def path; end

  # The URL relative path
  #
  # @api private
  # @example
  #   '/flowers'
  #   '/flowers/new'
  #   '/flowers/:id'
  # @since 0.1.0
  def rest_path; end

  # Separator between controller and action name
  #
  # @api private
  # @example
  #   '#' # default
  # @see Hanami::Routing::EndpointResolver#separator
  # @since 0.1.0
  def separator; end

  # Accepted HTTP verb
  #
  # @api private
  # @see Hanami::Routing::Resource::Action.verb
  # @since 0.1.0
  def verb; end

  class << self
    # Load a subclass, according to the given action name
    #
    # @api private
    # @example
    #   Hanami::Routing::Resource::Action.send(:class_for, 'New') # =>
    #   Hanami::Routing::Resource::New
    # @param action [String] the action name
    # @since 0.1.0
    def class_for(action); end

    # Generate an action for the given router
    #
    # @api private
    # @param router [Hanami::Router]
    # @param action [Hanami::Routing::Resource::Action]
    # @param options [Hash]
    # @param resource [Hanami::Routing::Resource, Hanami::Routing::Resources]
    # @since 0.1.0
    def generate(router, action, options = T.unsafe(nil), resource = T.unsafe(nil)); end

    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Nested routes separator
#
# @api private
# @since 0.4.0
Hanami::Routing::Resource::Action::NESTED_ROUTES_SEPARATOR = T.let(T.unsafe(nil), String)

# Collection action
# It implements #collection within a #resource block.
#
# @api private
# @see Hanami::Router#resource
# @since 0.1.0
class Hanami::Routing::Resource::CollectionAction < ::Hanami::Routing::Resource::Action
  # @api private
  # @since 0.1.0
  def generate(&blk); end

  protected

  # @api private
  # @since 0.1.0
  def method_missing(m, *args); end

  private

  # @api private
  # @since 0.1.0
  def as(action_name); end

  # @api private
  # @since 0.1.0
  def endpoint(action_name); end

  # @api private
  # @since 0.1.0
  def path(action_name); end

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Create action
#
# @api private
# @see Hanami::Router#resource
# @since 0.1.0
class Hanami::Routing::Resource::Create < ::Hanami::Routing::Resource::Action
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Implementation of common methods for concrete member actions
#
# @api private
# @since 0.1.0
module Hanami::Routing::Resource::DefaultMemberAction
  private

  # @api private
  # @since 0.1.0
  def as; end

  # @api private
  # @since 0.1.0
  def path; end
end

# Destroy action
#
# @api private
# @see Hanami::Router#resource
# @since 0.1.0
class Hanami::Routing::Resource::Destroy < ::Hanami::Routing::Resource::Action
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Edit action
#
# @api private
# @see Hanami::Router#resource
# @since 0.1.0
class Hanami::Routing::Resource::Edit < ::Hanami::Routing::Resource::Action
  include ::Hanami::Routing::Resource::DefaultMemberAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Collection action
# It implements #member within a #resource block.
#
# @api private
# @see Hanami::Router#resource
# @since 0.1.0
class Hanami::Routing::Resource::MemberAction < ::Hanami::Routing::Resource::CollectionAction
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# @api private
# @since 0.4.0
Hanami::Routing::Resource::NESTED_ROUTES_SEPARATOR = T.let(T.unsafe(nil), String)

# Helper class to calculate nested path
#
# @api private
# @since 0.4.0
class Hanami::Routing::Resource::Nested
  # @api private
  # @return [Nested] a new instance of Nested
  # @since 0.4.0
  def initialize(resource_name, resource); end

  # @api private
  # @since 0.4.0
  def to_path; end

  private

  # @api private
  # @since 0.4.0
  def _calculate(param_wildcard, resource = T.unsafe(nil)); end
end

# @api private
# @since 0.4.0
Hanami::Routing::Resource::Nested::SEPARATOR = T.let(T.unsafe(nil), String)

# New action
#
# @api private
# @see Hanami::Router#resource
# @since 0.1.0
class Hanami::Routing::Resource::New < ::Hanami::Routing::Resource::Action
  include ::Hanami::Routing::Resource::DefaultMemberAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Options for RESTFul resource(s)
#
# @api private
# @see Hanami::Router#resource
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resource::Options
  # Initialize the options for:
  #   * Hanami::Router#resource
  #   * Hanami::Router#resources
  #
  # @api private
  # @example
  #   require 'hanami/router'
  #
  #   Hanami::Router.new do
  #   resources 'articles', only:   [:index]
  #   resource  'profile',  except: [:new, :create, :destroy]
  #   end
  # @option options
  # @option options
  # @option options
  # @param actions [Array<Symbol>] the name of the actions
  # @param options [Hash]
  # @return [Options] a new instance of Options
  # @see Hanami::Routing::Resource
  # @see Hanami::Routing::Resources
  # @since 0.1.0
  def initialize(actions, options = T.unsafe(nil)); end

  # Return the option for the given key
  #
  # @api private
  # @param key [Symbol] the key that should be searched
  # @return [Object, nil] returns the object associated to the given key
  #   or nil, if missing.
  # @since 0.1.1
  def [](key); end

  # @api private
  # @since 0.1.0
  def actions; end

  # Merge the current options with the given hash, without mutating self.
  #
  # @api private
  # @param hash [Hash] the hash to be merged
  # @return [Hash] the result of the merging operation
  # @since 0.1.1
  def merge(hash); end
end

# Show action
#
# @api private
# @see Hanami::Router#resource
# @since 0.1.0
class Hanami::Routing::Resource::Show < ::Hanami::Routing::Resource::Action
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Update action
#
# @api private
# @see Hanami::Router#resource
# @since 0.1.0
class Hanami::Routing::Resource::Update < ::Hanami::Routing::Resource::Action
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Set of RESTful resources routes
# Implementation of Hanami::Router#resources
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources < ::Hanami::Routing::Resource
  # Return wildcard param between separators
  #
  # @api private
  # @since 0.4.0
  def wildcard_param(route_param = T.unsafe(nil)); end

  class << self
    def action; end
    def action=(_arg0); end
    def actions; end
    def actions=(_arg0); end
    def collection; end
    def collection=(_arg0); end
    def member; end
    def member=(_arg0); end
  end
end

# Action for RESTful resources
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources::Action < ::Hanami::Routing::Resource::Action
  class << self
    def identifier; end
    def identifier=(_arg0); end
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Collection action
# It implements #collection within a #resources block.
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources::CollectionAction < ::Hanami::Routing::Resource::CollectionAction
  # @api private
  # @since 0.1.0
  def as(action_name); end

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Create action
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources::Create < ::Hanami::Routing::Resource::Create
  include ::Hanami::Routing::Resources::PluralizedAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Implementation of common methods for concrete member actions
#
# @api private
# @since 0.1.0
module Hanami::Routing::Resources::DefaultMemberAction
  private

  # @api private
  # @since 0.1.0
  def path; end
end

# Destroy action
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources::Destroy < ::Hanami::Routing::Resource::Destroy
  include ::Hanami::Routing::Resources::DefaultMemberAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Edit action
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources::Edit < ::Hanami::Routing::Resource::Edit
  include ::Hanami::Routing::Resources::DefaultMemberAction

  private

  # @api private
  # @since 0.1.0
  def path; end

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Index action
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources::Index < ::Hanami::Routing::Resources::Action
  include ::Hanami::Routing::Resources::PluralizedAction

  class << self
    def identifier; end
    def identifier=(_arg0); end
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Member action
# It implements #member within a #resources block.
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources::MemberAction < ::Hanami::Routing::Resource::MemberAction
  private

  # @api private
  # @since 0.1.0
  def path(action_name); end

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# New action
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources::New < ::Hanami::Routing::Resource::New
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Pluralize concrete actions
#
# @api private
# @since 0.4.0
module Hanami::Routing::Resources::PluralizedAction
  private

  # The name of the RESTful action.
  #
  # @api private
  # @since 0.4.0
  def as; end
end

# Show action
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources::Show < ::Hanami::Routing::Resource::Show
  include ::Hanami::Routing::Resources::DefaultMemberAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Update action
#
# @api private
# @see Hanami::Router#resources
# @since 0.1.0
class Hanami::Routing::Resources::Update < ::Hanami::Routing::Resource::Update
  include ::Hanami::Routing::Resources::DefaultMemberAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

# Entry of the routing system
#
# @api private
# @api private
# @example
#   require 'hanami/router'
#
#   router = Hanami::Router.new
#   router.get('/', to: endpoint) # => #<Hanami::Routing::Route:0x007f83083ba028 ...>
# @see http://rdoc.info/gems/http_router/HttpRouter/Route
# @since 0.1.0
class Hanami::Routing::Route < ::HttpRouter::Route
  # @api private
  # @return [Route] a new instance of Route
  # @since 0.7.0
  def initialize(*_arg0); end

  # Asks the given resolver to return an endpoint that will be associated
  #   with the other options.
  #
  # @api private
  # @example
  #   require 'hanami/router'
  #
  #   router = Hanami::Router.new
  #   router.get('/', to: endpoint, as: :home_page).name # => :home_page
  #
  #   router.path(:home_page) # => '/'
  # @option options
  # @param resolver [Hanami::Routing::EndpointResolver, #resolve] this may change
  #   according to the :resolve option passed to Hanami::Router#initialize.
  # @param options [Hash] options to customize the route
  # @see Hanami::Router#initialize
  # @since 0.1.0
  def generate(resolver, options = T.unsafe(nil), &endpoint); end

  # Introspect the given route to understand if there is a wrapped
  # router that has an inspector
  #
  # @api private
  # @since 0.2.0
  def nested_router; end

  private

  # @api private
  # @since 0.1.0
  def to=(dest = T.unsafe(nil), &blk); end
end

# This monkey patches http_router to make it Rack 2.0 compatible.
# Details see: https://github.com/hanami/router/issues/136
#
# @api private
class HttpRouter
  def initialize(*args, &blk); end

  def add(*args, &app); end
  def add_route(route); end
  def call(env, &callback); end
  def clone(klass = T.unsafe(nil)); end
  def compiling_call(env, &callback); end
  def compiling_path(route, *args); end
  def compiling_url(route, *args); end
  def compiling_url_ns(route, *args); end
  def default(app); end
  def default_app; end
  def default_app=(_arg0); end
  def default_host; end
  def default_host=(_arg0); end
  def default_port; end
  def default_port=(_arg0); end
  def default_scheme; end
  def default_scheme=(_arg0); end
  def delete(path, opts = T.unsafe(nil), &app); end
  def extend_route(&blk); end
  def get(path, opts = T.unsafe(nil), &app); end
  def head(path, opts = T.unsafe(nil), &app); end
  def ignore_trailing_slash?; end
  def inspect; end
  def link(path, opts = T.unsafe(nil), &app); end
  def named_routes; end
  def no_response(request, env); end
  def nodes; end
  def options(path, opts = T.unsafe(nil), &app); end
  def pass_on_response(response); end
  def patch(path, opts = T.unsafe(nil), &app); end
  def path(route, *args); end
  def post(path, opts = T.unsafe(nil), &app); end
  def process_destination_path(path, env); end
  def put(path, opts = T.unsafe(nil), &app); end
  def raw_call(env, &blk); end
  def raw_path(route, *args); end
  def raw_url(route, *args); end
  def raw_url_ns(route, *args); end
  def recognize(env, &callback); end
  def redirect_trailing_slash?; end
  def reset!; end
  def rewrite_partial_path_info(env, request); end
  def rewrite_path_info(env, request); end
  def root; end
  def route_class; end
  def route_class=(_arg0); end
  def routes; end
  def to_s; end
  def trace(path, opts = T.unsafe(nil), &app); end
  def uncompile; end
  def unlink(path, opts = T.unsafe(nil), &app); end
  def url(route, *args); end
  def url_mount; end
  def url_mount=(_arg0); end
  def url_ns(route, *args); end

  private

  def add_with_request_method(path, method, opts = T.unsafe(nil), &app); end
  def compile; end
end

class HttpRouter::AmbiguousVariableException < ::RuntimeError; end
class HttpRouter::InvalidRequestValueError < ::RuntimeError; end
class HttpRouter::InvalidRouteException < ::RuntimeError; end
class HttpRouter::LeftOverOptions < ::RuntimeError; end
class HttpRouter::MissingParameterException < ::RuntimeError; end

# @api private
class HttpRouter::Node
  def initialize(router, parent, matchers = T.unsafe(nil)); end

  def add_destination(route, path, param_names = T.unsafe(nil)); end
  def add_free_match(regexp); end
  def add_glob; end
  def add_glob_regexp(matcher); end
  def add_host(hosts); end
  def add_lookup(part); end
  def add_match(regexp, matching_indicies = T.unsafe(nil), splitting_indicies = T.unsafe(nil)); end
  def add_request_method(rm); end
  def add_scheme(scheme); end
  def add_spanning_match(regexp, matching_indicies = T.unsafe(nil), splitting_indicies = T.unsafe(nil)); end
  def add_user_agent(uas); end
  def add_variable; end
  def depth; end
  def inspect; end
  def inspect_label; end
  def inspect_matchers_body; end
  def router; end
  def usable?(other); end

  private

  def add(matcher); end
  def inject_root_ivar(obj); end
  def inject_root_methods(code = T.unsafe(nil), &blk); end
  def root; end
  def to_code; end
  def use_named_captures?; end
end

# @api private
class HttpRouter::Node::Path < ::HttpRouter::Node
  def initialize(router, parent, route, path, param_names = T.unsafe(nil)); end

  def duplicates; end
  def dynamic; end
  def dynamic?; end
  def hashify_params(params); end
  def inspect_label; end
  def param_names; end
  def path; end
  def route; end

  # @api private
  def to_code; end

  def usable?(other); end
end

class HttpRouter::RecognizeResponse < ::Struct
  def acceptable_methods; end
  def acceptable_methods=(_); end
  def matches; end
  def matches=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class HttpRouter::TooManyParametersException < ::RuntimeError; end
