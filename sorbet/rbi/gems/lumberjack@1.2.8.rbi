# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `lumberjack` gem.
# Please instead update this file by running `bin/tapioca gem lumberjack`.

# frozen_string_literals: true
module Lumberjack
  class << self
    # Contexts can be used to store tags that will be attached to all log entries in the block.
    #
    # If this method is called with a block, it will set a logging context for the scope of a block.
    # If there is already a context in scope, a new one will be created that inherits
    # all the tags of the parent context.
    #
    # Otherwise, it will return the current context. If one doesn't exist, it will return a new one
    # but that context will not be in any scope.
    def context(&block); end

    # Return true if inside a context block.
    #
    # @return [Boolean]
    def context?; end

    # Return the tags from the current context or nil if there are no tags.
    def context_tags; end

    # Set tags on the current context
    def tag(tags); end

    # Define a unit of work within a block. Within the block supplied to this
    # method, calling +unit_of_work_id+ will return the same value that can
    # This can then be used for tying together log entries.
    #
    # You can specify the id for the unit of work if desired. If you don't supply
    # it, a 12 digit hexidecimal number will be automatically generated for you.
    #
    # For the common use case of treating a single web request as a unit of work, see the
    # Lumberjack::Rack::UnitOfWork class.
    def unit_of_work(id = T.unsafe(nil)); end

    # Get the UniqueIdentifier for the current unit of work.
    def unit_of_work_id; end

    # Set the context to use within a block.
    def use_context(context, &block); end
  end
end

# A context is used to store tags that are then added to all log entries within a block.
class Lumberjack::Context
  # @return [Context] a new instance of Context
  def initialize(parent_context = T.unsafe(nil)); end

  # Get a context tag.
  def [](key); end

  # Set a context tag.
  def []=(key, value); end

  # Clear all the context data.
  def reset; end

  # Set tags on the context.
  def tag(tags); end

  # Returns the value of attribute tags.
  def tags; end
end

# This is an abstract class for logging devices. Subclasses must implement the +write+ method and
# may implement the +close+ and +flush+ methods if applicable.
class Lumberjack::Device
  def cleanup_files!; end

  # Subclasses may implement this method to close the device.
  def close; end

  # Subclasses may implement this method to get the format for log timestamps.
  def datetime_format; end

  # Subclasses may implement this method to set a format for log timestamps.
  def datetime_format=(format); end

  def do_once(file); end

  # Subclasses may implement this method to flush any buffers used by the device.
  def flush; end

  # Subclasses may implement this method to reopen the device.
  def reopen(logdev = T.unsafe(nil)); end

  # Subclasses must implement this method to write a LogEntry.
  #
  # @raise [NotImplementedError]
  def write(entry); end
end

# This log device will append entries to a file and roll the file periodically by date. Files
# are rolled at midnight and can be rolled daily, weekly, or monthly. Archive file names will
# have the date appended to them in the format ".YYYY-MM-DD" for daily, ".week-of-YYYY-MM-DD" for weekly
# and ".YYYY-MM" for monthly. It is not guaranteed that log messages will break exactly on the
# roll period as buffered entries will always be written to the same file.
class Lumberjack::Device::DateRollingLogFile < ::Lumberjack::Device::RollingLogFile
  # Create a new logging device to the specified file. The period to roll the file is specified
  # with the :roll option which may contain a value of :daily, :weekly,
  # or :monthly.
  #
  # @return [DateRollingLogFile] a new instance of DateRollingLogFile
  def initialize(path, options = T.unsafe(nil)); end

  def archive_file_suffix; end

  # @return [Boolean]
  def roll_file?; end

  protected

  def after_roll; end
end

# This is a logging device that appends log entries to a file.
class Lumberjack::Device::LogFile < ::Lumberjack::Device::Writer
  # Create a logger to the file at +path+. Options are passed through to the Writer constructor.
  #
  # @return [LogFile] a new instance of LogFile
  def initialize(path, options = T.unsafe(nil)); end

  # The absolute path of the file being logged to.
  def path; end

  def reopen(logdev = T.unsafe(nil)); end

  private

  def file_stream; end
end

Lumberjack::Device::LogFile::EXTERNAL_ENCODING = T.let(T.unsafe(nil), String)

# This is a logging device that forward log entries to multiple other devices.
class Lumberjack::Device::Multi < ::Lumberjack::Device
  # @return [Multi] a new instance of Multi
  def initialize(*devices); end

  def close; end
  def datetime_format; end
  def datetime_format=(format); end
  def flush; end
  def reopen(logdev = T.unsafe(nil)); end
  def write(entry); end
end

# This is a logging device that produces no output. It can be useful in
# testing environments when log file output is not useful.
class Lumberjack::Device::Null < ::Lumberjack::Device
  # @return [Null] a new instance of Null
  def initialize(*args); end

  def write(entry); end
end

# This is an abstract class for a device that appends entries to a file and periodically archives
# the existing file and starts a one. Subclasses must implement the roll_file? and archive_file_suffix
# methods.
#
# The :keep option can be used to specify a maximum number of rolled log files to keep.
# Older files will be deleted based on the time they were created. The default is to keep all files.
#
# The :min_roll_check option can be used to specify the number of seconds between checking
# the file to determine if it needs to be rolled. The default is to check at most once per second.
class Lumberjack::Device::RollingLogFile < ::Lumberjack::Device::LogFile
  # @return [RollingLogFile] a new instance of RollingLogFile
  def initialize(path, options = T.unsafe(nil)); end

  # Returns a suffix that will be appended to the file name when it is archived.. The suffix should
  # change after it is time to roll the file. The log file will be renamed when it is rolled.
  #
  # @raise [NotImplementedError]
  def archive_file_suffix; end

  # Returns the value of attribute keep.
  def keep; end

  # Sets the attribute keep
  #
  # @param value the value to set the attribute keep to.
  def keep=(_arg0); end

  # Returns the value of attribute path.
  def path; end

  # Roll the log file by renaming it to the archive file name and then re-opening a stream to the log
  # file path. Rolling a file is safe in multi-threaded or multi-process environments.
  def roll_file!; end

  # Return +true+ if the file should be rolled.
  #
  # @raise [NotImplementedError]
  # @return [Boolean]
  def roll_file?; end

  protected

  # This method will be called after a file has been rolled. Subclasses can
  # implement code to reset the state of the device. This method is thread safe.
  def after_roll; end

  # Handle rolling the file before flushing.
  def before_flush; end

  private

  def reopen_file; end
end

# This is a log device that appends entries to a file and rolls the file when it reaches a specified
# size threshold. When a file is rolled, it will have an number extension appended to the file name.
# For example, if the log file is named production.log, the first time it is rolled it will be renamed
# production.log.1, then production.log.2, etc.
class Lumberjack::Device::SizeRollingLogFile < ::Lumberjack::Device::RollingLogFile
  # Create an new log device to the specified file. The maximum size of the log file is specified with
  # the :max_size option. The unit can also be specified: "32K", "100M", "2G" are all valid.
  #
  # @return [SizeRollingLogFile] a new instance of SizeRollingLogFile
  def initialize(path, options = T.unsafe(nil)); end

  def archive_file_suffix; end

  # Returns the value of attribute max_size.
  def max_size; end

  # @return [Boolean]
  def roll_file?; end

  protected

  # Calculate the next archive file name extension.
  def next_archive_number; end
end

# This logging device writes log entries as strings to an IO stream. By default, messages will be buffered
# and written to the stream in a batch when the buffer is full or when +flush+ is called.
#
# Subclasses can implement a +before_flush+ method if they have logic to execute before flushing the log.
# If it is implemented, it will be called before every flush inside a mutex lock.
class Lumberjack::Device::Writer < ::Lumberjack::Device
  # Create a new device to write log entries to a stream. Entries are converted to strings
  # using a Template. The template can be specified using the :template option. This can
  # either be a Proc or a string that will compile into a Template object.
  #
  # If the template is a Proc, it should accept an LogEntry as its only argument and output a string.
  #
  # If the template is a template string, it will be used to create a Template. The
  # :additional_lines and :time_format options will be passed through to the
  # Template constuctor.
  #
  # The default template is "[:time :severity :progname(:pid) #:unit_of_work_id] :message"
  # with additional lines formatted as "\n [#:unit_of_work_id] :message". The unit of
  # work id will only appear if it is present.
  #
  # The size of the internal buffer in bytes can be set by providing :buffer_size (defaults to 32K).
  #
  # @return [Writer] a new instance of Writer
  def initialize(stream, options = T.unsafe(nil)); end

  # The size of the internal buffer. Defaults to 32K.
  def buffer_size; end

  # Set the buffer size in bytes. The device will only be physically written to when the buffer size
  # is exceeded.
  def buffer_size=(value); end

  # Close the underlying stream.
  def close; end

  def datetime_format; end
  def datetime_format=(format); end

  # Flush the underlying stream.
  def flush; end

  # Write an entry to the stream. The entry will be converted into a string using the defined template.
  def write(entry); end

  protected

  # Get the underlying stream.
  def stream; end

  # Set the underlying stream.
  def stream=(_arg0); end

  private

  def write_to_stream(lines); end
end

# Internal buffer to batch writes to the stream.
class Lumberjack::Device::Writer::Buffer
  # @return [Buffer] a new instance of Buffer
  def initialize; end

  def <<(string); end
  def clear; end

  # @return [Boolean]
  def empty?; end

  def pop!; end
  def size; end
end

Lumberjack::Device::Writer::DEFAULT_ADDITIONAL_LINES_TEMPLATE = T.let(T.unsafe(nil), String)
Lumberjack::Device::Writer::DEFAULT_FIRST_LINE_TEMPLATE = T.let(T.unsafe(nil), String)

# This class controls the conversion of log entry messages into a loggable format. This allows you
# to log any object you want and have the logging system deal with converting it into a string.
#
# Formats are added to a Formatter by associating them with a class using the +add+ method. Formats
# are any object that responds to the +call+ method.
#
# By default, all object will be converted to strings using their inspect method except for Strings
# and Exceptions. Strings are not converted and Exceptions are converted using the ExceptionFormatter.
#
# Enumerable objects (including Hash and Array) will call the formatter recursively for each element.
class Lumberjack::Formatter
  # @return [Formatter] a new instance of Formatter
  def initialize; end

  # Add a formatter for a class. The formatter can be specified as either an object
  # that responds to the +call+ method or as a symbol representing one of the predefined
  # formatters, or as a block to the method call.
  #
  # The predefined formatters are: :inspect, :string, :exception, and :pretty_print.
  #
  # You can add multiple classes at once by passing an array of classes.
  #
  # You can also pass class names as strings instead of the classes themselves. This can
  # help avoid loading dependency issues. This applies only to classes; modules cannot be
  # passed in as strings.
  #
  # === Examples
  #
  #   # Use a predefined formatter
  #   formatter.add(MyClass, :pretty_print)
  #
  #   # Pass in a formatter object
  #   formatter.add(MyClass, Lumberjack::Formatter::PrettyPrintFormatter.new)
  #
  #   # Use a block
  #   formatter.add(MyClass){|obj| obj.humanize}
  #
  #   # Add statements can be chained together
  #   formatter.add(MyClass, :pretty_print).add(YourClass){|obj| obj.humanize}
  def add(klass, formatter = T.unsafe(nil), &block); end

  # Compatibility with the Logger::Formatter signature. This method will just convert the message
  # object to a string and ignores the other parameters.
  def call(severity, timestamp, progname, msg); end

  # Remove all formatters including the default formatter. Can be chained to add method calls.
  def clear; end

  # Format a message object as a string.
  def format(message); end

  # Remove the formatter associated with a class. Remove statements can be chained together.
  #
  # You can remove multiple classes at once by passing an array of classes.
  #
  # You can also pass class names as strings instead of the classes themselves. This can
  # help avoid loading dependency issues. This applies only to classes; modules cannot be
  # passed in as strings.
  def remove(klass); end

  private

  # Find the formatter for a class by looking it up using the class hierarchy.
  def formatter_for(klass); end

  class << self
    # Returns a new empty formatter with no mapping. For historical reasons, a formatter
    # is initialized with mappings to help output objects as strings. This will return one
    # without the default mappings.
    def empty; end
  end
end

# Format a Date, Time, or DateTime object. If you don't specify a format in the constructor,
# it will use the ISO-8601 format.
class Lumberjack::Formatter::DateTimeFormatter
  # @return [DateTimeFormatter] a new instance of DateTimeFormatter
  def initialize(format = T.unsafe(nil)); end

  def call(obj); end

  # Returns the value of attribute format.
  def format; end
end

# Format an exception including the backtrace. You can specify an object that
# responds to `call` as a backtrace cleaner. The exception backtrace will be
# passed to this object and the returned array is what will be logged. You can
# use this to clean out superfluous lines.
class Lumberjack::Formatter::ExceptionFormatter
  # @return [ExceptionFormatter] a new instance of ExceptionFormatter
  def initialize(backtrace_cleaner = T.unsafe(nil)); end

  # Returns the value of attribute backtrace_cleaner.
  def backtrace_cleaner; end

  # Sets the attribute backtrace_cleaner
  #
  # @param value the value to set the attribute backtrace_cleaner to.
  def backtrace_cleaner=(_arg0); end

  def call(exception); end

  private

  def clean_backtrace(trace); end
end

# Format an object that has an id as a hash with keys for class and id. This formatter is useful
# as a default formatter for objects pulled from a data store. By default it will use :id as the
# id attribute.
class Lumberjack::Formatter::IdFormatter
  # @return [IdFormatter] a new instance of IdFormatter
  def initialize(id_attribute = T.unsafe(nil)); end

  def call(obj); end
end

# Format an object by calling +inspect+ on it.
class Lumberjack::Formatter::InspectFormatter
  def call(obj); end
end

# No-op formatter that just returns the object itself.
class Lumberjack::Formatter::ObjectFormatter
  def call(obj); end
end

# Format an object with it's pretty print method.
class Lumberjack::Formatter::PrettyPrintFormatter
  # Create a new formatter. The maximum width of the message can be specified with the width
  # parameter (defaults to 79 characters).
  #
  # @return [PrettyPrintFormatter] a new instance of PrettyPrintFormatter
  def initialize(width = T.unsafe(nil)); end

  def call(obj); end

  # Returns the value of attribute width.
  def width; end

  # Sets the attribute width
  #
  # @param value the value to set the attribute width to.
  def width=(_arg0); end
end

# Format an object by calling `to_s` on it.
class Lumberjack::Formatter::StringFormatter
  def call(obj); end
end

# Format an object by calling `to_s` on it and stripping leading and trailing whitespace.
class Lumberjack::Formatter::StripFormatter
  def call(obj); end
end

# Dereference arrays and hashes and recursively call formatters on each element.
class Lumberjack::Formatter::StructuredFormatter
  # @return [StructuredFormatter] a new instance of StructuredFormatter
  def initialize(formatter = T.unsafe(nil)); end

  def call(obj); end

  private

  def call_with_references(obj, references); end
  def with_object_reference(obj, references); end
end

class Lumberjack::Formatter::StructuredFormatter::RecusiveReferenceError < ::StandardError; end
Lumberjack::LINE_SEPARATOR = T.let(T.unsafe(nil), String)

# An entry in a log is a data structure that captures the log message as well as
# information about the system that logged the message.
class Lumberjack::LogEntry
  # @return [LogEntry] a new instance of LogEntry
  def initialize(time, severity, message, progname, pid, tags); end

  def inspect; end

  # Returns the value of attribute message.
  def message; end

  # Sets the attribute message
  #
  # @param value the value to set the attribute message to.
  def message=(_arg0); end

  # Returns the value of attribute pid.
  def pid; end

  # Sets the attribute pid
  #
  # @param value the value to set the attribute pid to.
  def pid=(_arg0); end

  # Returns the value of attribute progname.
  def progname; end

  # Sets the attribute progname
  #
  # @param value the value to set the attribute progname to.
  def progname=(_arg0); end

  # Returns the value of attribute severity.
  def severity; end

  # Sets the attribute severity
  #
  # @param value the value to set the attribute severity to.
  def severity=(_arg0); end

  def severity_label; end

  # Return the tag with the specified name.
  def tag(name); end

  # Returns the value of attribute tags.
  def tags; end

  # Sets the attribute tags
  #
  # @param value the value to set the attribute tags to.
  def tags=(_arg0); end

  # Returns the value of attribute time.
  def time; end

  # Sets the attribute time
  #
  # @param value the value to set the attribute time to.
  def time=(_arg0); end

  def to_s; end

  # Deprecated - backward compatibility with 1.0 API
  def unit_of_work_id; end

  # Deprecated - backward compatibility with 1.0 API
  def unit_of_work_id=(value); end

  private

  def tags_to_s; end
end

Lumberjack::LogEntry::TIME_FORMAT = T.let(T.unsafe(nil), String)
Lumberjack::LogEntry::UNIT_OF_WORK_ID = T.let(T.unsafe(nil), String)

# Logger is a thread safe logging object. It has a compatible API with the Ruby
# standard library Logger class, the Log4r gem, and ActiveSupport::BufferedLogger.
#
# === Example
#
#   logger = Lumberjack::Logger.new
#   logger.info("Starting processing")
#   logger.debug("Processing options #{options.inspect}")
#   logger.fatal("OMG the application is on fire!")
#
# Log entries are written to a logging Device if their severity meets or exceeds the log level.
#
# Devices may use buffers internally and the log entries are not guaranteed to be written until you call
# the +flush+ method. Sometimes this can result in problems when trying to track down extraordinarily
# long running sections of code since it is likely that none of the messages logged before the long
# running code will appear in the log until the entire process finishes. You can set the +:flush_seconds+
# option on the constructor to force the device to be flushed periodically. This will create a new
# monitoring thread, but its use is highly recommended.
#
# Each log entry records the log message and severity along with the time it was logged, the
# program name, process id, and unit of work id. The message will be converted to a string, but
# otherwise, it is up to the device how these values are recorded. Messages are converted to strings
# using a Formatter associated with the logger.
class Lumberjack::Logger
  include ::Lumberjack::Severity

  # Create a new logger to log to a Device.
  #
  # The +device+ argument can be in any one of several formats.
  #
  # If it is a Device object, that object will be used.
  # If it has a +write+ method, it will be wrapped in a Device::Writer class.
  # If it is :null, it will be a Null device that won't record any output.
  # Otherwise, it will be assumed to be file path and wrapped in a Device::LogFile class.
  #
  # This method can take the following options:
  #
  # * :level - The logging level below which messages will be ignored.
  # * :formatter - The formatter to use for outputting messages to the log.
  # * :datetime_format - The format to use for log timestamps.
  # * :tag_formatter - The TagFormatter to use for formatting tags.
  # * :progname - The name of the program that will be recorded with each log entry.
  # * :flush_seconds - The maximum number of seconds between flush calls.
  # * :roll - If the log device is a file path, it will be a Device::DateRollingLogFile if this is set.
  # * :max_size - If the log device is a file path, it will be a Device::SizeRollingLogFile if this is set.
  #
  # All other options are passed to the device constuctor.
  #
  # @return [Logger] a new instance of Logger
  def initialize(device = T.unsafe(nil), options = T.unsafe(nil)); end

  def <<(msg); end

  # ::Logger compatible method to add a log entry.
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # Add a message to the log with a given severity. The message can be either
  # passed in the +message+ argument or supplied with a block. This method
  # is not normally called. Instead call one of the helper functions
  # +fatal+, +error+, +warn+, +info+, or +debug+.
  #
  # The severity can be passed in either as one of the Severity constants,
  # or as a Severity label.
  #
  # === Example
  #
  #   logger.add_entry(Logger::ERROR, exception)
  #   logger.add_entry(Logger::INFO, "Request completed")
  #   logger.add_entry(:warn, "Request took a long time")
  #   logger.add_entry(Logger::DEBUG){"Start processing with options #{options.inspect}"}
  def add_entry(severity, message, progname = T.unsafe(nil), tags = T.unsafe(nil)); end

  # Close the logging device.
  def close; end

  # @return [Boolean]
  def closed?; end

  # Get the timestamp format on the device if it has one.
  def datetime_format; end

  # Set the timestamp format on the device if it is supported.
  def datetime_format=(format); end

  # Log a +DEBUG+ message. The message can be passed in either the +message+ argument or in a block.
  def debug(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Set the log level to debug.
  def debug!; end

  # Return +true+ if +DEBUG+ messages are being logged.
  #
  # @return [Boolean]
  def debug?; end

  # The device being written to
  def device; end

  # The device being written to
  def device=(_arg0); end

  # Log an +ERROR+ message. The message can be passed in either the +message+ argument or in a block.
  def error(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Set the log level to error.
  def error!; end

  # Return +true+ if +ERROR+ messages are being logged.
  #
  # @return [Boolean]
  def error?; end

  # Log a +FATAL+ message. The message can be passed in either the +message+ argument or in a block.
  def fatal(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Set the log level to fatal.
  def fatal!; end

  # Return +true+ if +FATAL+ messages are being logged.
  #
  # @return [Boolean]
  def fatal?; end

  # Flush the logging device. Messages are not guaranteed to be written until this method is called.
  def flush; end

  # Get the Lumberjack::Formatter used to format objects for logging as messages.
  def formatter; end

  # Set the Lumberjack::Formatter used to format objects for logging as messages.
  def formatter=(value); end

  # Log an +INFO+ message. The message can be passed in either the +message+ argument or in a block.
  def info(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Set the log level to info.
  def info!; end

  # Return +true+ if +INFO+ messages are being logged.
  #
  # @return [Boolean]
  def info?; end

  # The time that the device was last flushed.
  def last_flushed_at; end

  # Get the level of severity of entries that are logged. Entries with a lower
  # severity level will be ignored.
  def level; end

  # Set the log level using either an integer level like Logger::INFO or a label like
  # :info or "info"
  def level=(value); end

  # ::Logger compatible method to add a log entry.
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # Get the program name associated with log messages.
  def progname; end

  # Set the name of the program to attach to log entries.
  def progname=(_arg0); end

  # Remove a tag from the current tag context. If this is called inside a block to a
  # call to `tag`, the tags will only be removed for the duration of that block. Otherwise
  # they will be removed from the global tags.
  def remove_tag(*tag_names); end

  def reopen(logdev = T.unsafe(nil)); end

  # Set the program name that is associated with log messages. If a block
  # is given, the program name will be valid only within the block.
  def set_progname(value, &block); end

  # Get the level of severity of entries that are logged. Entries with a lower
  # severity level will be ignored.
  def sev_threshold; end

  # Set the log level using either an integer level like Logger::INFO or a label like
  # :info or "info"
  def sev_threshold=(value); end

  # Silence the logger by setting a new log level inside a block. By default, only +ERROR+ or +FATAL+
  # messages will be logged.
  #
  # === Example
  #
  #   logger.level = Logger::INFO
  #   logger.silence do
  #     do_something   # Log level inside the block is +ERROR+
  #   end
  def silence(temporary_level = T.unsafe(nil), &block); end

  # Set +silencer+ to false to disable silencing the log.
  def silencer; end

  # Set +silencer+ to false to disable silencing the log.
  def silencer=(_arg0); end

  # Set a hash of tags on logger. If a block is given, the tags will only be set
  # for the duration of the block. If this method is called inside such a block,
  # the tags will only be defined on the tags in that block. When the parent block
  # exits, all the tags will be reverted. If there is no block, then the tags will
  # be defined as global and apply to all log statements.
  def tag(tags, &block); end

  # The TagFormatter used for formatting tags for output
  def tag_formatter; end

  # The TagFormatter used for formatting tags for output
  def tag_formatter=(_arg0); end

  # Enable this logger to function like an ActiveSupport::TaggedLogger. This will make the logger
  # API compatible with ActiveSupport::TaggedLogger and is provided as a means of compatibility
  # with other libraries that assume they can call the `tagged` method on a logger to add tags.
  #
  # The tags added with this method are just strings so they are stored in the logger tags
  # in an array under the "tagged" tag. So calling `logger.tagged("foo", "bar")` will result
  # in tags `{"tagged" => ["foo", "bar"]}`.
  def tagged_logger!; end

  # Return all tags in scope on the logger including global tags set on the Lumberjack
  # context, tags set on the logger, and tags set on the current block for the logger.
  def tags; end

  # Log a message when the severity is not known. Unknown messages will always appear in the log.
  # The message can be passed in either the +message+ argument or in a block.
  def unknown(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Remove all tags on the current logger and logging context within a block.
  # You can still set new block scoped tags within theuntagged block and provide
  # tags on individual log methods.
  def untagged(&block); end

  # Log a +WARN+ message. The message can be passed in either the +message+ argument or in a block.
  def warn(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Set the log level to warn.
  def warn!; end

  # Return +true+ if +WARN+ messages are being logged.
  #
  # @return [Boolean]
  def warn?; end

  private

  # Dereference arguments to log calls so we can have methods with compatibility with ::Logger
  def call_add_entry(severity, message_or_progname_or_tags, progname_or_tags, &block); end

  # Create a thread that will periodically call flush.
  def create_flusher_thread(flush_seconds); end

  # Open a logging device.
  def open_device(device, options); end

  # Set a local value for a thread tied to this object within a block.
  def push_thread_local_value(name, value); end

  # Set a local value for a thread tied to this object.
  def set_thread_local_value(name, value); end

  # Get a local value for a thread tied to this object.
  def thread_local_value(name); end

  def write_to_device(entry); end
end

module Lumberjack::Rack; end

# Middleware to create a global context for Lumberjack for the scope of a rack request.
class Lumberjack::Rack::Context
  # @return [Context] a new instance of Context
  def initialize(app); end

  def call(env); end
end

# Support for using the Rails ActionDispatch request id in the log.
# The format is expected to be a random UUID and only the first chunk is used for terseness
# if the abbreviated argument is true.
class Lumberjack::Rack::RequestId
  # @return [RequestId] a new instance of RequestId
  def initialize(app, abbreviated = T.unsafe(nil)); end

  def call(env); end
end

Lumberjack::Rack::RequestId::REQUEST_ID = T.let(T.unsafe(nil), String)

class Lumberjack::Rack::UnitOfWork
  # @return [UnitOfWork] a new instance of UnitOfWork
  def initialize(app); end

  def call(env); end
end

# The standard severity levels for logging messages.
module Lumberjack::Severity
  class << self
    def label_to_level(label); end
    def level_to_label(severity); end
  end
end

# Backward compatibilty with 1.0 API
Lumberjack::Severity::DEBUG = T.let(T.unsafe(nil), Integer)

Lumberjack::Severity::ERROR = T.let(T.unsafe(nil), Integer)
Lumberjack::Severity::FATAL = T.let(T.unsafe(nil), Integer)
Lumberjack::Severity::INFO = T.let(T.unsafe(nil), Integer)
Lumberjack::Severity::SEVERITY_LABELS = T.let(T.unsafe(nil), Array)
Lumberjack::Severity::UNKNOWN = T.let(T.unsafe(nil), Integer)
Lumberjack::Severity::WARN = T.let(T.unsafe(nil), Integer)

# Class for formatting tags. You can register a default formatter and tag
# name specific formatters. Formatters can be either `Lumberjack::Formatter`
# objects or any object that responds to `call`.
#
# tag_formatter = Lumberjack::TagFormatter.new.default(Lumberjack::Formatter.new)
# tag_formatter.add(["password", "email"]) { |value| "***" }
# tag_formatter.add("finished_at", Lumberjack::Formatter::DateTimeFormatter.new("%Y-%m-%dT%H:%m:%S%z"))
class Lumberjack::TagFormatter
  # @return [TagFormatter] a new instance of TagFormatter
  def initialize; end

  # Add a formatter for specific tag names. This can either be a Lumberjack::Formatter
  # or an object that responds to `call` or a block. The default formatter will not be
  # applied.
  def add(names, formatter = T.unsafe(nil), &block); end

  # Remove all formatters.
  def clear; end

  # Add a default formatter applied to all tag values. This can either be a Lumberjack::Formatter
  # or an object that responds to `call` or a block.
  def default(formatter = T.unsafe(nil), &block); end

  # Format a hash of tags using the formatters
  def format(tags); end

  # Remove formatters for specific tag names. The default formatter will still be applied.
  def remove(names); end

  # Remove the default formatter.
  def remove_default; end

  private

  def dereference_formatter(formatter); end
end

# Methods to make Lumberjack::Logger API compatible with ActiveSupport::TaggedLogger.
module Lumberjack::TaggedLoggerSupport
  def clear_tags!; end
  def pop_tags(size = T.unsafe(nil)); end
  def push_tags(*tags); end

  # Compatibility with ActiveSupport::TaggedLogging which only supports adding tags as strings.
  # If a tag looks like "key:value"  or "key=value", it will be added as a key value pair.
  # Otherwise it will be appended to a list named "tagged".
  def tagged(*tags, &block); end
end

class Lumberjack::TaggedLoggerSupport::Formatter
  extend ::Forwardable

  # @return [Formatter] a new instance of Formatter
  def initialize(formatter:, logger:); end

  def __formatter; end
  def clear_tags!(*args, **_arg1, &block); end
  def current_tags; end
  def pop_tags(*args, **_arg1, &block); end
  def push_tags(*args, **_arg1, &block); end
  def tagged(*args, **_arg1, &block); end
  def tags_text; end
end

# Monkey patch for ActiveSupport::TaggedLogger so it doesn't blow up when
# a Lumberjack logger is trying to be wrapped. This module will be automatically
# included in ActiveSupport::TaggedLogger if activesupport is already loaded.
module Lumberjack::TaggedLogging
  mixes_in_class_methods ::Lumberjack::TaggedLogging::ClassMethods

  class << self
    # @private
    def included(base); end
  end
end

module Lumberjack::TaggedLogging::ClassMethods
  def new(logger); end
end

class Lumberjack::Tags
  class << self
    # Ensure keys are strings and expand any values in a hash that are Proc's by calling them and replacing
    # the value with the result. This allows setting global tags with runtime values.
    def expand_runtime_values(hash); end

    # Transform hash keys to strings. This method exists for optimization and backward compatibility.
    # If a hash already has string keys, it will be returned as is.
    def stringify_keys(hash); end
  end
end

# A template converts entries to strings. Templates can contain the following place holders to
# reference log entry values:
#
# * :time
# * :severity
# * :progname
# * :tags
# * :message
#
# Any other words prefixed with a colon will be substituted with the value of the tag with that name.
# If your tag name contains characters other than alpha numerics and the underscore, you must surround it
# with curly brackets: `:{http.request-id}`.
class Lumberjack::Template
  # Create a new template from the markup. The +first_line+ argument is used to format only the first
  # line of a message. Additional lines will be added to the message unformatted. If you wish to format
  # the additional lines, use the :additional_lines options to specify a template. Note that you'll need
  # to provide the line separator character in this template if you want to keep the message on multiple lines.
  #
  # The time will be formatted as YYYY-MM-DDTHH:MM:SSS.SSS by default. If you wish to change the format, you
  # can specify the :time_format option which can be either a time format template as documented in
  # +Time#strftime+ or the values +:milliseconds+ or +:microseconds+ to use the standard format with the
  # specified precision.
  #
  # Messages will have white space stripped from both ends.
  #
  # @return [Template] a new instance of Template
  def initialize(first_line, options = T.unsafe(nil)); end

  # Convert an entry into a string using the template.
  def call(entry); end

  def datetime_format; end
  def datetime_format=(format); end

  private

  # Compile the template string into a value that can be used with sprintf.
  def compile(template); end

  def tag_args(tags, tag_vars); end
end

Lumberjack::Template::MICROSECOND_TIME_FORMAT = T.let(T.unsafe(nil), String)
Lumberjack::Template::MILLISECOND_TIME_FORMAT = T.let(T.unsafe(nil), String)
Lumberjack::Template::PLACEHOLDER_PATTERN = T.let(T.unsafe(nil), Regexp)
Lumberjack::Template::TEMPLATE_ARGUMENT_ORDER = T.let(T.unsafe(nil), Array)
