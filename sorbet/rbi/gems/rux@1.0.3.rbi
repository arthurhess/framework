# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rux` gem.
# Please instead update this file by running `bin/tapioca gem rux`.

module Rux
  class << self
    # Returns the value of attribute buffer.
    def buffer; end

    # Sets the attribute buffer
    #
    # @param value the value to set the attribute buffer to.
    def buffer=(_arg0); end

    def create_buffer; end
    def default_buffer; end
    def default_tag_builder; end
    def default_visitor; end
    def library_paths; end
    def tag(tag_name, attributes = T.unsafe(nil), &block); end

    # Returns the value of attribute tag_builder.
    def tag_builder; end

    # Sets the attribute tag_builder
    #
    # @param value the value to set the attribute tag_builder to.
    def tag_builder=(_arg0); end

    def to_ruby(str, visitor: T.unsafe(nil), pretty: T.unsafe(nil)); end
  end
end

module Rux::AST; end

class Rux::AST::ListNode
  # @return [ListNode] a new instance of ListNode
  def initialize(children); end

  def accept(visitor); end

  # Returns the value of attribute children.
  def children; end
end

class Rux::AST::RubyNode
  # @return [RubyNode] a new instance of RubyNode
  def initialize(code); end

  def accept(visitor); end

  # Returns the value of attribute code.
  def code; end
end

class Rux::AST::StringNode
  # @return [StringNode] a new instance of StringNode
  def initialize(str); end

  def accept(visitor); end

  # Returns the value of attribute str.
  def str; end
end

class Rux::AST::TagNode
  # @return [TagNode] a new instance of TagNode
  def initialize(name, attrs); end

  def accept(visitor); end

  # Returns the value of attribute attrs.
  def attrs; end

  # Returns the value of attribute children.
  def children; end

  # Returns the value of attribute name.
  def name; end
end

class Rux::AST::TextNode
  # @return [TextNode] a new instance of TextNode
  def initialize(text); end

  def accept(visitor); end

  # Returns the value of attribute text.
  def text; end
end

class Rux::Buffer
  # @return [Buffer] a new instance of Buffer
  def initialize(init_str = T.unsafe(nil)); end

  def <<(*obj); end
  def to_s; end
end

class Rux::DefaultTagBuilder
  def call(tag_name, attributes = T.unsafe(nil)); end

  private

  def serialize_attrs(attributes); end
end

class Rux::DefaultVisitor < ::Rux::Visitor
  def visit_list(node); end
  def visit_ruby(node); end
  def visit_string(node); end
  def visit_tag(node); end
  def visit_text(node); end
end

class Rux::File
  # @return [File] a new instance of File
  def initialize(path); end

  def default_outfile; end

  # Returns the value of attribute path.
  def path; end

  def to_ruby(visitor: T.unsafe(nil), **kwargs); end
  def write(outfile = T.unsafe(nil), **kwargs); end

  private

  def contents; end
end

module Rux::Lex; end

class Rux::Lex::CharsetPattern
  # @return [CharsetPattern] a new instance of CharsetPattern
  def initialize(chars); end

  # Returns the value of attribute chars.
  def chars; end

  # @return [Boolean]
  def matches?(char); end

  class << self
    def parse(str); end
  end
end

class Rux::Lex::DefaultPattern
  # @return [Boolean]
  def matches?(_); end
end

class Rux::Lex::NegatedCharsetPattern < ::Rux::Lex::CharsetPattern
  # @return [Boolean]
  def matches?(char); end
end

class Rux::Lex::State
  # @return [State] a new instance of State
  def initialize(name, is_terminal, transitions); end

  def [](chr); end

  # Returns the value of attribute is_terminal.
  def is_terminal; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute is_terminal.
  def terminal?; end

  # Returns the value of attribute transitions.
  def transitions; end

  class << self
    def parse(state_str, transition_strs, inputs); end
  end
end

class Rux::Lex::Transition
  # @return [Transition] a new instance of Transition
  def initialize(input, to_state, advance_count); end

  # Returns the value of attribute advance_count.
  def advance_count; end

  # Returns the value of attribute input.
  def input; end

  # @return [Boolean]
  def matches?(chr); end

  # Returns the value of attribute to_state.
  def to_state; end

  class << self
    def parse(str, input); end
  end
end

class Rux::Lexer
  # @return [Lexer] a new instance of Lexer
  def initialize(source_buffer); end

  def advance; end

  # Returns the value of attribute source_buffer.
  def source_buffer; end

  private

  def current; end
  def each_token; end
end

class Rux::Lexer::EOFError < ::StandardError; end
class Rux::Lexer::TransitionError < ::StandardError; end

class Rux::Parser
  # @return [Parser] a new instance of Parser
  def initialize(lexer); end

  def parse; end

  private

  def attr_ruby_code; end
  def attribute; end
  def attribute_value; end
  def attributes; end
  def consume(*types); end
  def current; end
  def get_next; end

  # @return [Boolean]
  def is?(*types); end

  def literal; end
  def literal_ruby_code; end
  def maybe_consume(type); end
  def pos_of(token); end
  def ruby; end
  def squeeze_lit(lit); end
  def tag; end
  def text_of(token); end
  def type_of(token); end

  class << self
    def parse(str); end
    def parse_file(path); end
  end
end

class Rux::Parser::TagMismatchError < ::StandardError; end
class Rux::Parser::UnexpectedTokenError < ::StandardError; end

class Rux::RubyLexer < ::Parser::Lexer
  # @return [RubyLexer] a new instance of RubyLexer
  def initialize(source_buffer, init_pos); end

  def advance; end
  def advance_orig; end
  def next_lexer(pos); end
  def reset_to(pos); end

  private

  # @return [Boolean]
  def at_inheritance?; end

  # @return [Boolean]
  def at_lt?; end

  # @return [Boolean]
  def at_rux?; end

  def each_token(&block); end

  # @return [Boolean]
  def is?(tok, sym); end

  # @return [Boolean]
  def is_not?(tok, sym); end

  def make_range(start, stop); end
  def populate_queue; end
  def ruby_version; end
end

Rux::RubyLexer::LOOKAHEAD = T.let(T.unsafe(nil), Integer)

class Rux::RuxLexer
  # @return [RuxLexer] a new instance of RuxLexer
  def initialize(source_buffer, init_pos); end

  def advance; end
  def next_lexer(pos); end
  def reset_to(pos); end

  private

  def check_eof; end
  def each_rux_token(&block); end
  def each_token; end
  def make_range(start, stop); end

  # Ruby code can only exist in two places: attribute values and inside tag
  # bodies. Eventually I'd like to also allow passing a Ruby hash to
  # dynamically specify attributes, but we're not there yet.
  #
  # @return [Boolean]
  def ruby_code?(state); end

  class << self
    def parse_pattern(pattern); end

    # See: https://docs.google.com/spreadsheets/d/11ikKuySIKoaj-kFIfhlzebUwH31cRt_1flGjWfk7RMg
    def state_table; end

    def state_table_path; end
  end
end

module Rux::Utils
  extend ::Rux::Utils

  def attr_to_hash_elem(key, value); end
end

class Rux::Visitor
  def visit(node); end
  def visit_children(node); end
  def visit_list(node); end
  def visit_ruby(node); end
  def visit_string(node); end
  def visit_tag(node); end
  def visit_text(node); end
end
