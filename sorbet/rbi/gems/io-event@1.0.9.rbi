# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `io-event` gem.
# Please instead update this file by running `bin/tapioca gem io-event`.

class IO
  include ::Enumerable
  include ::File::Constants
end

class IO::Buffer
  include ::Comparable

  def initialize(*_arg0); end

  def <=>(_arg0); end
  def clear(*_arg0); end
  def copy(*_arg0); end
  def empty?; end
  def external?; end
  def free; end
  def get_string(*_arg0); end
  def get_value(_arg0, _arg1); end
  def hexdump; end
  def inspect; end
  def internal?; end
  def locked; end
  def locked?; end
  def mapped?; end
  def null?; end
  def pread(_arg0, _arg1, _arg2); end
  def pwrite(_arg0, _arg1, _arg2); end
  def read(_arg0, _arg1); end
  def readonly?; end
  def resize(_arg0); end
  def set_string(*_arg0); end
  def set_value(_arg0, _arg1, _arg2); end
  def size; end
  def slice(_arg0, _arg1); end
  def to_s; end
  def transfer; end
  def valid?; end
  def write(_arg0, _arg1); end

  class << self
    def for(_arg0); end
    def map(*_arg0); end
  end
end

class IO::Buffer::AccessError < ::RuntimeError; end
class IO::Buffer::AllocationError < ::RuntimeError; end
IO::Buffer::BIG_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::EXTERNAL = T.let(T.unsafe(nil), Integer)
IO::Buffer::HOST_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::INTERNAL = T.let(T.unsafe(nil), Integer)
class IO::Buffer::InvalidatedError < ::RuntimeError; end
IO::Buffer::LITTLE_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::LOCKED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::LockedError < ::RuntimeError; end
IO::Buffer::MAPPED = T.let(T.unsafe(nil), Integer)
IO::Buffer::NETWORK_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::PAGE_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::PRIVATE = T.let(T.unsafe(nil), Integer)
IO::Buffer::READONLY = T.let(T.unsafe(nil), Integer)

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end

  private

  def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
module IO::Event; end
module IO::Event::Debug; end

# Enforces the selector interface and delegates operations to a wrapped selector instance.
class IO::Event::Debug::Selector
  # @return [Selector] a new instance of Selector
  def initialize(selector); end

  def close; end
  def io_read(fiber, io, buffer, length); end
  def io_wait(fiber, io, events); end
  def io_write(fiber, io, buffer, length); end
  def process_wait(*arguments); end
  def push(fiber); end
  def raise(fiber, *arguments); end

  # @return [Boolean]
  def ready?; end

  def resume(*arguments); end
  def select(duration = T.unsafe(nil)); end

  # Transfer from the calling fiber to the event loop.
  def transfer; end

  def wakeup; end
  def yield; end
end

# A thread safe synchronisation primative.
class IO::Event::Interrupt
  # @return [Interrupt] a new instance of Interrupt
  def initialize(selector); end

  def close; end

  # Send a sigle byte interrupt.
  def signal; end

  class << self
    def attach(selector); end
  end
end

module IO::Event::Selector
  class << self
    def default(env = T.unsafe(nil)); end
    def new(loop, env = T.unsafe(nil)); end
  end
end

class IO::Event::Selector::KQueue
  def initialize(_arg0); end

  def close; end
  def io_read(_arg0, _arg1, _arg2, _arg3); end
  def io_wait(_arg0, _arg1, _arg2); end
  def io_write(_arg0, _arg1, _arg2, _arg3); end
  def loop; end
  def process_wait(_arg0, _arg1, _arg2); end
  def push(_arg0); end
  def raise(*_arg0); end
  def ready?; end
  def resume(*_arg0); end
  def select(_arg0); end
  def transfer; end
  def wakeup; end
  def yield; end
end

class IO::Event::Selector::Select
  # @return [Select] a new instance of Select
  def initialize(loop); end

  def close; end
  def io_read(fiber, io, buffer, length); end
  def io_wait(fiber, io, events); end
  def io_write(fiber, io, buffer, length); end

  # Returns the value of attribute loop.
  def loop; end

  def process_wait(fiber, pid, flags); end

  # Append the given fiber into the ready list.
  def push(fiber); end

  # Transfer to the given fiber and raise an exception. Put the current fiber into the ready list.
  def raise(fiber, *arguments); end

  # @return [Boolean]
  def ready?; end

  # Transfer from the current fiber to the specified fiber. Put the current fiber into the ready list.
  def resume(fiber, *arguments); end

  def select(duration = T.unsafe(nil)); end

  # Transfer from the current fiber to the event loop.
  def transfer; end

  # If the event loop is currently blocked,
  def wakeup; end

  # Yield from the current fiber back to the event loop. Put the current fiber into the ready list.
  def yield; end

  private

  def blocking(&block); end
  def pop_ready; end
end

IO::Event::Selector::Select::EAGAIN = T.let(T.unsafe(nil), Integer)

class IO::Event::Selector::Select::Optional < ::Struct
  # @return [Boolean]
  def alive?; end

  # Returns the value of attribute fiber
  #
  # @return [Object] the current value of fiber
  def fiber; end

  # Sets the attribute fiber
  #
  # @param value [Object] the value to set the attribute fiber to.
  # @return [Object] the newly set value
  def fiber=(_); end

  def nullify; end
  def transfer(*arguments); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class IO::Event::Selector::Select::Waiter < ::Struct
  # @return [Boolean]
  def alive?; end

  def each(&block); end

  # Returns the value of attribute events
  #
  # @return [Object] the current value of events
  def events; end

  # Sets the attribute events
  #
  # @param value [Object] the value to set the attribute events to.
  # @return [Object] the newly set value
  def events=(_); end

  # Returns the value of attribute fiber
  #
  # @return [Object] the current value of fiber
  def fiber; end

  # Sets the attribute fiber
  #
  # @param value [Object] the value to set the attribute fiber to.
  # @return [Object] the newly set value
  def fiber=(_); end

  def invalidate; end

  # Returns the value of attribute tail
  #
  # @return [Object] the current value of tail
  def tail; end

  # Sets the attribute tail
  #
  # @param value [Object] the value to set the attribute tail to.
  # @return [Object] the newly set value
  def tail=(_); end

  def transfer(events); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

IO::Event::VERSION = T.let(T.unsafe(nil), String)
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
