# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/async/all/async.rbi
#
# async-2.0.3

module Async
end
class Async::Clock
  def initialize(total = nil); end
  def self.measure; end
  def self.now; end
  def self.start; end
  def start!; end
  def stop!; end
  def total; end
end
class Async::List
  def delete(item); end
  def each(&block); end
  def empty?; end
  def first; end
  def head; end
  def head=(arg0); end
  def include?(needle); end
  def initialize; end
  def insert(item); end
  def last; end
  def nil?; end
  def size; end
  def tail; end
  def tail=(arg0); end
end
class Async::Children < Async::List
  def delete(item); end
  def finished?; end
  def initialize; end
  def insert(item); end
  def transients?; end
end
class Async::Node
  def add_child(child); end
  def annotate(annotation); end
  def annotation; end
  def backtrace(*arguments); end
  def children; end
  def children?; end
  def consume; end
  def delete_child(child); end
  def description; end
  def finished?; end
  def head; end
  def head=(arg0); end
  def initialize(parent = nil, annotation: nil, transient: nil); end
  def inspect; end
  def parent; end
  def parent=(parent); end
  def print_backtrace(out, indent, node); end
  def print_hierarchy(out = nil, backtrace: nil); end
  def root; end
  def set_parent(parent); end
  def stop(later = nil); end
  def stop_children(later = nil); end
  def stopped?; end
  def tail; end
  def tail=(arg0); end
  def terminate; end
  def to_s; end
  def transient?; end
  def traverse(level = nil, &block); end
end
class Async::Condition
  def empty?; end
  def initialize; end
  def signal(value = nil); end
  def wait; end
end
class Async::Condition::Queue < Struct
  def alive?; end
  def fiber; end
  def fiber=(_); end
  def nullify; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def transfer(*arguments); end
end
class Async::Stop < Exception
end
class Async::Stop::Later
  def alive?; end
  def initialize(task); end
  def transfer; end
end
class Async::TimeoutError < StandardError
  def initialize(message = nil); end
end
class Async::Task < Async::Node
  def alive?; end
  def async(*arguments, **options, &block); end
  def backtrace(*arguments); end
  def complete?; end
  def current?; end
  def fail!(exception = nil, propagate = nil); end
  def failed?; end
  def fiber; end
  def finish!; end
  def finished?; end
  def initialize(parent = nil, finished: nil, **options, &block); end
  def reactor; end
  def result; end
  def run(*arguments); end
  def running?; end
  def schedule(arguments); end
  def self.current; end
  def self.current?; end
  def self.yield; end
  def set!; end
  def sleep(duration = nil); end
  def status; end
  def stop!; end
  def stop(later = nil); end
  def stopped?; end
  def to_s; end
  def wait; end
  def with_timeout(duration, exception = nil, message = nil, &block); end
  def yield; end
end
class Async::Scheduler < Async::Node
  def address_resolve(hostname); end
  def async(*arguments, **options, &block); end
  def block(blocker, timeout); end
  def close; end
  def closed?; end
  def fiber(*, **, &); end
  def initialize(parent = nil, selector: nil); end
  def interrupt; end
  def io_read(io, buffer, length); end
  def io_wait(io, events, timeout = nil); end
  def io_write(io, buffer, length); end
  def kernel_sleep(duration = nil); end
  def process_wait(pid, flags); end
  def push(fiber); end
  def raise(*arguments); end
  def resume(fiber, *arguments); end
  def run(*, **, &); end
  def run_once(timeout = nil); end
  def self.supported?; end
  def timeout_after(duration, exception, message, &block); end
  def to_s; end
  def transfer; end
  def unblock(blocker, fiber); end
  def with_timeout(duration, exception = nil, message = nil, &block); end
  def yield; end
end
class Async::Reactor < Async::Scheduler
  def initialize(*, **, &); end
  def self.run(*, **, &); end
  def sleep(*arg0); end
end
module Kernel
  def Async(*, **, &); end
  def Sync(&block); end
end
class Async::Wrapper
  def close; end
  def closed?; end
  def dup; end
  def initialize(io, reactor = nil); end
  def io; end
  def reactor; end
  def reactor=(arg0); end
  def wait_any(timeout = nil); end
  def wait_priority(timeout = nil); end
  def wait_readable(timeout = nil); end
  def wait_writable(timeout = nil); end
end
class Async::Wrapper::Cancelled < StandardError
end
class Async::Semaphore
  def acquire; end
  def async(*arguments, parent: nil, **options); end
  def blocking?; end
  def count; end
  def empty?; end
  def initialize(limit = nil, parent: nil); end
  def limit; end
  def release; end
  def wait; end
  def waiting; end
end
class Async::Notification < Async::Condition
  def signal(value = nil, task: nil); end
end
class Async::Notification::Signal < Struct
  def alive?; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def transfer; end
  def value; end
  def value=(_); end
  def waiting; end
  def waiting=(_); end
end
class Async::Queue < Async::Notification
  def <<(item); end
  def async(parent: nil, &block); end
  def dequeue; end
  def each; end
  def empty?; end
  def enqueue(*items); end
  def initialize(parent: nil); end
  def items; end
  def size; end
end
class Async::LimitedQueue < Async::Queue
  def <<(item); end
  def dequeue; end
  def enqueue(*items); end
  def initialize(limit = nil, **options); end
  def limit; end
  def limited?; end
end
