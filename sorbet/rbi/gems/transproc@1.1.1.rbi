# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `transproc` gem.
# Please instead update this file by running `bin/tapioca gem transproc`.

module Transproc; end

# Transformation functions for Array objects
#
# @api public
# @example
#   require 'transproc/array'
#
#   include Transproc::Helper
#
#   fn = t(:map_array, t(:symbolize_keys)) >> t(:wrap, :address, [:city, :zipcode])
#
#   fn.call(
#   [
#   { 'city' => 'Boston', 'zipcode' => '123' },
#   { 'city' => 'NYC', 'zipcode' => '312' }
#   ]
#   )
#   # => [{:address=>{:city=>"Boston", :zipcode=>"123"}}, {:address=>{:city=>"NYC", :zipcode=>"312"}}]
module Transproc::ArrayTransformations
  extend ::Transproc::Registry

  class << self
    # Adds missing keys with nil value to all tuples in array
    #
    # @api public
    # @param keys [Array]
    # @return [Array]
    def add_keys(array, keys); end

    # @api public
    def combine(array, mappings); end

    # Converts the array of hashes to array of values, extracted by given key
    #
    # @api public
    # @example
    #   fn = t(:extract_key, :name)
    #   fn.call [
    #   { name: 'Alice', role: 'sender' },
    #   { name: 'Bob', role: 'receiver' },
    #   { role: 'listener' }
    #   ]
    #   # => ['Alice', 'Bob', nil]
    # @param array [Array<Hash>] The input array of hashes
    # @param key [Object] The key to extract values by
    # @return [Array]
    def extract_key(array, key); end

    # Group array values using provided root key and value keys
    #
    # @api public
    # @example
    #   fn = Transproc(:group, :tags, [:tag])
    #
    #   fn.call [
    #   { task: 'Group it', tag: 'task' },
    #   { task: 'Group it', tag: 'important' }
    #   ]
    #   # => [{ task: 'Group it', tags: [{ tag: 'task' }, { tag: 'important' }]]
    # @param array [Array] The input array
    # @param key [Object] The nesting root key
    # @param keys [Object] The nesting value keys
    # @return [Array]
    def group(array, key, keys); end

    # Wraps every value of the array to tuple with given key
    #
    # The transformation partially inverses the `extract_key`.
    #
    # @api public
    # @example
    #   fn = t(:insert_key, 'name')
    #   fn.call ['Alice', 'Bob', nil]
    #   # => [{ 'name' => 'Alice' }, { 'name' => 'Bob' }, { 'name' => nil }]
    # @param array [Array<Hash>] The input array of hashes
    # @param key [Object] The key to extract values by
    # @return [Array]
    def insert_key(array, key); end

    # Map array values using transformation function
    #
    # @api public
    # @example
    #
    #   fn = Transproc(:map_array, -> v { v.upcase })
    #
    #   fn.call ['foo', 'bar'] # => ["FOO", "BAR"]
    # @param array [Array] The input array
    # @param fn [Proc] The transformation function
    # @return [Array]
    def map_array(array, fn); end

    # Ungroup array values using provided root key and value keys
    #
    # @api public
    # @example
    #   fn = Transproc(:ungroup, :tags, [:tag])
    #
    #   fn.call [
    #   { task: 'Group it', tags: [{ tag: 'task' }, { tag: 'important' }] }
    #   ]
    #   # => [
    #   { task: 'Group it', tag: 'task' },
    #   { task: 'Group it', tag: 'important' }
    #   ]
    # @param array [Array] The input array
    # @param key [Object] The nesting root key
    # @param keys [Object] The nesting value keys
    # @return [Array]
    def ungroup(array, key, keys); end

    # Wrap array values using HashTransformations.nest function
    #
    # @api public
    # @example
    #   fn = Transproc(:wrap, :address, [:city, :zipcode])
    #
    #   fn.call [{ city: 'NYC', zipcode: '123' }]
    #   # => [{ address: { city: 'NYC', zipcode: '123' } }]
    # @param array [Array] The input array
    # @param key [Object] The nesting root key
    # @param keys [Object] The nesting value keys
    # @return [Array]
    def wrap(array, key, keys); end
  end
end

class Transproc::ArrayTransformations::Combine
  class << self
    def combine(array, mappings); end

    private

    def add_groups_to_element(element, groups, mappings); end
    def element_candidates(element, candidates, keys); end
    def element_candidates_key(element, keys); end
    def group_candidates(candidates, mapping); end
    def group_candidates_by_keys(candidates, keys); end
    def group_nodes(nodes, mappings); end
  end
end

Transproc::ArrayTransformations::Combine::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# Coercion functions for common types
#
# @api public
module Transproc::Coercions
  extend ::Transproc::Registry

  class << self
    # Does nothing and returns a value
    #
    # @api public
    # @example
    #   fn = Coercions[:identity]
    #   fn[:foo] # => :foo
    # @param value [Object]
    # @return [Object]
    def identity(value = T.unsafe(nil)); end

    # Coerce value into a boolean
    #
    # @api public
    # @example
    #   Transproc(:to_boolean)['true']
    #   # => true
    #   Transproc(:to_boolean)['f']
    #   # => false
    # @param value [Object] The input value
    # @return [TrueClass, FalseClass]
    def to_boolean(value); end

    # Coerce value into a date
    #
    # @api public
    # @example
    #   Transproc(:to_date)['2015-04-14']
    #   # => #<Date: 2015-04-14 ((2457127j,0s,0n),+0s,2299161j)>
    # @param value [Object] The input value
    # @return [Date]
    def to_date(value); end

    # Coerce value into a datetime
    #
    # @api public
    # @example
    #   Transproc(:to_datetime)['2015-04-14 12:01:45']
    #   # => #<DateTime: 2015-04-14T12:01:45+00:00 ((2457127j,43305s,0n),+0s,2299161j)>
    # @param value [Object] The input value
    # @return [DateTime]
    def to_datetime(value); end

    # Coerce value into a decimal
    #
    # @api public
    # @example
    #   Transproc(:to_decimal)[1.2]
    #   # => #<BigDecimal:7fca32acea50,'0.12E1',18(36)>
    # @param value [Object] The input value
    # @return [Decimal]
    def to_decimal(value); end

    # Coerce value into a float
    #
    # @api public
    # @example
    #   Transproc(:to_float)['1.2']
    #   # => 1.2
    # @param value [Object] The input value
    # @return [Float]
    def to_float(value); end

    # Coerce value into a integer
    #
    # @api public
    # @example
    #   Transproc(:to_integer)['1']
    #   # => 1
    # @param value [Object] The input value
    # @return [Integer]
    def to_integer(value); end

    # Coerce value into a string
    #
    # @api public
    # @example
    #   Transproc(:to_string)[1]
    #   # => "1"
    # @param value [Object] The input value
    # @return [String]
    def to_string(value); end

    # Coerce value into a symbol
    #
    # @api public
    # @example
    #   Transproc(:to_symbol)['foo']
    #   # => :foo
    # @param value [#to_s] The input value
    # @return [Symbol]
    def to_symbol(value); end

    # Coerce value into a time
    #
    # @api public
    # @example
    #   Transproc(:to_time)['2015-04-14 12:01:45']
    #   # => 2015-04-14 12:01:45 +0200
    # @param value [Object] The input value
    # @return [Time]
    def to_time(value); end

    # Coerce value into an array containing tuples only
    #
    # If the source is not an array, or doesn't contain a tuple, returns
    # an array with one empty tuple
    #
    # @api public
    # @example
    #   Transproc(:to_tuples)[:foo]                  # => [{}]
    #   Transproc(:to_tuples)[[]]                    # => [{}]
    #   Transproc(:to_tuples)[[{ foo: :FOO, :bar }]] # => [{ foo: :FOO }]
    # @param value [Object]
    # @return [Array<Hash>]
    def to_tuples(value); end
  end
end

# @api public
Transproc::Coercions::BOOLEAN_MAP = T.let(T.unsafe(nil), Hash)

# @api public
Transproc::Coercions::FALSE_VALUES = T.let(T.unsafe(nil), Array)

# @api public
Transproc::Coercions::TRUE_VALUES = T.let(T.unsafe(nil), Array)

# @api private
class Transproc::Compiler
  # @api private
  # @return [Compiler] a new instance of Compiler
  def initialize(registry, transformer = T.unsafe(nil)); end

  # @api private
  def call(ast); end

  # @api private
  def registry; end

  # @api private
  def transformer; end

  # @api private
  def visit(node); end

  # @api private
  def visit_arg(arg); end

  # @api private
  def visit_fn(node); end

  # @api private
  def visit_t(node); end
end

# @api private
class Transproc::Compiler::InvalidFunctionNameError < ::StandardError; end

# Helper extension handy for composing many functions in multiple steps
#
# @api public
# @example
#   include Transproc::Composer
#
#   fn = compose do |fns|
#   fns << t(:map_array, t(:symbolize_keys))
#   fns << t(:map_array, t(:nest, :address, [:city, :zipcode]))
#   end
#
#   fn.call [{ 'city' => 'NYC', 'zipcode' => '123' }]
#   # => [{ address: { city: 'NYC', zipcode: '123' }]
module Transproc::Composer
  # Gather and compose functions and fall-back to a default one if provided
  #
  # @api public
  # @example
  #   include Transproc::Composer
  #
  #   fn = compose(-> v { v }) do |fns|
  #   fns << t(:to_string) if something
  #   end
  #
  #   fn[1] # => "1"
  # @see Composer
  # @yield [factory]
  def compose(default = T.unsafe(nil)); end
end

# @api private
class Transproc::Composer::Factory
  # @api private
  # @return [Factory] a new instance of Factory
  def initialize(default = T.unsafe(nil)); end

  # @api private
  def <<(other); end

  # @api private
  def default; end

  # @api private
  def fns; end

  # @api public
  # @deprecated
  def t(*args, &block); end

  # @api private
  def to_fn; end
end

# Composition of two functions
#
# @api private
class Transproc::Composite
  # @api private
  # @return [Composite] a new instance of Composite
  def initialize(left, right); end

  # @api public
  # @see Function#compose
  def +(other); end

  # @api public
  # @see Function#compose
  def >>(other); end

  # Call right side with the result from the left side
  #
  # @api public
  # @param value [Object] The input value
  # @return [Object]
  def [](value); end

  # Call right side with the result from the left side
  #
  # @api public
  # @param value [Object] The input value
  # @return [Object]
  def call(value); end

  # @api public
  # @see Function#compose
  def compose(other); end

  # @api private
  # @return [Proc]
  def left; end

  # @api private
  # @return [Proc]
  def right; end

  # @api public
  # @see Function#to_ast
  def to_ast; end
end

module Transproc::Deprecations
  class << self
    def announce(name, msg); end
  end
end

class Transproc::Error < ::StandardError; end

# Transformation proc wrapper allowing composition of multiple procs into
# a data-transformation pipeline.
#
# This is used by Transproc to wrap registered methods.
#
# @api private
class Transproc::Function
  # @api private
  # @return [Function] a new instance of Function
  def initialize(fn, options = T.unsafe(nil)); end

  # Compose this function with another function or a proc
  #
  # @api public
  # @param [Proc, Function]
  # @return [Composite]
  def +(other); end

  # @api public
  def ==(other); end

  # Compose this function with another function or a proc
  #
  # @api public
  # @param [Proc, Function]
  # @return [Composite]
  def >>(other); end

  # Call the wrapped proc
  #
  # @api public
  # @param value [Object] The input value
  def [](*value); end

  # Additional arguments that will be passed to the wrapped proc
  #
  # @api private
  # @return [Array]
  def args; end

  # Call the wrapped proc
  #
  # @api public
  # @param value [Object] The input value
  def call(*value); end

  # Compose this function with another function or a proc
  #
  # @api public
  # @param [Proc, Function]
  # @return [Composite]
  def compose(other); end

  # @api public
  def eql?(other); end

  # Wrapped proc or another composite function
  #
  # @api private
  # @return [Proc, Composed]
  def fn; end

  # @api public
  # @return [<type] The name of the function] <type] The name of the function
  def name; end

  # Return a simple AST representation of this function
  #
  # @api public
  # @return [Array]
  def to_ast; end

  # Converts a transproc to a simple proc
  #
  # @api private
  # @return [Proc]
  def to_proc; end

  # Return a new fn with curried args
  #
  # @api private
  # @return [Function]
  def with(*args); end
end

class Transproc::FunctionAlreadyRegisteredError < ::Transproc::Error; end

class Transproc::FunctionNotFoundError < ::Transproc::Error
  # @return [FunctionNotFoundError] a new instance of FunctionNotFoundError
  def initialize(function, source = T.unsafe(nil)); end
end

# Function container extension
#
# @api public
# @example
#   module MyTransformations
#   extend Transproc::Functions
#
#   def boom!(value)
#   "#{value} BOOM!"
#   end
#   end
#
#   Transproc(:boom!)['w00t!'] # => "w00t! BOOM!"
module Transproc::Functions
  # @api public
  def method_added(meth); end

  class << self
    # @api public
    # @private
    def extended(mod); end
  end
end

# Transformation functions for Hash objects
#
# @api public
# @example
#   require 'transproc/hash'
#
#   include Transproc::Helper
#
#   fn = t(:symbolize_keys) >> t(:nest, :address, [:street, :zipcode])
#
#   fn["street" => "Street 1", "zipcode" => "123"]
#   # => {:address => {:street => "Street 1", :zipcode => "123"}}
module Transproc::HashTransformations
  extend ::Transproc::Registry

  class << self
    # Accepts specified keys from a hash
    #
    # @api public
    # @example
    #   Transproc(:accept_keys, [:name])[name: 'Jane', email: 'jane@doe.org']
    #   # => {:name=>"Jane"}
    # @param hash [Hash] The input hash
    # @param keys [Array] The keys to be accepted
    # @return [Hash]
    def accept_keys(hash, keys); end

    # Copy all keys in a hash using provided mapping hash
    #
    # @api public
    # @example
    #   Transproc(:copy_keys, user_name: :name)[user_name: 'Jane']
    #   # => {:user_name => "Jane", :name => "Jane"}
    # @param source_hash [Hash] The input hash
    # @param mapping [Hash] The key-copy mapping
    # @return [Hash]
    def copy_keys(source_hash, mapping); end

    # Merge a hash recursively
    #
    # @api public
    # @example
    #
    #   input = { 'foo' => 'bar', 'baz' => { 'one' => 1 } }
    #   other = { 'foo' => 'buz', 'baz' => { :one => 'one', :two => 2 } }
    #
    #   t(:deep_merge)[input, other]
    #   # => { 'foo' => "buz", :baz => { :one => 'one', 'one' => 1, :two => 2 } }
    # @param [Hash]
    # @param [Hash]
    # @return [Hash]
    def deep_merge(hash, other); end

    # Stringify keys in a hash recursively
    #
    # @api public
    # @example
    #   input = { :foo => "bar", :baz => [{ :one => 1 }] }
    #
    #   t(:deep_stringify_keys)[input]
    #   # => { "foo" => "bar", "baz" => [{ "one" => 1 }] }
    # @param [Hash]
    # @return [Hash]
    def deep_stringify_keys(hash); end

    # Symbolize keys in a hash recursively
    #
    # @api public
    # @example
    #
    #   input = { 'foo' => 'bar', 'baz' => [{ 'one' => 1 }] }
    #
    #   t(:deep_symbolize_keys)[input]
    #   # => { :foo => "bar", :baz => [{ :one => 1 }] }
    # @param [Hash]
    # @return [Hash]
    def deep_symbolize_keys(hash); end

    # Recursively evaluate hash values if they are procs/lambdas
    #
    # @api public
    # @example
    #   hash = {
    #   num: -> i { i + 1 },
    #   str: -> i { "num #{i}" }
    #   }
    #
    #   t(:eval_values, 1)[hash]
    #   # => {:num => 2, :str => "num 1" }
    #
    #   # with filters
    #   t(:eval_values, 1, [:str])[hash]
    #   # => {:num => #{still a proc}, :str => "num 1" }
    # @param [Hash]
    # @param args [Array, Object] Anything that should be passed to procs
    # @param filters [Array] A list of attribute names that should be evaluated
    def eval_values(hash, args, filters = T.unsafe(nil)); end

    # Folds array of tuples to array of values from a specified key
    #
    # @api public
    # @example
    #   source = {
    #   name: "Jane",
    #   tasks: [{ title: "be nice", priority: 1 }, { title: "sleep well" }]
    #   }
    #   Transproc(:fold, :tasks, :title)[source]
    #   # => { name: "Jane", tasks: ["be nice", "sleep well"] }
    #   Transproc(:fold, :tasks, :priority)[source]
    #   # => { name: "Jane", tasks: [1, nil] }
    # @param hash [Hash]
    # @param key [Object] The key to fold values to
    # @param tuple_key [Object] The key to take folded values from
    # @return [Hash]
    def fold(hash, key, tuple_key); end

    # Map all keys in a hash with the provided transformation function
    #
    # @api public
    # @example
    #   Transproc(:map_keys, -> s { s.upcase })['name' => 'Jane']
    #   # => {"NAME" => "Jane"}
    # @param [Hash]
    # @return [Hash]
    def map_keys(source_hash, fn); end

    # Map a key in a hash with the provided transformation function
    #
    # @api public
    # @example
    #   Transproc(:map_value, 'name', -> s { s.upcase })['name' => 'jane']
    #   # => {"name" => "JANE"}
    # @param [Hash]
    # @return [Hash]
    def map_value(hash, key, fn); end

    # Map all values in a hash using transformation function
    #
    # @api public
    # @example
    #   Transproc(:map_values, -> v { v.upcase })[:name => 'Jane']
    #   # => {"name" => "JANE"}
    # @param [Hash]
    # @return [Hash]
    def map_values(source_hash, fn); end

    # Nest values from specified keys under a new key
    #
    # @api public
    # @example
    #   Transproc(:nest, :address, [:street, :zipcode])[street: 'Street', zipcode: '123']
    #   # => {address: {street: "Street", zipcode: "123"}}
    # @param [Hash]
    # @return [Hash]
    def nest(hash, root, keys); end

    # Rejects specified keys from a hash
    #
    # @api public
    # @example
    #   Transproc(:reject_keys, [:name])[name: 'Jane', email: 'jane@doe.org']
    #   # => {:email => "jane@doe.org"}
    # @param hash [Hash] The input hash
    # @param keys [Array] The keys to be rejected
    # @return [Hash]
    def reject_keys(hash, keys); end

    # Rename all keys in a hash using provided mapping hash
    #
    # @api public
    # @example
    #   Transproc(:rename_keys, user_name: :name)[user_name: 'Jane']
    #   # => {:name => "Jane"}
    # @param source_hash [Hash] The input hash
    # @param mapping [Hash] The key-rename mapping
    # @return [Hash]
    def rename_keys(source_hash, mapping); end

    # Splits hash to array by all values from a specified key
    #
    # The operation adds missing keys extracted from the array to regularize the output.
    #
    # @api public
    # @example
    #   input = {
    #   name: 'Joe',
    #   tasks: [
    #   { title: 'sleep well', priority: 1 },
    #   { title: 'be nice',    priority: 2 },
    #   {                      priority: 2 },
    #   { title: 'be cool'                 }
    #   ]
    #   }
    #   Transproc(:split, :tasks, [:priority])[input]
    #   => [
    #   { name: 'Joe', priority: 1,   tasks: [{ title: 'sleep well' }]              },
    #   { name: 'Joe', priority: 2,   tasks: [{ title: 'be nice' }, { title: nil }] },
    #   { name: 'Joe', priority: nil, tasks: [{ title: 'be cool' }]                 }
    #   ]
    # @param hash [Hash]
    # @param key [Object] The key to split a hash by
    # @param subkeys [Array] The list of subkeys to be extracted from key
    # @return [Array<Hash>]
    def split(hash, key, keys); end

    # Stringify all keys in a hash
    #
    # @api public
    # @example
    #   Transproc(:stringify_keys)[:name => 'Jane']
    #   # => {"name" => "Jane"}
    # @param [Hash]
    # @return [Hash]
    def stringify_keys(hash); end

    # Symbolize all keys in a hash
    #
    # @api public
    # @example
    #   Transproc(:symbolize_keys)['name' => 'Jane']
    #   # => {:name => "Jane"}
    # @param [Hash]
    # @return [Hash]
    def symbolize_keys(hash); end

    # Collapse a nested hash from a specified key
    #
    # @api public
    # @example
    #   Transproc(:unwrap, :address, [:street, :zipcode])[address: { street: 'Street', zipcode: '123' }]
    #   # => {street: "Street", zipcode: "123"}
    # @option options
    # @param options [Hash] hash of options (optional)
    # @param root [Mixed] The root key to unwrap values from
    # @param source_hash [Hash]
    # @param selected [Array] The keys that should be unwrapped (optional)
    # @return [Hash]
    def unwrap(source_hash, root, selected = T.unsafe(nil), options = T.unsafe(nil)); end
  end
end

# @api public
Transproc::HashTransformations::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Container to define transproc functions in, and access them via `[]` method
# from the outside of the module
#
# @api public
# @example
#   module FooMethods
#   extend Transproc::Registry
#
#   def self.foo(name, prefix)
#   [prefix, '_', name].join
#   end
#   end
#
#   fn = FooMethods[:foo, 'baz']
#   fn['qux'] # => 'qux_baz'
#
#   module BarMethods
#   extend FooMethods
#
#   def self.bar(*args)
#   foo(*args).upcase
#   end
#   end
#
#   fn = BarMethods[:foo, 'baz']
#   fn['qux'] # => 'qux_baz'
#
#   fn = BarMethods[:bar, 'baz']
#   fn['qux'] # => 'QUX_BAZ'
module Transproc::Registry
  # Builds the transformation
  #
  # @api public
  # @param fn [Proc, Symbol] A proc, a name of the module's own function, or a name of imported
  #   procedure from another module
  # @param args [Object, Array] Args to be carried by the transproc
  # @return [Transproc::Function]
  def [](fn, *args); end

  # Returns wether the registry contains such transformation by its key
  #
  # @api public
  # @param key [Symbol]
  # @return [Boolean]
  def contain?(key); end

  # Gets the procedure for creating a transproc
  #
  # @api public
  # @param fn [#call, Symbol] Either the procedure, or the name of the method of the current module,
  #   or the registered key of imported procedure in a store.
  # @return [#call]
  def fetch(fn); end

  # Imports either a method (converted to a proc) from another module, or
  # all methods from that module.
  #
  # If the external module is a registry, looks for its imports too.
  #
  # @api public
  # @overload import
  # @overload import
  # @overload import
  # @return [itself] self
  def import(*args); end

  # store.register(:to_json) { |v| v.to_json }
  #
  # @api public
  def register(name, fn = T.unsafe(nil), &block); end

  # The store of procedures imported from external modules
  #
  # @api public
  # @return [Transproc::Store]
  def store; end

  # Builds the transformation
  #
  # @api public
  # @param fn [Proc, Symbol] A proc, a name of the module's own function, or a name of imported
  #   procedure from another module
  # @param args [Object, Array] Args to be carried by the transproc
  # @return [Transproc::Function]
  def t(fn, *args); end

  # Imports either a method (converted to a proc) from another module, or
  # all methods from that module.
  #
  # If the external module is a registry, looks for its imports too.
  #
  # @api public
  # @overload import
  # @overload import
  # @overload import
  # @return [itself] self
  def uses(*args); end

  private

  # @api private
  # @return [Boolean]
  def already_wrapped?(func); end
end

# Immutable collection of named procedures from external modules
#
# @api private
class Transproc::Store
  def initialize(methods = T.unsafe(nil)); end

  def contain?(key); end
  def fetch(key); end
  def import(*args); end

  # @api private
  # @return [Hash] The associated list of imported procedures
  def methods; end

  def register(name, fn = T.unsafe(nil), &block); end

  protected

  def import_all(source); end
  def import_method(source, name, new_name = T.unsafe(nil)); end
  def import_methods(source, names); end
end

# Transfomer class for defining transprocs with a class DSL.
#
# @api public
# @example
#   require 'anima'
#   require 'transproc/all'
#
#   class User
#   include Anima.new(:name, :address)
#   end
#
#   class Address
#   include Anima.new(:city, :street, :zipcode)
#   end
#
#   class UsersMapper < Transproc::Transformer
#   map_array do
#   symbolize_keys
#   rename_keys user_name: :name
#   nest :address, %i(city street zipcode)
#   map_value :address do
#   constructor_inject Address
#   end
#   constructor_inject User
#   end
#   end
#
#   UsersMapper.new.call(
#   [
#   { 'user_name' => 'Jane',
#   'city' => 'NYC',
#   'street' => 'Street 1',
#   'zipcode' => '123'
#   }
#   ]
#   )
#   # => [
#   #<User
#   name="Jane"
#   address=#<Address city="NYC" street="Street 1" zipcode="123">>
#   ]
class Transproc::Transformer
  extend ::Transproc::Transformer::ClassInterface
  extend ::Transproc::Transformer::Deprecated::ClassInterface

  # Execute the transformation pipeline with the given input.
  #
  # @api public
  # @example
  #
  #   class SymbolizeKeys < Transproc::Transformer
  #   symbolize_keys
  #   end
  #
  #   SymbolizeKeys.new.call('name' => 'Jane')
  #   # => {:name=>"Jane"}
  # @param input [mixed] The input to pass to the pipeline
  # @return [mixed] output The output returned from the pipeline
  def call(input); end

  # @api public
  def transproc; end
end

# @api public
module Transproc::Transformer::ClassInterface
  # Return a base Transproc::Transformer class with the
  # container configured to the passed argument.
  #
  # @api public
  # @example
  #
  #   class MyTransformer < Transproc::Transformer[Transproc]
  #   end
  # @param container [Transproc::Registry] The container to resolve transprocs from
  # @return [subclass of Transproc::Transformer]
  def [](container); end

  # Get or set the container to resolve transprocs from.
  #
  # @api private
  # @example
  #
  #   # Setter
  #   Transproc::Transformer.container(Transproc)
  #   # => Transproc
  #
  #   # Getter
  #   Transproc::Transformer.container
  #   # => Transproc
  # @param container [Transproc::Registry] The container to resolve transprocs from
  # @return [Transproc::Registry]
  def container(container = T.unsafe(nil)); end

  # @api public
  def define!(&block); end

  # @api private
  def dsl; end

  # @api public
  def import(*args); end

  # @api private
  def inherited(subclass); end

  # @api public
  def new(*_arg0, **_arg1); end

  # Get a transformation from the container,
  # without adding it to the transformation pipeline
  #
  # @api public
  # @example
  #
  #   class Stringify < Transproc::Transformer
  #   map_values t(:to_string)
  #   end
  #
  #   Stringify.new.call(a: 1, b: 2)
  #   # => {a: '1', b: '2'}
  # @param fn [Proc, Symbol] A proc, a name of the module's own function, or a name of imported
  #   procedure from another module
  # @param args [Object, Array] Args to be carried by the transproc
  # @return [Transproc::Function]
  def t(fn, *args); end
end

# @api public
class Transproc::Transformer::DSL
  # @api private
  # @return [DSL] a new instance of DSL
  def initialize(container, ast: T.unsafe(nil), &block); end

  # @api private
  def ast; end

  # @api private
  def call(transformer); end

  # @api private
  def container; end

  # @api private
  def dup; end

  private

  # @api private
  def method_missing(meth, *args, &block); end

  # @api private
  def node(&block); end

  # @api private
  # @return [Boolean]
  def respond_to_missing?(method, _include_private = T.unsafe(nil)); end
end

module Transproc::Transformer::Deprecated; end

# @api public
module Transproc::Transformer::Deprecated::ClassInterface
  # Define an anonymous transproc derived from given Transformer
  # Evaluates block with transformations and returns initialized transproc.
  # Does not mutate original Transformer
  #
  # @api public
  # @example
  #   class MyTransformer < Transproc::Transformer[MyContainer]
  #   end
  #
  #   transproc = MyTransformer.define do
  #   map_values t(:to_string)
  #   end
  #   transproc.call(a: 1, b: 2)
  #   # => {a: '1', b: '2'}
  # @return [Function] Composed transproc
  # @yield Block allowing to define transformations. The same as class level DSL
  def build(&block); end

  # Define an anonymous transproc derived from given Transformer
  # Evaluates block with transformations and returns initialized transproc.
  # Does not mutate original Transformer
  #
  # @api public
  # @example
  #
  #   class MyTransformer < Transproc::Transformer[MyContainer]
  #   end
  #
  #   transproc = MyTransformer.define do
  #   map_values t(:to_string)
  #   end
  #   transproc.call(a: 1, b: 2)
  #   # => {a: '1', b: '2'}
  # @return [Function] Composed transproc
  # @yield Block allowing to define transformations. The same as class level DSL
  def define(&block); end

  # @api private
  def inherited(subclass); end

  # @api private
  def method_missing(method, *args, &block); end

  # @api public
  def new(*_arg0, **_arg1); end

  # @api private
  def transproc; end

  private

  # @api private
  # @return [Boolean]
  def respond_to_missing?(method, _include_private = T.unsafe(nil)); end

  # An array containing the transformation pipeline
  #
  # @api private
  def transformations; end
end

Transproc::Undefined = T.let(T.unsafe(nil), Object)
Transproc::VERSION = T.let(T.unsafe(nil), String)
