# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `concurrent-ruby` gem.
# Please instead update this file by running `bin/tapioca gem concurrent-ruby`.

# {include:file:README.md}
module Concurrent
  extend ::Concurrent::Utility::EngineDetector
  extend ::Concurrent::Utility::NativeExtensionLoader
end

module Concurrent::Collection; end
Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::Collection::MriMapBackend < ::Concurrent::Collection::NonConcurrentMapBackend
  # @return [MriMapBackend] a new instance of MriMapBackend
  def initialize(options = T.unsafe(nil)); end

  def []=(key, value); end
  def clear; end
  def compute(key); end
  def compute_if_absent(key); end
  def compute_if_present(key); end
  def delete(key); end
  def delete_pair(key, value); end
  def get_and_set(key, value); end
  def merge_pair(key, value); end
  def replace_if_exists(key, new_value); end
  def replace_pair(key, old_value, new_value); end
end

class Concurrent::Collection::NonConcurrentMapBackend
  # WARNING: all public methods of the class must operate on the @backend
  # directly without calling each other. This is important because of the
  # SynchronizedMapBackend which uses a non-reentrant mutex for performance
  # reasons.
  #
  # @return [NonConcurrentMapBackend] a new instance of NonConcurrentMapBackend
  def initialize(options = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def clear; end
  def compute(key); end
  def compute_if_absent(key); end
  def compute_if_present(key); end
  def delete(key); end
  def delete_pair(key, value); end
  def each_pair; end
  def get_and_set(key, value); end
  def get_or_default(key, default_value); end

  # @return [Boolean]
  def key?(key); end

  def merge_pair(key, value); end
  def replace_if_exists(key, new_value); end
  def replace_pair(key, old_value, new_value); end
  def size; end

  private

  def _get(key); end
  def _set(key, value); end
  def dupped_backend; end
  def initialize_copy(other); end

  # @return [Boolean]
  def pair?(key, expected_value); end

  def store_computed_value(key, new_value); end
end

# `Concurrent::Map` is a hash-like object and should have much better performance
# characteristics, especially under high concurrency, than `Concurrent::Hash`.
# However, `Concurrent::Map `is not strictly semantically equivalent to a ruby `Hash`
# -- for instance, it does not necessarily retain ordering by insertion time as `Hash`
# does. For most uses it should do fine though, and we recommend you consider
# `Concurrent::Map` instead of `Concurrent::Hash` for your concurrency-safe hash needs.
class Concurrent::Map < ::Concurrent::Collection::MriMapBackend
  # @return [Map] a new instance of Map
  def initialize(options = T.unsafe(nil), &block); end

  # Get a value with key
  #
  # @param key [Object]
  # @return [Object] the value
  def [](key); end

  # Set a value with key
  #
  # @param key [Object]
  # @param value [Object]
  # @return [Object] the new value
  def []=(key, value); end

  # Iterates over each key value pair.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each key value pair in the map
  # @yieldparam key [Object]
  # @yieldparam value [Object]
  def each; end

  # Iterates over each key.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each key in the map
  # @yieldparam key [Object]
  def each_key; end

  # Iterates over each key value pair.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each key value pair in the map
  # @yieldparam key [Object]
  # @yieldparam value [Object]
  def each_pair; end

  # Iterates over each value.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each value in the map
  # @yieldparam value [Object]
  def each_value; end

  # Is map empty?
  #
  # @return [true, false]
  def empty?; end

  # Get a value with key, or default_value when key is absent,
  # or fail when no default_value is given.
  #
  # @note The "fetch-then-act" methods of `Map` are not atomic. `Map` is intended
  #   to be use as a concurrency primitive with strong happens-before
  #   guarantees. It is not intended to be used as a high-level abstraction
  #   supporting complex operations. All read and write operations are
  #   thread safe, but no guarantees are made regarding race conditions
  #   between the fetch operation and yielding to the block. Additionally,
  #   this method does not support recursion. This is due to internal
  #   constraints that are very unlikely to change in the near future.
  # @param key [Object]
  # @param default_value [Object]
  # @raise [KeyError] when key is missing and no default_value is provided
  # @return [Object] the value or default value
  # @yield default value for a key
  # @yieldparam key [Object]
  # @yieldreturn [Object] default value
  def fetch(key, default_value = T.unsafe(nil)); end

  # Fetch value with key, or store default value when key is absent,
  # or fail when no default_value is given. This is a two step operation,
  # therefore not atomic. The store can overwrite other concurrently
  # stored value.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @param key [Object]
  # @param default_value [Object]
  # @return [Object] the value or default value
  # @yield default value for a key
  # @yieldparam key [Object]
  # @yieldreturn [Object] default value
  def fetch_or_store(key, default_value = T.unsafe(nil)); end

  # Get a value with key
  #
  # @param key [Object]
  # @return [Object] the value
  def get(key); end

  def inspect; end

  # Find key of a value.
  #
  # @param value [Object]
  # @return [Object, nil] key or nil when not found
  def key(value); end

  # All keys
  #
  # @return [::Array<Object>] keys
  def keys; end

  # @raise [TypeError]
  def marshal_dump; end

  def marshal_load(hash); end

  # Set a value with key
  #
  # @param key [Object]
  # @param value [Object]
  # @return [Object] the new value
  def put(key, value); end

  # Insert value into map with key if key is absent in one atomic step.
  #
  # @param key [Object]
  # @param value [Object]
  # @return [Object, nil] the previous value when key was present or nil when there was no key
  def put_if_absent(key, value); end

  # Is the value stored in the map. Iterates over all values.
  #
  # @param value [Object]
  # @return [true, false]
  def value?(value); end

  # All values
  #
  # @return [::Array<Object>] values
  def values; end

  private

  def initialize_copy(other); end
  def populate_from(hash); end

  # @raise [KeyError]
  def raise_fetch_no_key; end

  def validate_options_hash!(options); end
end

# Various classes within allows for +nil+ values to be stored,
# so a special +NULL+ token is required to indicate the "nil-ness".
Concurrent::NULL = T.let(T.unsafe(nil), Object)

# {include:file:docs-source/synchronization.md}
# {include:file:docs-source/synchronization-notes.md}
module Concurrent::Synchronization; end

class Concurrent::Synchronization::AbstractLockableObject < ::Concurrent::Synchronization::Object
  protected

  # Broadcast to all waiting threads.
  #
  # @note only to be used inside synchronized block
  # @note to provide direct access to this method in a descendant add method
  #   ```
  #   def broadcast
  #   synchronize { ns_broadcast }
  #   end
  #   ```
  # @raise [NotImplementedError]
  # @return [self]
  def ns_broadcast; end

  # Signal one waiting thread.
  #
  # @note only to be used inside synchronized block
  # @note to provide direct access to this method in a descendant add method
  #   ```
  #   def signal
  #   synchronize { ns_signal }
  #   end
  #   ```
  # @raise [NotImplementedError]
  # @return [self]
  def ns_signal; end

  # Wait until another thread calls #signal or #broadcast,
  # spurious wake-ups can happen.
  #
  # @note only to be used inside synchronized block
  # @note to provide direct access to this method in a descendant add method
  #   ```
  #   def wait(timeout = nil)
  #   synchronize { ns_wait(timeout) }
  #   end
  #   ```
  # @param timeout [Numeric, nil] in seconds, `nil` means no timeout
  # @raise [NotImplementedError]
  # @return [self]
  def ns_wait(timeout = T.unsafe(nil)); end

  # Wait until condition is met or timeout passes,
  # protects against spurious wake-ups.
  #
  # @note only to be used inside synchronized block
  # @note to provide direct access to this method in a descendant add method
  #   ```
  #   def wait_until(timeout = nil, &condition)
  #   synchronize { ns_wait_until(timeout, &condition) }
  #   end
  #   ```
  # @param timeout [Numeric, nil] in seconds, `nil` means no timeout
  # @return [true, false] if condition met
  # @yield condition to be met
  # @yieldreturn [true, false]
  def ns_wait_until(timeout = T.unsafe(nil), &condition); end

  # @note can by made public in descendants if required by `public :synchronize`
  # @raise [NotImplementedError]
  # @yield runs the block synchronized against this object,
  #   equivalent of java's `synchronize(this) {}`
  def synchronize; end
end

class Concurrent::Synchronization::AbstractObject
  # @abstract has to be implemented based on Ruby runtime
  # @raise [NotImplementedError]
  # @return [AbstractObject] a new instance of AbstractObject
  def initialize; end

  # @abstract
  # @raise [NotImplementedError]
  def full_memory_barrier; end

  class << self
    # @raise [NotImplementedError]
    def attr_volatile(*names); end
  end
end

# TODO (pitr-ch 04-Dec-2016): should be in edge
class Concurrent::Synchronization::Condition < ::Concurrent::Synchronization::LockableObject
  # @return [Condition] a new instance of Condition
  def initialize(lock); end

  def broadcast; end
  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = T.unsafe(nil)); end
  def ns_wait_until(timeout = T.unsafe(nil), &condition); end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
  def wait_until(timeout = T.unsafe(nil), &condition); end

  class << self
    def private_new(*args, &block); end
  end
end

module Concurrent::Synchronization::ConditionSignalling
  protected

  def ns_broadcast; end
  def ns_signal; end
end

# TODO (pitr-ch 04-Dec-2016): should be in edge
class Concurrent::Synchronization::Lock < ::Concurrent::Synchronization::LockableObject
  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
  def wait_until(timeout = T.unsafe(nil), &condition); end
end

# Safe synchronization under any Ruby implementation.
#   It provides methods like {#synchronize}, {#wait}, {#signal} and {#broadcast}.
#   Provides a single layer which can improve its implementation over time without changes needed to
#   the classes using it. Use {Synchronization::Object} not this abstract class.
#
#   @note this object does not support usage together with
#     [`Thread#wakeup`](http://ruby-doc.org/core/Thread.html#method-i-wakeup)
#     and [`Thread#raise`](http://ruby-doc.org/core/Thread.html#method-i-raise).
#     `Thread#sleep` and `Thread#wakeup` will work as expected but mixing `Synchronization::Object#wait` and
#     `Thread#wakeup` will not work on all platforms.
#
#   @see Event implementation as an example of this class use
#
#   @example simple
#     class AnClass < Synchronization::Object
#       def initialize
#         super
#         synchronize { @value = 'asd' }
#       end
#
#       def value
#         synchronize { @value }
#       end
#     end
class Concurrent::Synchronization::LockableObject < ::Concurrent::Synchronization::MutexLockableObject
  def new_condition; end
end

Concurrent::Synchronization::LockableObjectImplementation = Concurrent::Synchronization::MutexLockableObject

class Concurrent::Synchronization::MonitorLockableObject < ::Concurrent::Synchronization::AbstractLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling

  # @return [MonitorLockableObject] a new instance of MonitorLockableObject
  def initialize(*defaults); end

  protected

  def ns_wait(timeout = T.unsafe(nil)); end

  # TODO may be a problem with lock.synchronize { lock.wait }
  def synchronize; end

  private

  def initialize_copy(other); end

  class << self
    def new(*args, &block); end
  end
end

module Concurrent::Synchronization::MriAttrVolatile
  mixes_in_class_methods ::Concurrent::Synchronization::MriAttrVolatile::ClassMethods

  def full_memory_barrier; end

  class << self
    # @private
    def included(base); end
  end
end

module Concurrent::Synchronization::MriAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

class Concurrent::Synchronization::MriObject < ::Concurrent::Synchronization::AbstractObject
  include ::Concurrent::Synchronization::MriAttrVolatile
  extend ::Concurrent::Synchronization::MriAttrVolatile::ClassMethods

  # @return [MriObject] a new instance of MriObject
  def initialize; end
end

class Concurrent::Synchronization::MutexLockableObject < ::Concurrent::Synchronization::AbstractLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling

  # @return [MutexLockableObject] a new instance of MutexLockableObject
  def initialize(*defaults); end

  protected

  def ns_wait(timeout = T.unsafe(nil)); end
  def synchronize; end

  private

  def initialize_copy(other); end

  class << self
    def new(*args, &block); end
  end
end

# Abstract object providing final, volatile, ans CAS extensions to build other concurrent abstractions.
# - final instance variables see {Object.safe_initialization!}
# - volatile instance variables see {Object.attr_volatile}
# - volatile instance variables see {Object.attr_atomic}
class Concurrent::Synchronization::Object < ::Concurrent::Synchronization::MriObject
  # Has to be called by children.
  #
  # @return [Object] a new instance of Object
  def initialize; end

  private

  def __initialize_atomic_fields__; end

  class << self
    # @return [true, false] is the attribute with name atomic?
    def atomic_attribute?(name); end

    # @param inherited [true, false] should inherited volatile with CAS fields be returned?
    # @return [::Array<Symbol>] Returns defined volatile with CAS fields on this class.
    def atomic_attributes(inherited = T.unsafe(nil)); end

    # Creates methods for reading and writing to a instance variable with
    # volatile (Java) semantic as {.attr_volatile} does.
    # The instance variable should be accessed oly through generated methods.
    # This method generates following methods: `value`, `value=(new_value) #=> new_value`,
    # `swap_value(new_value) #=> old_value`,
    # `compare_and_set_value(expected, value) #=> true || false`, `update_value(&block)`.
    #
    # @param names [::Array<Symbol>] of the instance variables to be volatile with CAS.
    # @return [::Array<Symbol>] names of defined method names.
    def attr_atomic(*names); end

    # For testing purposes, quite slow. Injects assert code to new method which will raise if class instance contains
    # any instance variables with CamelCase names and isn't {.safe_initialization?}.
    #
    # @raise when offend found
    # @return [true]
    def ensure_safe_initialization_when_final_fields_are_present; end

    # By calling this method on a class, it and all its children are marked to be constructed safely. Meaning that
    # all writes (ivar initializations) are made visible to all readers of newly constructed object. It ensures
    # same behaviour as Java's final fields.
    #
    # @example
    #   class AClass < Concurrent::Synchronization::Object
    #   safe_initialization!
    #
    #   def initialize
    #   @AFinalValue = 'value' # published safely, does not have to be synchronized
    #   end
    #   end
    # @return [true]
    def safe_initialization!; end

    # @return [true, false] if this class is safely initialized.
    def safe_initialization?; end

    private

    def define_initialize_atomic_fields; end
  end
end

Concurrent::Synchronization::ObjectImplementation = Concurrent::Synchronization::MriObject

module Concurrent::Synchronization::RbxAttrVolatile
  mixes_in_class_methods ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods

  def full_memory_barrier; end

  class << self
    # @private
    def included(base); end
  end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

class Concurrent::Synchronization::RbxLockableObject < ::Concurrent::Synchronization::AbstractLockableObject
  # @return [RbxLockableObject] a new instance of RbxLockableObject
  def initialize(*defaults); end

  protected

  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = T.unsafe(nil)); end
  def synchronize(&block); end

  private

  def initialize_copy(other); end

  class << self
    def new(*args, &block); end
  end
end

class Concurrent::Synchronization::RbxObject < ::Concurrent::Synchronization::AbstractObject
  include ::Concurrent::Synchronization::RbxAttrVolatile
  extend ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods

  # @return [RbxObject] a new instance of RbxObject
  def initialize; end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  mixes_in_class_methods ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods

  def full_memory_barrier; end

  class << self
    # @private
    def included(base); end
  end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

class Concurrent::Synchronization::TruffleRubyObject < ::Concurrent::Synchronization::AbstractObject
  include ::Concurrent::Synchronization::TruffleRubyAttrVolatile
  extend ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods

  # @return [TruffleRubyObject] a new instance of TruffleRubyObject
  def initialize; end
end

# Volatile adds the attr_volatile class method when included.
#
#  foo = Foo.new
#  foo.bar
#  => 1
#  foo.bar = 2
#  => 2
#
# @example
#   class Foo
#   include Concurrent::Synchronization::Volatile
#
#   attr_volatile :bar
#
#   def initialize
#   self.bar = 1
#   end
#   end
Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

module Concurrent::Utility; end

module Concurrent::Utility::EngineDetector
  # @return [Boolean]
  def on_cruby?; end

  # @return [Boolean]
  def on_jruby?; end

  # @return [Boolean]
  def on_jruby_9000?; end

  # @return [Boolean]
  def on_linux?; end

  # @return [Boolean]
  def on_osx?; end

  # @return [Boolean]
  def on_rbx?; end

  # @return [Boolean]
  def on_truffleruby?; end

  # @return [Boolean]
  def on_windows?; end

  def ruby_engine; end
  def ruby_version(version = T.unsafe(nil), comparison, major, minor, patch); end
end

module Concurrent::Utility::NativeExtensionLoader
  # @return [Boolean]
  def allow_c_extensions?; end

  # @return [Boolean]
  def c_extensions_loaded?; end

  # @return [Boolean]
  def java_extensions_loaded?; end

  def load_native_extensions; end

  private

  def load_error_path(error); end
  def set_c_extensions_loaded; end
  def set_java_extensions_loaded; end
  def try_load_c_extension(path); end
end
