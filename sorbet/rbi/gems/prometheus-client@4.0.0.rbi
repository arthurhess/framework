# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `prometheus-client` gem.
# Please instead update this file by running `bin/tapioca gem prometheus-client`.

# Prometheus is a generic time-series collection and computation server.
module Prometheus; end

# Client is a ruby implementation for a Prometheus compatible client.
module Prometheus::Client
  class << self
    def config; end

    # Returns a default registry object
    def registry; end
  end
end

class Prometheus::Client::Config
  # @return [Config] a new instance of Config
  def initialize; end

  # Returns the value of attribute data_store.
  def data_store; end

  # Sets the attribute data_store
  #
  # @param value the value to set the attribute data_store to.
  def data_store=(_arg0); end
end

# Counter is a metric that exposes merely a sum or tally of things.
class Prometheus::Client::Counter < ::Prometheus::Client::Metric
  # @raise [ArgumentError]
  def increment(by: T.unsafe(nil), labels: T.unsafe(nil)); end

  def type; end
end

module Prometheus::Client::DataStores; end

# Stores all the data in simple hashes, one per metric. Each of these metrics
# synchronizes access to their hash, but multiple metrics can run observations
# concurrently.
class Prometheus::Client::DataStores::Synchronized
  def for_metric(metric_name, metric_type:, metric_settings: T.unsafe(nil)); end

  private

  def validate_metric_settings(metric_settings:); end
end

class Prometheus::Client::DataStores::Synchronized::InvalidStoreSettingsError < ::StandardError; end

class Prometheus::Client::DataStores::Synchronized::MetricStore
  # @return [MetricStore] a new instance of MetricStore
  def initialize; end

  def all_values; end
  def get(labels:); end
  def increment(labels:, by: T.unsafe(nil)); end
  def set(labels:, val:); end
  def synchronize; end
end

module Prometheus::Client::Formats; end

# Text format is human readable mainly used for manual inspection.
module Prometheus::Client::Formats::Text
  class << self
    def marshal(registry); end

    private

    def escape(string, format = T.unsafe(nil)); end

    # @yield [metric("#{name}_sum", l, value["sum"])]
    def histogram(name, set, value); end

    def labels(set); end
    def metric(name, labels, value); end
    def representation(metric, label_set, value, &block); end

    # @yield [metric("#{name}_sum", l, value["sum"])]
    def summary(name, set, value); end
  end
end

Prometheus::Client::Formats::Text::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Prometheus::Client::Formats::Text::DELIMITER = T.let(T.unsafe(nil), String)
Prometheus::Client::Formats::Text::HELP_LINE = T.let(T.unsafe(nil), String)
Prometheus::Client::Formats::Text::LABEL = T.let(T.unsafe(nil), String)
Prometheus::Client::Formats::Text::MEDIA_TYPE = T.let(T.unsafe(nil), String)
Prometheus::Client::Formats::Text::METRIC_LINE = T.let(T.unsafe(nil), String)
Prometheus::Client::Formats::Text::REGEX = T.let(T.unsafe(nil), Hash)
Prometheus::Client::Formats::Text::REPLACE = T.let(T.unsafe(nil), Hash)
Prometheus::Client::Formats::Text::SEPARATOR = T.let(T.unsafe(nil), String)
Prometheus::Client::Formats::Text::TYPE_LINE = T.let(T.unsafe(nil), String)
Prometheus::Client::Formats::Text::VERSION = T.let(T.unsafe(nil), String)

# A Gauge is a metric that exposes merely an instantaneous value or some
# snapshot thereof.
class Prometheus::Client::Gauge < ::Prometheus::Client::Metric
  # Decrements Gauge value by 1 or subtracts the given value from the Gauge.
  # (The value can be negative, resulting in a increase of the Gauge.)
  def decrement(by: T.unsafe(nil), labels: T.unsafe(nil)); end

  # Increments Gauge value by 1 or adds the given value to the Gauge.
  # (The value can be negative, resulting in a decrease of the Gauge.)
  def increment(by: T.unsafe(nil), labels: T.unsafe(nil)); end

  # Sets the value for the given label set
  def set(value, labels: T.unsafe(nil)); end

  def type; end
end

# A histogram samples observations (usually things like request durations
# or response sizes) and counts them in configurable buckets. It also
# provides a total count and sum of all observed values.
class Prometheus::Client::Histogram < ::Prometheus::Client::Metric
  # Offer a way to manually specify buckets
  #
  # @raise [ArgumentError]
  # @return [Histogram] a new instance of Histogram
  def initialize(name, docstring:, labels: T.unsafe(nil), preset_labels: T.unsafe(nil), buckets: T.unsafe(nil), store_settings: T.unsafe(nil)); end

  # Returns the value of attribute buckets.
  def buckets; end

  # Returns a hash with all the buckets plus +Inf (count) plus Sum for the given label set
  def get(labels: T.unsafe(nil)); end

  def init_label_set(labels); end

  # Records a given value. The recorded value is usually positive
  # or zero. A negative value is accepted but prevents current
  # versions of Prometheus from properly detecting counter resets
  # in the sum of observations. See
  # https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations
  # for details.
  def observe(value, labels: T.unsafe(nil)); end

  def type; end

  # Returns all label sets with their values expressed as hashes with their buckets
  def values; end

  def with_labels(labels); end

  private

  # Modifies the passed in parameter
  def accumulate_buckets(h); end

  def reserved_labels; end

  # @return [Boolean]
  def sorted?(bucket); end

  class << self
    def exponential_buckets(start:, count:, factor: T.unsafe(nil)); end
    def linear_buckets(start:, width:, count:); end
  end
end

# DEFAULT_BUCKETS are the default Histogram buckets. The default buckets
# are tailored to broadly measure the response time (in seconds) of a
# network service. (From DefBuckets client_golang)
Prometheus::Client::Histogram::DEFAULT_BUCKETS = T.let(T.unsafe(nil), Array)

# LabelSetValidator ensures that all used label sets comply with the
# Prometheus specification.
class Prometheus::Client::LabelSetValidator
  # @return [LabelSetValidator] a new instance of LabelSetValidator
  def initialize(expected_labels:, reserved_labels: T.unsafe(nil)); end

  # Returns the value of attribute expected_labels.
  def expected_labels; end

  # Returns the value of attribute reserved_labels.
  def reserved_labels; end

  # @raise [InvalidLabelSetError]
  def validate_labelset!(labelset); end

  def validate_symbols!(labels); end

  private

  # @return [Boolean]
  def keys_match?(labelset); end

  def validate_name(key); end

  # @raise [ReservedLabelError]
  def validate_reserved_key(key); end

  # @raise [InvalidLabelError]
  def validate_symbol(key); end
end

# TODO: we might allow setting :instance in the future
Prometheus::Client::LabelSetValidator::BASE_RESERVED_LABELS = T.let(T.unsafe(nil), Array)

class Prometheus::Client::LabelSetValidator::InvalidLabelError < ::Prometheus::Client::LabelSetValidator::LabelSetError; end
class Prometheus::Client::LabelSetValidator::InvalidLabelSetError < ::Prometheus::Client::LabelSetValidator::LabelSetError; end
Prometheus::Client::LabelSetValidator::LABEL_NAME_REGEX = T.let(T.unsafe(nil), Regexp)
class Prometheus::Client::LabelSetValidator::LabelSetError < ::StandardError; end
class Prometheus::Client::LabelSetValidator::ReservedLabelError < ::Prometheus::Client::LabelSetValidator::LabelSetError; end

# Metric
class Prometheus::Client::Metric
  # @return [Metric] a new instance of Metric
  def initialize(name, docstring:, labels: T.unsafe(nil), preset_labels: T.unsafe(nil), store_settings: T.unsafe(nil)); end

  # Returns the value of attribute docstring.
  def docstring; end

  # Returns the value for the given label set
  def get(labels: T.unsafe(nil)); end

  def init_label_set(labels); end

  # Returns the value of attribute labels.
  def labels; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute preset_labels.
  def preset_labels; end

  # Returns all label sets with their values
  def values; end

  def with_labels(labels); end

  protected

  def replace_internal_store(new_store); end

  private

  def label_set_for(labels); end
  def reserved_labels; end
  def stringify_values(labels); end

  # @raise [ArgumentError]
  def validate_docstring(docstring); end

  def validate_name(name); end
end

# Registry
class Prometheus::Client::Registry
  # @return [Registry] a new instance of Registry
  def initialize; end

  def counter(name, docstring:, labels: T.unsafe(nil), preset_labels: T.unsafe(nil), store_settings: T.unsafe(nil)); end

  # @return [Boolean]
  def exist?(name); end

  def gauge(name, docstring:, labels: T.unsafe(nil), preset_labels: T.unsafe(nil), store_settings: T.unsafe(nil)); end
  def get(name); end
  def histogram(name, docstring:, labels: T.unsafe(nil), preset_labels: T.unsafe(nil), buckets: T.unsafe(nil), store_settings: T.unsafe(nil)); end
  def metrics; end
  def register(metric); end
  def summary(name, docstring:, labels: T.unsafe(nil), preset_labels: T.unsafe(nil), store_settings: T.unsafe(nil)); end
  def unregister(name); end
end

class Prometheus::Client::Registry::AlreadyRegisteredError < ::StandardError; end

# Summary is an accumulator for samples. It captures Numeric data and
# provides the total count and sum of observations.
class Prometheus::Client::Summary < ::Prometheus::Client::Metric
  # Returns a hash with "sum" and "count" as keys
  def get(labels: T.unsafe(nil)); end

  def init_label_set(labels); end

  # Records a given value. The recorded value is usually positive
  # or zero. A negative value is accepted but prevents current
  # versions of Prometheus from properly detecting counter resets
  # in the sum of observations. See
  # https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations
  # for details.
  def observe(value, labels: T.unsafe(nil)); end

  def type; end

  # Returns all label sets with their values expressed as hashes with their sum/count
  def values; end

  private

  def reserved_labels; end
end

module Prometheus::Middleware; end

# Collector is a Rack middleware that provides a sample implementation of a
# HTTP tracer.
#
# By default metrics are registered on the global registry. Set the
# `:registry` option to use a custom registry.
#
# By default metrics all have the prefix "http_server". Set
# `:metrics_prefix` to something else if you like.
#
# The request counter metric is broken down by code, method and path.
# The request duration metric is broken down by method and path.
class Prometheus::Middleware::Collector
  # @return [Collector] a new instance of Collector
  def initialize(app, options = T.unsafe(nil)); end

  # Returns the value of attribute app.
  def app; end

  def call(env); end

  # Returns the value of attribute registry.
  def registry; end

  protected

  def generate_path(env); end
  def init_exception_metrics; end
  def init_request_metrics; end
  def record(env, code, duration); end
  def strip_ids_from_path(path); end
  def trace(env); end
end

# Exporter is a Rack middleware that provides a sample implementation of a
# Prometheus HTTP exposition endpoint.
#
# By default it will export the state of the global registry and expose it
# under `/metrics`. Use the `:registry` and `:path` options to change the
# defaults.
class Prometheus::Middleware::Exporter
  # @return [Exporter] a new instance of Exporter
  def initialize(app, options = T.unsafe(nil)); end

  # Returns the value of attribute app.
  def app; end

  def call(env); end

  # Returns the value of attribute path.
  def path; end

  # Returns the value of attribute registry.
  def registry; end

  private

  def build_dictionary(formats, fallback); end
  def extract_quality(attributes, default = T.unsafe(nil)); end

  # @return [Boolean]
  def metrics_port?(request_port); end

  def negotiate(env, formats); end
  def not_acceptable(formats); end
  def parse(header); end
  def respond_with(format); end
end

Prometheus::Middleware::Exporter::FALLBACK = Prometheus::Client::Formats::Text
Prometheus::Middleware::Exporter::FORMATS = T.let(T.unsafe(nil), Array)
