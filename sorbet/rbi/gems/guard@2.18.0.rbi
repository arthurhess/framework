# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `guard` gem.
# Please instead update this file by running `bin/tapioca gem guard`.

# Guard is the main module for all Guard related modules and classes.
# Also Guard plugins should use this namespace.
module Guard
  extend ::Guard::Deprecated::Guard::ClassMethods
  extend ::Guard::Internals::Helpers
  extend ::Guard::Commander

  class << self
    # Asynchronously trigger changes
    #
    # Currently supported args:
    #
    #   @example Old style hash:
    #     async_queue_add(modified: ['foo'], added: ['bar'], removed: [])
    #
    #   @example New style signals with args:
    #     async_queue_add([:guard_pause, :unpaused ])
    def async_queue_add(changes); end

    def init(cmdline_options); end

    # Returns the value of attribute interactor.
    def interactor; end

    # Returns the value of attribute listener.
    def listener; end

    # Returns the value of attribute queue.
    def queue; end

    # Initializes the Guard singleton:
    #
    # * Initialize the internal Guard state;
    # * Create the interactor
    # * Select and initialize the file change listener.
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param options [Hash] a customizable set of options
    # @return [Guard] the Guard singleton
    def setup(cmdline_options = T.unsafe(nil)); end

    # Returns the value of attribute state.
    def state; end

    private

    def _evaluate(options); end

    # TODO: remove at some point
    # TODO: not tested because collides with ongoing refactoring
    def _guardfile_deprecated_check(modified); end

    def _listener_callback; end

    # TODO: obsoleted? (move to Dsl?)
    #
    # @return [Boolean]
    def _pluginless_guardfile?; end

    def _relative_pathnames(paths); end

    # Check if any of the changes are actually watched for
    # TODO: why iterate twice? reuse this info when running tasks
    #
    # @return [Boolean]
    def _relevant_changes?(changes); end
  end
end

# Facade for the Guard command line interface managed by
# [Thor](https://github.com/wycats/thor).
#
# This is the main interface to Guard that is called by the Guard binary
# `bin/guard`. Do not put any logic in here, create a class and delegate
# instead.
class Guard::CLI < ::Thor
  # Initializes the templates of all installed Guard plugins and adds them
  # to the `Guardfile` when no Guard name is passed. When passing
  # Guard plugin names it does the same but only for those Guard plugins.
  #
  # initialize
  #
  # @param plugin_names [Array<String>] the name of the Guard plugins to
  # @see Guard::Guardfile.initialize_template
  # @see Guard::Guardfile.initialize_all_templates
  def init(*plugin_names); end

  # List the Guard plugins that are available for use in your system and
  # marks those that are currently used in your `Guardfile`.
  #
  # @see Guard::DslDescriber.list
  def list; end

  # List the Notifiers for use in your system.
  #
  # @see Guard::DslDescriber.notifiers
  def notifiers; end

  # Shows all Guard plugins and their options that are defined in
  # the `Guardfile`
  #
  # @see Guard::DslDescriber.show
  def show; end

  # Start Guard by initializing the defined Guard plugins and watch the file
  # system.
  #
  # This is the default task, so calling `guard` is the same as calling
  # `guard start`.
  #
  # @see Guard.start
  def start; end

  # Shows the current version of Guard.
  #
  # @see Guard::VERSION
  def version; end

  class << self
    def help(shell, subcommand = T.unsafe(nil)); end
  end
end

module Guard::Cli; end
module Guard::Cli::Environments; end

class Guard::Cli::Environments::Bundler
  def verify; end
end

class Guard::Cli::Environments::EvaluateOnly
  # @return [EvaluateOnly] a new instance of EvaluateOnly
  def initialize(options); end

  def evaluate; end
end

class Guard::Cli::Environments::Valid
  # @return [Valid] a new instance of Valid
  def initialize(options); end

  def initialize_guardfile(plugin_names = T.unsafe(nil)); end
  def start_guard; end
end

# Commands supported by guard
module Guard::Commander
  # Pause Guard listening to file changes.
  def pause(expected = T.unsafe(nil)); end

  # Reload Guardfile and all Guard plugins currently enabled.
  # If no scope is given, then the Guardfile will be re-evaluated,
  # which results in a stop/start, which makes the reload obsolete.
  #
  # @param scopes [Hash] hash with a Guard plugin or a group scope
  def reload(scopes = T.unsafe(nil)); end

  # Trigger `run_all` on all Guard plugins currently enabled.
  #
  # @param scopes [Hash] hash with a Guard plugin or a group scope
  def run_all(scopes = T.unsafe(nil)); end

  def show; end

  # Start Guard by evaluating the `Guardfile`, initializing declared Guard
  # plugins and starting the available file change listener.
  # Main method for Guard that is called from the CLI when Guard starts.
  #
  # - Setup Guard internals
  # - Evaluate the `Guardfile`
  # - Configure Notifiers
  # - Initialize the declared Guard plugins
  # - Start the available file change listener
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @see CLI#start
  def start(options = T.unsafe(nil)); end

  def stop; end
end

module Guard::Commands; end

class Guard::Commands::All
  class << self
    def import; end
  end
end

class Guard::Commands::Change
  class << self
    def import; end
  end
end

class Guard::Commands::Notification
  class << self
    def import; end
  end
end

class Guard::Commands::Pause
  class << self
    def import; end
  end
end

class Guard::Commands::Reload
  class << self
    def import; end
  end
end

class Guard::Commands::Scope
  class << self
    def import; end
  end
end

class Guard::Commands::Show
  class << self
    def import; end
  end
end

class Guard::Config < ::Nenv::Environment
  # @return [Config] a new instance of Config
  def initialize; end

  # @return [Boolean]
  def silence_deprecations?; end
end

# @deprecated Every method in this module is deprecated
module Guard::Deprecated; end

module Guard::Deprecated::Dsl
  class << self
    def add_deprecated(dsl_klass); end
  end
end

module Guard::Deprecated::Dsl::ClassMethods
  def evaluate_guardfile(options = T.unsafe(nil)); end
end

# `Guard::Guardfile::Evaluator.new(options).evaluate_guardfile`
# instead.
#
# to upgrade for Guard 2.0
#
# @deprecated Use
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How
Guard::Deprecated::Dsl::ClassMethods::EVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)

Guard::Deprecated::Dsl::MORE_INFO_ON_UPGRADING_TO_GUARD_2 = T.let(T.unsafe(nil), String)

module Guard::Deprecated::Evaluator
  def evaluate_guardfile; end
  def reevaluate_guardfile; end

  class << self
    def add_deprecated(klass); end
  end
end

Guard::Deprecated::Evaluator::EVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)
Guard::Deprecated::Evaluator::REEVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)

module Guard::Deprecated::Guard
  class << self
    def add_deprecated(klass); end
  end
end

module Guard::Deprecated::Guard::ClassMethods
  def add_group(name, options = T.unsafe(nil)); end
  def add_guard(*args); end
  def add_plugin(name, options = T.unsafe(nil)); end
  def evaluate_guardfile; end
  def evaluator; end
  def get_guard_class(name, fail_gracefully = T.unsafe(nil)); end
  def group(filter); end
  def groups(filter); end
  def guard_gem_names; end
  def guards(filter = T.unsafe(nil)); end
  def listener=(_); end
  def locate_guard(name); end
  def lock; end
  def options; end
  def plugin(filter); end
  def plugins(filter); end
  def reset_evaluator(_options); end
  def runner; end
  def running; end
  def scope; end
  def scope=(scope); end
end

Guard::Deprecated::Guard::ClassMethods::ADD_GROUP = T.let(T.unsafe(nil), String)

# @deprecated Use `Guard.add_plugin(name, options = {})` instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
#   upgrade for Guard 2.0
Guard::Deprecated::Guard::ClassMethods::ADD_GUARD = T.let(T.unsafe(nil), String)

Guard::Deprecated::Guard::ClassMethods::ADD_PLUGIN = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::EVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::EVALUATOR = T.let(T.unsafe(nil), String)

# @deprecated Use
#   `Guard::PluginUtil.new(name).plugin_class(fail_gracefully:
#   fail_gracefully)` instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
#   upgrade for Guard 2.0
Guard::Deprecated::Guard::ClassMethods::GET_GUARD_CLASS = T.let(T.unsafe(nil), String)

Guard::Deprecated::Guard::ClassMethods::GROUP = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::GROUPS = T.let(T.unsafe(nil), String)

# @deprecated Use `Guard.plugins(filter)` instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
#   upgrade for Guard 2.0
Guard::Deprecated::Guard::ClassMethods::GUARDS = T.let(T.unsafe(nil), String)

# Deprecator message for the `Guard.guard_gem_names` method
#
# @deprecated Use `Guard::PluginUtil.plugin_names` instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
#   upgrade for Guard 2.0
Guard::Deprecated::Guard::ClassMethods::GUARD_GEM_NAMES = T.let(T.unsafe(nil), String)

Guard::Deprecated::Guard::ClassMethods::LISTENER_ASSIGN = T.let(T.unsafe(nil), String)

# @deprecated Use `Guard::PluginUtil.new(name).plugin_location` instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
#   upgrade for Guard 2.0
Guard::Deprecated::Guard::ClassMethods::LOCATE_GUARD = T.let(T.unsafe(nil), String)

Guard::Deprecated::Guard::ClassMethods::LOCK = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::MORE_INFO_ON_UPGRADING_TO_GUARD_2 = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::OPTIONS = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::PLUGIN = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::PLUGINS = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::RESET_EVALUATOR = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::RUNNER = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::RUNNING = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::SCOPE = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::SCOPE_ASSIGN = T.let(T.unsafe(nil), String)

module Guard::Deprecated::Guardfile
  class << self
    def add_deprecated(dsl_klass); end
  end
end

module Guard::Deprecated::Guardfile::ClassMethods
  def create_guardfile(options = T.unsafe(nil)); end
  def initialize_all_templates; end
  def initialize_template(plugin_name); end
end

# upgrade for Guard 2.0
#
# @deprecated Use {Guardfile::Generator#create_guardfile} instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
Guard::Deprecated::Guardfile::ClassMethods::CREATE_GUARDFILE = T.let(T.unsafe(nil), String)

# instead.
#
# upgrade for Guard 2.0
#
# Deprecator message for the `Guardfile.initialize_all_templates` method
#
# @deprecated Use {Guardfile::Generator#initialize_all_templates}
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
Guard::Deprecated::Guardfile::ClassMethods::INITIALIZE_ALL_TEMPLATES = T.let(T.unsafe(nil), String)

# upgrade for Guard 2.0
#
# Deprecator message for the `Guardfile.initialize_template` method
#
# @deprecated Use {Guardfile::Generator#initialize_template} instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
Guard::Deprecated::Guardfile::ClassMethods::INITIALIZE_TEMPLATE = T.let(T.unsafe(nil), String)

Guard::Deprecated::Guardfile::ClassMethods::MORE_INFO_ON_UPGRADING_TO_GUARD_2 = T.let(T.unsafe(nil), String)

module Guard::Deprecated::Watcher
  class << self
    def add_deprecated(klass); end
  end
end

module Guard::Deprecated::Watcher::ClassMethods
  # @return [Boolean]
  def match_guardfile?(files); end
end

Guard::Deprecated::Watcher::ClassMethods::MATCH_GUARDFILE = T.let(T.unsafe(nil), String)

# The Dsl class provides the methods that are used in each `Guardfile` to
# describe the behaviour of Guard.
#
# The main keywords of the DSL are {#guard} and {#watch}. These are necessary
# to define the used Guard plugins and the file changes they are watching.
#
# You can optionally group the Guard plugins with the {#group} keyword and
# ignore and filter certain paths with the {#ignore} and {#filter} keywords.
#
# You can set your preferred system notification library with {#notification}
# and pass some optional configuration options for the library. If you don't
# configure a library, Guard will automatically pick one with default options
# (if you don't want notifications, specify `:off` as library). Please see
# {Notifier} for more information about the supported libraries.
#
# A more advanced DSL use is the {#callback} keyword that allows you to
# execute arbitrary code before or after any of the {Plugin#start},
# {Plugin#stop}, {Plugin#reload}, {Plugin#run_all},
# {Plugin#run_on_changes}, {Plugin#run_on_additions},
# {Plugin#run_on_modifications} and {Plugin#run_on_removals}
# Guard plugins method.
# You can even insert more hooks inside these methods. Please [checkout the
# Wiki page](https://github.com/guard/guard/wiki/Hooks-and-callbacks) for
# more details.
#
# The DSL will also evaluate normal Ruby code.
#
# There are two possible locations for the `Guardfile`:
#
# * The `Guardfile` or `guardfile.rb` in the current directory where Guard
#   has been started
# * The `.Guardfile` in your home directory.
#
# In addition, if a user configuration `.guard.rb` in your home directory is
# found, it will be appended to the current project `Guardfile`.
#
# @see https://github.com/guard/guard/wiki/Guardfile-examples
class Guard::Dsl
  extend ::Guard::Deprecated::Dsl::ClassMethods

  # Defines a callback to execute arbitrary code before or after any of
  # the `start`, `stop`, `reload`, `run_all`, `run_on_changes`,
  # `run_on_additions`, `run_on_modifications` and `run_on_removals` plugin
  # method.
  #
  # @example Add callback before the `reload` action.
  #   callback(:reload_begin) { puts "Let's reload!" }
  # @example Add callback before the `start` and `stop` actions.
  #
  #   my_lambda = lambda do |plugin, event, *args|
  #   puts "Let's #{event} #{plugin} with #{args}!"
  #   end
  #
  #   callback(my_lambda, [:start_begin, :start_end])
  # @param args [Array] the callback arguments
  # @yield a callback block
  def callback(*args, &block); end

  # Sets Guard to clear the screen before every task is run
  #
  # @example switching clearing the screen on
  #   clearing(:on)
  # @param on [Symbol] ':on' to turn on, ':off' (default) to turn off
  def clearing(on); end

  # Sets the directories to pass to Listen
  #
  # @example watch only given directories
  #   directories %w(lib specs)
  # @param directories [Array] directories for Listen to watch
  def directories(directories); end

  # :nodoc
  def evaluate(contents, filename, lineno); end

  # Ignores certain paths globally.
  # TODO: deprecate
  #
  # @example Ignore some paths
  #   ignore %r{^ignored/path/}, /man/
  # @param regexps [Regexp] a pattern (or list of patterns) for ignoring paths
  def filter(*regexps); end

  # Replaces ignored paths globally
  # TODO: deprecate
  #
  # @example Ignore only these paths
  #   ignore! %r{^ignored/path/}, /man/
  # @param regexps [Regexp] a pattern (or list of patterns) for ignoring paths
  def filter!(*regexps); end

  # Declares a group of Guard plugins to be run with `guard start --group
  #   group_name`.
  #
  # @example Declare two groups of Guard plugins
  #   group :backend do
  #   guard :spork
  #   guard :rspec
  #   end
  #
  #   group :frontend do
  #   guard :passenger
  #   guard :livereload
  #   end
  # @param name [Symbol, String, Array<Symbol, String>] the group name called
  #   from the CLI
  # @param options [Hash] the options accepted by the group
  # @see Group
  # @see Guard.add_group
  # @see #guard
  # @yield a block where you can declare several Guard plugins
  def group(*args); end

  # Declares a Guard plugin to be used when running `guard start`.
  #
  # The name parameter is usually the name of the gem without
  # the 'guard-' prefix.
  #
  # The available options are different for each Guard implementation.
  #
  # @example Declare a Guard without `watch` patterns
  #   guard :rspec
  # @example Declare a Guard with a `watch` pattern
  #   guard :rspec do
  #   watch %r{.*_spec.rb}
  #   end
  # @param name [String] the Guard plugin name
  # @param options [Hash] the options accepted by the Guard plugin
  # @see Plugin
  # @see Guard.add_plugin
  # @see #watch
  # @see #group
  # @yield a block where you can declare several watch patterns and actions
  def guard(name, options = T.unsafe(nil)); end

  # Ignores certain paths globally.
  #
  # @example Ignore some paths
  #   ignore %r{^ignored/path/}, /man/
  # @param regexps [Regexp] a pattern (or list of patterns) for ignoring paths
  def ignore(*regexps); end

  # Replaces ignored paths globally
  #
  # @example Ignore only these paths
  #   ignore! %r{^ignored/path/}, /man/
  # @param regexps [Regexp] a pattern (or list of patterns) for ignoring paths
  def ignore!(*regexps); end

  # Sets the interactor options or disable the interactor.
  #
  # @example Pass options to the interactor
  #   interactor option1: 'value1', option2: 'value2'
  # @example Turn off interactions
  #   interactor :off
  # @param options [Symbol, Hash] either `:off` or a Hash with interactor
  #   options
  def interactor(options); end

  # Configures the Guard logger.
  #
  # * Log level must be either `:debug`, `:info`, `:warn` or `:error`.
  # * Template supports the following placeholders: `:time`, `:severity`,
  #   `:progname`, `:pid`, `:unit_of_work_id` and `:message`.
  # * Time format directives are the same as `Time#strftime` or
  #   `:milliseconds`.
  # * The `:only` and `:except` options must be a `RegExp`.
  #
  # @example Set the log level
  #   logger level: :warn
  # @example Set a custom log template
  #   logger template: '[Guard - :severity - :progname - :time] :message'
  # @example Set a custom time format
  #   logger time_format: '%h'
  # @example Limit logging to a Guard plugin
  #   logger only: :jasmine
  # @example Log all but not the messages from a specific Guard plugin
  #   logger except: :jasmine
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] the log options
  def logger(options); end

  # Set notification options for the system notifications.
  # You can set multiple notifications, which allows you to show local
  # system notifications and remote notifications with separate libraries.
  # You can also pass `:off` as library to turn off notifications.
  #
  # @example Define multiple notifications
  #   notification :ruby_gntp
  #   notification :ruby_gntp, host: '192.168.1.5'
  # @param notifier [Symbol, String] the name of the notifier to use
  # @param opts [Hash] the notification library options
  # @see Guard::Notifier for available notifier and its options.
  def notification(notifier, opts = T.unsafe(nil)); end

  # Sets the default scope on startup
  #
  # @example Scope Guard to a single group
  #   scope group: :frontend
  # @example Scope Guard to multiple groups
  #   scope groups: [:specs, :docs]
  # @example Scope Guard to a single plugin
  #   scope plugin: :test
  # @example Scope Guard to multiple plugins
  #   scope plugins: [:jasmine, :rspec]
  # @param scope [Hash] the scope for the groups and plugins
  def scope(scope = T.unsafe(nil)); end

  # Defines a pattern to be watched in order to run actions on file
  # modification.
  #
  # modification
  #
  # @example Declare global watchers outside of a Guard
  #   watch(%r{^(.+)$}) { |m| puts "#{m[1]} changed." }
  # @example Declare watchers for a Guard
  #   guard :rspec do
  #   watch('spec/spec_helper.rb')
  #   watch(%r{^.+_spec.rb})
  #   watch(%r{^app/controllers/(.+).rb}) do |m|
  #   'spec/acceptance/#{m[1]}s_spec.rb'
  #   end
  #   end
  # @param pattern [String, Regexp] the pattern that Guard must watch for
  # @see #guard
  # @see Guard::Watcher
  # @yield a block to be run when the pattern is matched
  # @yieldparam m [MatchData] matches of the pattern
  # @yieldreturn a directory, a filename, an array of
  #   directories / filenames, or nothing (can be an arbitrary command)
  def watch(pattern, &action); end

  private

  def _cleanup_backtrace(backtrace); end
end

# Wrap exceptions during parsing Guardfile
class Guard::Dsl::Error < ::RuntimeError; end

Guard::Dsl::WARN_INVALID_LOG_LEVEL = T.let(T.unsafe(nil), String)
Guard::Dsl::WARN_INVALID_LOG_OPTIONS = T.let(T.unsafe(nil), String)

# The DslDescriber evaluates the Guardfile and creates an internal structure
# of it that is used in some inspection utility methods like the CLI commands
# `show` and `list`.
#
# @see Guard::Dsl
# @see Guard::CLI
class Guard::DslDescriber
  # @return [DslDescriber] a new instance of DslDescriber
  def initialize(options = T.unsafe(nil)); end

  # List the Guard plugins that are available for use in your system and marks
  # those that are currently used in your `Guardfile`.
  #
  # @see CLI#list
  def list; end

  # Shows all notifiers and their options that are defined in
  # the `Guardfile`.
  #
  # @see CLI#show
  def notifiers; end

  # Shows all Guard plugins and their options that are defined in
  # the `Guardfile`.
  #
  # @see CLI#show
  def show; end

  private

  def _add_row(rows, name, available, used, option, value); end
end

# TODO: this should probably be a base class for Dsl instead (in Guard 3.x)
class Guard::DslReader < ::Guard::Dsl
  # @return [DslReader] a new instance of DslReader
  def initialize; end

  def callback(*_args, &_block); end
  def clearing(_on); end
  def directories(_directories); end
  def group(*_args); end
  def guard(name, _options = T.unsafe(nil)); end
  def ignore(*_regexps); end
  def ignore!(*_regexps); end
  def interactor(_options); end
  def logger(_options); end

  # Stub everything else
  def notification(_notifier, _opts = T.unsafe(nil)); end

  # Returns the value of attribute plugin_names.
  def plugin_names; end

  def scope(_scope = T.unsafe(nil)); end
  def watch(_pattern, &_action); end
end

# A group of Guard plugins. There are two reasons why you want to group your
# Guard plugins:
#
# * You can start only certain groups from the command line by passing the
#   `--group` option to `guard start`.
# * Abort task execution chain on failure within a group with the
#   `:halt_on_fail` option.
#
# @example Group that aborts on failure
#
#   group :frontend, halt_on_fail: true do
#   guard 'coffeescript', input: 'spec/coffeescripts',
#   output: 'spec/javascripts'
#   guard 'jasmine-headless-webkit' do
#   watch(%r{^spec/javascripts/(.*)\..*}) do |m|
#   newest_js_file("spec/javascripts/#{m[1]}_spec")
#   end
#   end
#   end
# @see Guard::CLI
class Guard::Group
  # Initializes a Group.
  #
  # @option options
  # @param name [String] the name of the group
  # @param options [Hash] the group options
  # @return [Group] a new instance of Group
  def initialize(name, options = T.unsafe(nil)); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # Returns the group title.
  #
  # @example Title for a group named 'backend'
  #   > Guard::Group.new('backend').title
  #   => "Backend"
  # @return [String]
  def title; end

  # String representation of the group.
  #
  # @example String representation of a group named 'backend'
  #   > Guard::Group.new('backend').to_s
  #   => "#<Guard::Group @name=backend @options={}>"
  # @return [String] the string representation
  def to_s; end
end

module Guard::Guardfile; end

# This class is responsible for evaluating the Guardfile. It delegates to
# Guard::Dsl for the actual objects generation from the Guardfile content.
#
# TODO: rename this to a Locator or Loader or something
#
# @see Guard::Dsl
class Guard::Guardfile::Evaluator
  include ::Guard::Deprecated::Evaluator

  # Initializes a new Guard::Guardfile::Evaluator object.
  #
  # content of a valid Guardfile
  #
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Evaluator] a new instance of Evaluator
  def initialize(opts = T.unsafe(nil)); end

  # @return [Boolean]
  def custom?; end

  # Evaluates the DSL methods in the `Guardfile`.
  #
  # path
  #
  #   options = { guardfile: '/Users/guardfile/MyAwesomeGuardfile' }
  #   Guard::Guardfile::Evaluator.new(options).evaluate
  #
  # @example Programmatically evaluate a Guardfile
  #   Guard::Guardfile::Evaluator.new.evaluate
  # @example Programmatically evaluate a Guardfile with a custom Guardfile
  # @example Programmatically evaluate a Guardfile with an inline Guardfile
  #
  #   options = { contents: 'guard :rspec' }
  #   Guard::Guardfile::Evaluator.new(options).evaluate
  def evaluate; end

  # Gets the content of the `Guardfile` concatenated with the global
  # user configuration file.
  #
  # @example Programmatically get the content of the current Guardfile
  #   Guard::Guardfile::Evaluator.new.guardfile_contents
  #   => "guard :rspec"
  # @return [String] the Guardfile content
  def guardfile_contents; end

  # Tests if the current `Guardfile` contains a specific Guard plugin.
  #
  # plugin
  #
  #   File.read('Guardfile')
  #   => "guard :rspec"
  #
  #   Guard::Guardfile::Evaluator.new.guardfile_include?('rspec)
  #   => true
  #
  # TODO: rename this method to it matches RSpec examples better
  #
  # @example Programmatically test if a Guardfile contains a specific Guard
  # @param plugin_name [String] the name of the Guard
  # @return [Boolean] whether the Guard plugin has been declared
  def guardfile_include?(plugin_name); end

  # Returns the value of attribute guardfile_path.
  def guardfile_path; end

  def guardfile_source; end

  # @return [Boolean]
  def inline?; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute path.
  def path; end

  private

  def _fetch_guardfile_contents; end
  def _from_deprecated(opts); end
  def _guardfile_contents; end

  # @return [Boolean]
  def _guardfile_contents_usable?; end

  def _guardfile_contents_without_user_config; end
  def _instance_eval_guardfile(contents); end
  def _read(path); end
  def _use_default!; end
  def _use_inline; end
  def _use_provided; end
end

Guard::Guardfile::Evaluator::DEFAULT_GUARDFILES = T.let(T.unsafe(nil), Array)
Guard::Guardfile::Evaluator::ERROR_NO_GUARDFILE = T.let(T.unsafe(nil), String)
Guard::Guardfile::Evaluator::ERROR_NO_PLUGINS = T.let(T.unsafe(nil), String)
class Guard::Guardfile::Evaluator::Error < ::RuntimeError; end
class Guard::Guardfile::Evaluator::NoCustomGuardfile < ::Guard::Guardfile::Evaluator::Error; end
class Guard::Guardfile::Evaluator::NoGuardfileError < ::Guard::Guardfile::Evaluator::Error; end
class Guard::Guardfile::Evaluator::NoPluginsError < ::Guard::Guardfile::Evaluator::Error; end

# This class is responsible for generating the Guardfile and adding Guard'
# plugins' templates into it.
#
# @see Guard::CLI
class Guard::Guardfile::Generator
  # Creates the initial Guardfile template when it does not
  # already exist.
  #
  # @see Guard::CLI#init
  def create_guardfile; end

  # Adds the templates of all installed Guard implementations to an
  # existing Guardfile.
  #
  # @see Guard::CLI#init
  def initialize_all_templates; end

  # Adds the Guardfile template of a Guard plugin to an existing Guardfile.
  #
  # @param plugin_name [String] the name of the Guard plugin or template to
  #   initialize
  # @see Guard::CLI#init
  def initialize_template(plugin_name); end

  private

  def _ui(*args); end
end

class Guard::Guardfile::Generator::Error < ::RuntimeError; end

# The Guardfile template for `guard init`
Guard::Guardfile::Generator::GUARDFILE_TEMPLATE = T.let(T.unsafe(nil), String)

Guard::Guardfile::Generator::HOME_TEMPLATES = T.let(T.unsafe(nil), Pathname)
Guard::Guardfile::Generator::INFO_TEMPLATE_ADDED = T.let(T.unsafe(nil), String)

class Guard::Guardfile::Generator::NoSuchPlugin < ::Guard::Guardfile::Generator::Error
  # @return [NoSuchPlugin] a new instance of NoSuchPlugin
  def initialize(plugin_name); end

  # Returns the value of attribute class_name.
  def class_name; end

  def message; end

  # Returns the value of attribute plugin_name.
  def plugin_name; end
end

class Guard::Interactor
  extend ::Forwardable

  # Initializes the interactor. This configures
  # Pry and creates some custom commands and aliases
  # for Guard.
  #
  # @return [Interactor] a new instance of Interactor
  def initialize(no_interaction = T.unsafe(nil)); end

  def background(*args, **_arg1, &block); end
  def foreground(*args, **_arg1, &block); end
  def handle_interrupt(*args, **_arg1, &block); end

  # @return [Boolean]
  def interactive?; end

  private

  # Returns the value of attribute idle_job.
  def idle_job; end

  class << self
    # TODO: allow custom user idle jobs, e.g. [:pry, :sleep, :exit, ...]
    #
    # @return [Boolean]
    def enabled; end

    # TODO: handle switching interactors during runtime?
    def enabled=(_arg0); end

    # TODO: allow custom user idle jobs, e.g. [:pry, :sleep, :exit, ...]
    #
    # @return [Boolean]
    def enabled?; end

    def options; end

    # Pass options to interactor's job when it's created
    def options=(_arg0); end
  end
end

# @private api
module Guard::Internals; end

class Guard::Internals::Debugging
  class << self
    # Sets up debugging:
    #
    # * aborts on thread exceptions
    # * Set the logging level to `:debug`
    # * traces execution of Kernel.system and backtick calls
    def start; end

    def stop; end

    private

    def _notify(*args); end

    # reset singleton - called by tests
    def _reset; end

    def _trace(mod, meth, &block); end
    def _untrace(mod, meth); end
  end
end

class Guard::Internals::Groups
  # @return [Groups] a new instance of Groups
  def initialize; end

  def add(name, options = T.unsafe(nil)); end
  def all(filter = T.unsafe(nil)); end

  private

  def matcher_for(filter); end
end

Guard::Internals::Groups::DEFAULT_GROUPS = T.let(T.unsafe(nil), Array)

module Guard::Internals::Helpers
  def _relative_pathname(path); end
end

class Guard::Internals::Plugins
  # @return [Plugins] a new instance of Plugins
  def initialize; end

  # TODO: should it allow duplicates? (probably yes because of different
  # configs or groups)
  def add(name, options); end

  def all(filter = T.unsafe(nil)); end
  def remove(plugin); end

  private

  def matcher_for(filter); end
end

class Guard::Internals::Queue
  # @return [Queue] a new instance of Queue
  def initialize(commander); end

  def <<(changes); end

  # @return [Boolean]
  def pending?; end

  # Process the change queue, running tasks within the main Guard thread
  def process; end

  private

  def _run_actions(actions); end
end

class Guard::Internals::Scope
  # @return [Scope] a new instance of Scope
  def initialize; end

  def from_interactor(scope); end

  # TODO: refactor
  def grouped_plugins(scope = T.unsafe(nil)); end

  def titles(scope = T.unsafe(nil)); end
  def to_hash; end

  private

  def _find_non_empty_scope(type, local_scope); end
  def _groups; end

  # TODO: let the Plugins and Groups classes handle this?
  # TODO: why even instantiate?? just to check if it exists?
  def _hashify_scope(type); end

  def _instantiate(meth, obj); end
  def _plugins; end

  # TODO: move to session
  def _scope_names(new_scope, name); end
end

# TODO: split into a commandline class and session (plugins, groups)
# TODO: swap session and metadata
class Guard::Internals::Session
  # @return [Session] a new instance of Session
  def initialize(new_options); end

  # @return [Boolean]
  def clear?; end

  def clearing(on); end

  # @return [Boolean]
  def clearing?; end

  def cmdline_groups; end
  def cmdline_plugins; end

  # TODO: call this from within action, not within interactor command
  def convert_scope(entries); end

  # @return [Boolean]
  def debug?; end

  def evaluator_options; end

  # Returns the value of attribute groups.
  def groups; end

  # TODO: create a EvaluatorResult class?
  def guardfile_group_scope; end

  # Returns the value of attribute guardfile_ignore.
  def guardfile_ignore; end

  def guardfile_ignore=(ignores); end

  # Returns the value of attribute guardfile_ignore_bang.
  def guardfile_ignore_bang; end

  # Sets the attribute guardfile_ignore_bang
  #
  # @param value the value to set the attribute guardfile_ignore_bang to.
  def guardfile_ignore_bang=(_arg0); end

  def guardfile_notification=(config); end

  # Returns the value of attribute guardfile_plugin_scope.
  def guardfile_plugin_scope; end

  def guardfile_scope(scope); end

  # Returns the value of attribute interactor_name.
  def interactor_name; end

  def listener_args; end
  def notify_options; end

  # Returns the value of attribute plugins.
  def plugins; end

  def watchdirs; end

  # set by Dsl with :directories() command
  def watchdirs=(dirs); end
end

Guard::Internals::Session::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Guard::Internals::State
  # Minimal setup for non-interactive commands (list, init, show, etc.)
  #
  # @return [State] a new instance of State
  def initialize(cmdline_opts); end

  # Returns the value of attribute scope.
  def scope; end

  # Returns the value of attribute session.
  def session; end
end

module Guard::Internals::Tracing
  class << self
    def trace(mod, meth); end
    def untrace(mod, meth); end
  end
end

module Guard::Internals::Traps
  class << self
    def handle(signal, &block); end
  end
end

module Guard::Jobs; end

class Guard::Jobs::Base
  # @return [Base] a new instance of Base
  def initialize(_options); end

  def background; end

  # @return [Symbol] :stopped once job is finished
  # @return [Symbol] :exit to tell Guard to terminate
  def foreground; end

  # Signal handler calls this, so avoid actually doing
  # anything other than signaling threads
  def handle_interrupt; end
end

class Guard::Jobs::PryWrapper < ::Guard::Jobs::Base
  # @return [PryWrapper] a new instance of PryWrapper
  def initialize(options); end

  def background; end
  def foreground; end
  def handle_interrupt; end

  private

  # Add Pry hooks:
  #
  # * Load `~/.guardrc` within each new Pry session.
  # * Load project's `.guardrc` within each new Pry session.
  # * Restore prompt after each evaluation.
  def _add_hooks(options); end

  # Add a `when_started` hook that loads a global .guardrc if it exists.
  def _add_load_guard_rc_hook(guard_rc); end

  # Add a `when_started` hook that loads a project .guardrc if it exists.
  def _add_load_project_guard_rc_hook(guard_rc); end

  # Add a `after_eval` hook that restores visibility after a command is
  # eval.
  def _add_restore_visibility_hook; end

  def _clip_name(target); end
  def _configure_history_file(history_file); end

  # Configures the pry prompt to see `guard` instead of
  # `pry`.
  def _configure_prompt; end

  # Creates command aliases for the commands: `help`, `reload`, `change`,
  # `scope`, `notification`, `pause`, `exit` and `quit`, which will be the
  # first letter of the command.
  def _create_command_aliases; end

  # Create a shorthand command to run the `:run_all`
  # action on a specific Guard group. For example,
  # when you have a group `frontend`, then a command
  # `frontend` is created that runs `all frontend`.
  def _create_group_commands; end

  # Create a shorthand command to run the `:run_all`
  # action on a specific Guard plugin. For example,
  # when guard-rspec is available, then a command
  # `rspec` is created that runs `all rspec`.
  def _create_guard_commands; end

  # Creates a command that triggers the `:run_all` action
  # when the command is empty (just pressing enter on the
  # beginning of a line).
  def _create_run_all_command; end

  def _history(pry); end
  def _kill_pry; end

  # @return [Boolean]
  def _killed?; end

  # Returns a proc that will return itself a string ending with the given
  # `ending_char` when called.
  def _prompt(ending_char); end

  def _pry_commands; end
  def _pry_config; end

  # Replaces reset defined inside of Pry with a reset that
  # instead restarts guard.
  def _replace_reset_command; end

  # Returns the plugins scope, or the groups scope ready for display in the
  # prompt.
  def _scope_for_prompt; end

  def _setup(options); end
  def _setup_commands; end
  def _switch_to_pry; end

  # Returns the value of attribute thread.
  def thread; end
end

# The default Ruby script to configure Guard Pry if the option `:guard_rc`
# is not defined.
Guard::Jobs::PryWrapper::GUARD_RC = T.let(T.unsafe(nil), String)

# The default Guard Pry history file if the option `:history_file` is not
# defined.
Guard::Jobs::PryWrapper::HISTORY_FILE = T.let(T.unsafe(nil), String)

# List of shortcuts for each interactor command
Guard::Jobs::PryWrapper::SHORTCUTS = T.let(T.unsafe(nil), Hash)

class Guard::Jobs::Sleep < ::Guard::Jobs::Base
  def background; end
  def foreground; end
  def handle_interrupt; end
end

class Guard::Jobs::TerminalSettings
  # @return [TerminalSettings] a new instance of TerminalSettings
  def initialize; end

  # @return [Boolean]
  def configurable?; end

  def echo; end
  def restore; end
  def save; end
end

class Guard::Notifier
  class << self
    def connect(options = T.unsafe(nil)); end

    # Used by dsl describer
    def detected; end

    def disconnect; end
    def notify(message, options = T.unsafe(nil)); end

    # Used by dsl describer
    def supported; end

    def toggle; end
    def turn_on; end
  end
end

Guard::Notifier::DEPRECATED_IMPLICIT_CONNECT = T.let(T.unsafe(nil), String)

# A class that holds options. Can be instantiated with default options.
class Guard::Options < ::Thor::CoreExt::HashWithIndifferentAccess
  # Initializes an Guard::Options object. `default_opts` is merged into
  # `opts`.
  #
  # @param opts [Hash] the options
  # @param default_opts [Hash] the default options
  # @return [Options] a new instance of Options
  def initialize(opts = T.unsafe(nil), default_opts = T.unsafe(nil)); end

  # workaround for: https://github.com/erikhuda/thor/issues/504
  def fetch(name); end
end

# Base class from which every Guard plugin implementation must inherit.
#
# Guard will trigger the {#start}, {#stop}, {#reload}, {#run_all} and
# {#run_on_changes} ({#run_on_additions}, {#run_on_modifications} and
# {#run_on_removals}) task methods depending on user interaction and file
# modification.
#
# {#run_on_changes} could be implemented to handle all the changes task case
# (additions, modifications, removals) in once, or each task can be
# implemented separately with a specific behavior.
#
# In each of these Guard task methods you have to implement some work when
# you want to support this kind of task. The return value of each Guard task
# method is not evaluated by Guard, but it'll be passed to the "_end" hook
# for further evaluation. You can throw `:task_has_failed` to indicate that
# your Guard plugin method was not successful, and successive Guard plugin
# tasks will be aborted when the group has set the `:halt_on_fail` option.
#
# Each Guard plugin should provide a template Guardfile located within the Gem
# at `lib/guard/guard-name/templates/Guardfile`.
#
# Watchers for a Guard plugin should return a file path or an array of files
# paths to Guard, but if your Guard plugin wants to allow any return value
# from a watcher, you can set the `any_return` option to true.
#
# If one of those methods raises an exception other than `:task_has_failed`,
# the `Guard::GuardName` instance will be removed from the active Guard
# plugins.
#
# @example Throw :task_has_failed
#
#   def run_all
#   if !runner.run(['all'])
#   throw :task_has_failed
#   end
#   end
# @see Guard::Group
class Guard::Plugin
  # Initializes a Guard plugin.
  # Don't do any work here, especially as Guard plugins get initialized even
  # if they are not in an active group!
  #
  # @option options
  # @option options
  # @option options
  # @param options [Hash] the Guard plugin options
  # @return [Plugin] a new instance of Plugin
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute callbacks.
  def callbacks; end

  # Sets the attribute callbacks
  #
  # @param value the value to set the attribute callbacks to.
  def callbacks=(_arg0); end

  # Returns the value of attribute group.
  def group; end

  # Sets the attribute group
  #
  # @param value the value to set the attribute group to.
  def group=(_arg0); end

  # When event is a Symbol, {#hook} will generate a hook name
  # by concatenating the method name from where {#hook} is called
  # with the given Symbol.
  #
  # Here, when {Guard::Plugin#run_all} is called, {#hook} will notify
  # callbacks registered for the "run_all_foo" event.
  #
  # When event is a String, {#hook} will directly turn the String
  # into a Symbol.
  #
  # When {Guard::Plugin::run_all} is called, {#hook} will notify
  # callbacks registered for the "foo_bar" event.
  #
  # @example Add a hook with a Symbol
  #
  #   def run_all
  #   hook :foo
  #   end
  # @example Add a hook with a String
  #
  #   def run_all
  #   hook "foo_bar"
  #   end
  # @param event [Symbol, String] the name of the Guard event
  # @param args [Array] the parameters are passed as is to the callbacks
  #   registered for the given event.
  def hook(event, *args); end

  # Returns the plugin's name (without "guard-").
  #
  # @example Name for Guard::RSpec
  #   Guard::RSpec.new.name
  #   #=> "rspec"
  # @return [String]
  def name; end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # Returns the plugin's class name without the Guard:: namespace.
  #
  # @example Title for Guard::RSpec
  #   Guard::RSpec.new.title
  #   #=> "RSpec"
  # @return [String]
  def title; end

  # String representation of the plugin.
  #
  # @example String representation of an instance of the Guard::RSpec plugin
  #
  #   Guard::RSpec.new.title
  #   #=> "#<Guard::RSpec @name=rspec @group=#<Guard::Group @name=default
  #   @options={}> @watchers=[] @callbacks=[] @options={all_after_pass:
  #   true}>"
  # @return [String] the string representation
  def to_s; end

  # Returns the value of attribute watchers.
  def watchers; end

  # Sets the attribute watchers
  #
  # @param value the value to set the attribute watchers to.
  def watchers=(_arg0); end

  private

  # Add all the Guard::Plugin's callbacks to the global @callbacks array
  # that's used by Guard to know which callbacks to notify.
  def _register_callbacks; end

  class << self
    # Add a callback.
    #
    # @param listener [Block] the listener to notify
    # @param guard_plugin [Guard::Plugin] the Guard plugin to add the callback
    # @param events [Array<Symbol>] the events to register
    def add_callback(listener, guard_plugin, events); end

    # Get all callbacks registered for all Guard plugins present in the
    # Guardfile.
    def callbacks; end

    # Returns the non-namespaced class name of the plugin
    #
    # @example Non-namespaced class name for Guard::RSpec
    #   Guard::RSpec.non_namespaced_classname
    #   #=> "RSpec"
    # @return [String]
    def non_namespaced_classname; end

    # Returns the non-namespaced name of the plugin
    #
    # @example Non-namespaced name for Guard::RSpec
    #   Guard::RSpec.non_namespaced_name
    #   #=> "rspec"
    # @return [String]
    def non_namespaced_name; end

    # Notify a callback.
    #
    # @param guard_plugin [Guard::Plugin] the Guard plugin to add the callback
    # @param event [Symbol] the event to trigger
    # @param args [Array] the arguments for the listener
    def notify(guard_plugin, event, *args); end

    # Reset all callbacks.
    #
    # TODO: remove (not used anywhere)
    def reset_callbacks!; end

    # Specify the source for the Guardfile template.
    # Each Guard plugin can redefine this method to add its own logic.
    #
    # @param plugin_location [String] the plugin location
    def template(plugin_location); end
  end
end

Guard::Plugin::TEMPLATE_FORMAT = T.let(T.unsafe(nil), String)

# This class contains useful methods to:
#
# * Fetch all the Guard plugins names;
# * Initialize a plugin, get its location;
# * Return its class name;
# * Add its template to the Guardfile.
class Guard::PluginUtil
  # Initializes a new `Guard::PluginUtil` object.
  #
  # @param name [String] the name of the Guard plugin
  # @return [PluginUtil] a new instance of PluginUtil
  def initialize(name); end

  # Adds a plugin's template to the Guardfile.
  def add_to_guardfile; end

  # Initializes a new `Guard::Plugin` with the given `options` hash. This
  # methods handles plugins that inherit from the deprecated `Guard::Guard`
  # class as well as plugins that inherit from `Guard::Plugin`.
  #
  # upgrade for Guard 2.0
  #
  # @return [Guard::Plugin] the initialized plugin
  # @return [Guard::Guard] the initialized plugin. This return type is
  #   deprecated and the plugin's maintainer should update it to be
  #   compatible with Guard 2.0. For more information on how to upgrade for
  #   Guard 2.0, please head over to:
  #   https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0
  # @see Guard::Plugin
  # @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
  def initialize_plugin(options); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Tries to load the Guard plugin main class. This transforms the supplied
  # plugin name into a class name:
  #
  # * `guardname` will become `Guard::Guardname`
  # * `dashed-guard-name` will become `Guard::DashedGuardName`
  # * `underscore_guard_name` will become `Guard::UnderscoreGuardName`
  #
  # When no class is found with the strict case sensitive rules, another
  # try is made to locate the class without matching case:
  #
  # * `rspec` will find a class `Guard::RSpec`
  #
  # not be printed
  #
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [Class, nil] the loaded class
  def plugin_class(options = T.unsafe(nil)); end

  # Locates a path to a Guard plugin gem.
  #
  # @return [String] the full path to the plugin gem
  def plugin_location; end

  private

  # Guesses the most probable name for the current plugin based on its name.
  #
  # @example Returns the most probable name for a plugin
  #   > Guard::PluginUtil.new('rspec').send(:_constant_name)
  #   => "Rspec"
  def _constant_name; end

  def _full_gem_path(name); end

  # Returns the constant for the current plugin.
  #
  # @example Returns the constant for a plugin
  #   > Guard::PluginUtil.new('rspec').send(:_plugin_constant)
  #   => Guard::RSpec
  def _plugin_constant; end

  class << self
    # @return [Boolean]
    def _gem_valid?(gem); end

    # Returns a list of Guard plugin Gem names installed locally.
    #
    # @return [Array<String>] a list of Guard plugin gem names
    def plugin_names; end
  end
end

Guard::PluginUtil::ERROR_NO_GUARD_OR_CLASS = T.let(T.unsafe(nil), String)
Guard::PluginUtil::INFO_ADDED_GUARD_TO_GUARDFILE = T.let(T.unsafe(nil), String)

# The runner is responsible for running all methods defined on each plugin.
class Guard::Runner
  # Run a Guard plugin task, but remove the Guard plugin when his work leads
  # to a system failure.
  #
  # When the Group has `:halt_on_fail` disabled, we've to catch
  # `:task_has_failed` here in order to avoid an uncaught throw error.
  #
  # @param plugin [Guard::Plugin] guard the Guard to execute
  # @param task [Symbol] the task to run
  # @param args [Array] the arguments for the task
  # @raise [:task_has_failed] when task has failed
  def _supervise(plugin, task, *args); end

  # Runs a Guard-task on all registered plugins.
  #
  # on
  #
  # @param task [Symbol] the task to run
  # @param scope_hash [Hash] either the Guard plugin or the group to run the task
  def run(task, scope_hash = T.unsafe(nil)); end

  # Runs the appropriate tasks on all registered plugins
  # based on the passed changes.
  #
  # @param modified [Array<String>] the modified paths.
  # @param added [Array<String>] the added paths.
  # @param removed [Array<String>] the removed paths.
  def run_on_changes(modified, added, removed); end

  private

  def _run_group_plugins(plugins); end

  class << self
    # Returns the symbol that has to be caught when running a supervised task.
    #
    # @note If a Guard group is being run and it has the `:halt_on_fail`
    #   option set, this method returns :no_catch as it will be caught at the
    #   group level.
    # @param guard [Guard::Plugin] the Guard plugin to execute
    # @return [Symbol] the symbol to catch
    def stopping_symbol_for(guard); end
  end
end

Guard::Runner::ADDITION_TASKS = T.let(T.unsafe(nil), Array)
Guard::Runner::MODIFICATION_TASKS = T.let(T.unsafe(nil), Array)
Guard::Runner::PLUGIN_FAILED = T.let(T.unsafe(nil), String)
Guard::Runner::REMOVAL_TASKS = T.let(T.unsafe(nil), Array)

class Guard::Terminal
  class << self
    def clear; end
  end
end

# The UI class helps to format messages for the user. Everything that is
# logged through this class is considered either as an error message or a
# diagnostic message and is written to standard error ($stderr).
#
# If your Guard plugin does some output that is piped into another process
# for further processing, please just write it to STDOUT with `puts`.
module Guard::UI
  include ::Guard::UI::Colors

  class << self
    # Show a scoped action message.
    #
    # @param action [String] the action to show
    # @param scope [Hash] hash with a guard or a group scope
    def action_with_scopes(action, scope); end

    # Clear the output if clearable.
    def clear(opts = T.unsafe(nil)); end

    # Allow the screen to be cleared again.
    def clearable; end

    # Show a debug message that is prefixed with DEBUG and a timestamp.
    #
    # @option options
    # @option options
    # @param message [String] the message to show
    # @param options [Hash] a customizable set of options
    def debug(message, options = T.unsafe(nil)); end

    # Show a red deprecation message that is prefixed with DEPRECATION.
    # It has a log level of `warn`.
    #
    # @option options
    # @option options
    # @param message [String] the message to show
    # @param options [Hash] a customizable set of options
    def deprecation(message, options = T.unsafe(nil)); end

    # Show a red error message that is prefixed with ERROR.
    #
    # @option options
    # @option options
    # @param message [String] the message to show
    # @param options [Hash] a customizable set of options
    def error(message, options = T.unsafe(nil)); end

    # Show an info message.
    #
    # @option options
    # @option options
    # @param message [String] the message to show
    # @param options [Hash] a customizable set of options
    def info(message, options = T.unsafe(nil)); end

    # Assigns a log level
    def level=(new_level); end

    # Get the Guard::UI logger instance
    def logger; end

    # Get the logger options
    #
    # @return [Hash] the logger options
    def options; end

    # Set the logger options
    #
    # TODO: deprecate?
    #
    # @option options
    # @option options
    # @option options
    # @param options [Hash] the logger options
    def options=(options); end

    # TODO: arguments: UI uses Guard::options anyway
    #
    # @private api
    def reset_and_clear; end

    # Reset a line.
    def reset_line; end

    # Since logger is global, for Aruba in-process to properly
    # separate output between calls, we need to reset
    #
    # We don't use logger=() since it's expected to be a Lumberjack instance
    def reset_logger; end

    # Show a yellow warning message that is prefixed with WARNING.
    #
    # @option options
    # @option options
    # @param message [String] the message to show
    # @param options [Hash] a customizable set of options
    def warning(message, options = T.unsafe(nil)); end

    private

    # Tries to extract the calling Guard plugin name
    # from the call stack.
    #
    # @param depth [Integer] the stack depth
    # @return [String] the Guard plugin name
    def _calling_plugin_name; end

    # Filters log messages depending on either the
    # `:only`` or `:except` option.
    #
    # @param plugin [String] the calling plugin name
    # @yield When the message should be logged
    # @yieldparam param [String] the calling plugin name
    def _filter(plugin); end

    # @private
    def _filtered_logger_message(message, method, color_name, options = T.unsafe(nil)); end

    # Colorizes a text message. See the constant in the UI class for possible
    # color_options parameters. You can pass optionally :bright, a foreground
    # color and a background color.
    #
    # @example
    #
    #   color('Hello World', :red, :bright)
    # @param text [String] the text to colorize
    # @param color_options [Array] the color options
    def color(text, *color_options); end

    # Checks if color output can be enabled.
    #
    # @return [Boolean] whether color is enabled or not
    def color_enabled?; end
  end
end

module Guard::UI::Colors; end

# Black background color
Guard::UI::Colors::ANSI_ESCAPE_BGBLACK = T.let(T.unsafe(nil), String)

# Blue background color
Guard::UI::Colors::ANSI_ESCAPE_BGBLUE = T.let(T.unsafe(nil), String)

# Cyan background color
Guard::UI::Colors::ANSI_ESCAPE_BGCYAN = T.let(T.unsafe(nil), String)

# Green background color
Guard::UI::Colors::ANSI_ESCAPE_BGGREEN = T.let(T.unsafe(nil), String)

# Magenta background color
Guard::UI::Colors::ANSI_ESCAPE_BGMAGENTA = T.let(T.unsafe(nil), String)

# Red background color
Guard::UI::Colors::ANSI_ESCAPE_BGRED = T.let(T.unsafe(nil), String)

# White background color
Guard::UI::Colors::ANSI_ESCAPE_BGWHITE = T.let(T.unsafe(nil), String)

# Yellow background color
Guard::UI::Colors::ANSI_ESCAPE_BGYELLOW = T.let(T.unsafe(nil), String)

# Black foreground color
Guard::UI::Colors::ANSI_ESCAPE_BLACK = T.let(T.unsafe(nil), String)

# Blue foreground color
Guard::UI::Colors::ANSI_ESCAPE_BLUE = T.let(T.unsafe(nil), String)

# Brighten the color
Guard::UI::Colors::ANSI_ESCAPE_BRIGHT = T.let(T.unsafe(nil), String)

# Cyan foreground color
Guard::UI::Colors::ANSI_ESCAPE_CYAN = T.let(T.unsafe(nil), String)

# Green foreground color
Guard::UI::Colors::ANSI_ESCAPE_GREEN = T.let(T.unsafe(nil), String)

# Magenta foreground color
Guard::UI::Colors::ANSI_ESCAPE_MAGENTA = T.let(T.unsafe(nil), String)

# Red foreground color
Guard::UI::Colors::ANSI_ESCAPE_RED = T.let(T.unsafe(nil), String)

# White foreground color
Guard::UI::Colors::ANSI_ESCAPE_WHITE = T.let(T.unsafe(nil), String)

# Yellow foreground color
Guard::UI::Colors::ANSI_ESCAPE_YELLOW = T.let(T.unsafe(nil), String)

class Guard::UI::Config < ::Guard::Options
  # @return [Config] a new instance of Config
  def initialize(options = T.unsafe(nil)); end

  def [](name); end
  def device; end
  def except; end

  # Returns the value of attribute logger_config.
  def logger_config; end

  def only; end
  def with_progname(name); end
end

Guard::UI::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)
Guard::UI::Config::DEPRECATED_OPTS = T.let(T.unsafe(nil), Array)
class Guard::UI::Logger; end

class Guard::UI::Logger::Config < ::Guard::Options
  # @return [Config] a new instance of Config
  def initialize(options = T.unsafe(nil)); end

  def level=(value); end
end

Guard::UI::Logger::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)
Guard::VERSION = T.let(T.unsafe(nil), String)

# The watcher defines a RegExp that will be matched against file system
# modifications.
# When a watcher matches a change, an optional action block is executed to
# enable processing the file system change result.
class Guard::Watcher
  extend ::Guard::Deprecated::Watcher::ClassMethods

  # Initializes a file watcher.
  #
  # @param pattern [String, Regexp] the pattern to be watched by the Guard
  #   plugin
  # @param action [Block] the action to execute before passing the result to
  #   the Guard plugin
  # @return [Watcher] a new instance of Watcher
  def initialize(pattern, action = T.unsafe(nil)); end

  # Compare with other watcher
  #
  # @param other [Guard::Watcher] other watcher for comparing
  # @return [true, false] equal or not
  def ==(other); end

  # Returns the value of attribute action.
  def action; end

  # Sets the attribute action
  #
  # @param value the value to set the attribute action to.
  def action=(_arg0); end

  # Executes a watcher action.
  #
  # @param matches [String, MatchData] the matched path or the match from the
  #   Regex
  # @return [String] the final paths
  def call_action(matches); end

  def match(string_or_pathname); end

  # Returns the value of attribute pattern.
  def pattern; end

  # Sets the attribute pattern
  #
  # @param value the value to set the attribute pattern to.
  def pattern=(_arg0); end

  class << self
    # Finds the files that matches a Guard plugin.
    #
    # @param guard [Guard::Plugin] the Guard plugin which watchers are used
    # @param files [Array<String>] the changed files
    # @return [Array<Object>] the matched watcher response
    def match_files(guard, files); end
  end
end

class Guard::Watcher::Pattern
  class << self
    def create(pattern); end
  end
end

# TODO: remove before Guard 3.x
class Guard::Watcher::Pattern::DeprecatedRegexp
  # @return [DeprecatedRegexp] a new instance of DeprecatedRegexp
  def initialize(pattern); end

  # @return [Boolean]
  def deprecated?; end

  class << self
    def convert(pattern); end
    def show_deprecation(pattern); end
  end
end

class Guard::Watcher::Pattern::MatchResult
  # @return [MatchResult] a new instance of MatchResult
  def initialize(match_result, original_value); end

  def [](index); end
end

class Guard::Watcher::Pattern::Matcher
  # @return [Matcher] a new instance of Matcher
  def initialize(obj); end

  # Compare with other matcher
  #
  # @param other [Guard::Watcher::Pattern::Matcher] other matcher for comparing
  # @return [true, false] equal or not
  def ==(other); end

  def match(string_or_pathname); end

  # Returns the value of attribute matcher.
  def matcher; end

  private

  def normalized(string_or_pathname); end
end

class Guard::Watcher::Pattern::PathnamePath < ::Guard::Watcher::Pattern::SimplePath
  protected

  def normalize(string_or_pathname); end
end

class Guard::Watcher::Pattern::SimplePath
  # @return [SimplePath] a new instance of SimplePath
  def initialize(string_or_pathname); end

  def match(string_or_pathname); end

  protected

  def normalize(string_or_pathname); end
end
