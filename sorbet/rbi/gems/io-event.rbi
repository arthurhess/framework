# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/io-event/all/io-event.rbi
#
# io-event-1.0.9

module IO::Event
end
class IO::Event::Interrupt
  def close; end
  def initialize(selector); end
  def self.attach(selector); end
  def signal; end
end
module IO::Event::Selector
  def self.default(env = nil); end
  def self.new(loop, env = nil); end
end
class IO::Event::Selector::Select
  def blocking(&block); end
  def close; end
  def initialize(loop); end
  def io_read(fiber, io, buffer, length); end
  def io_wait(fiber, io, events); end
  def io_write(fiber, io, buffer, length); end
  def loop; end
  def pop_ready; end
  def process_wait(fiber, pid, flags); end
  def push(fiber); end
  def raise(fiber, *arguments); end
  def ready?; end
  def resume(fiber, *arguments); end
  def select(duration = nil); end
  def transfer; end
  def wakeup; end
  def yield; end
end
class IO::Event::Selector::Select::Optional < Struct
  def alive?; end
  def fiber; end
  def fiber=(_); end
  def nullify; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def transfer(*arguments); end
end
class IO::Event::Selector::Select::Waiter < Struct
  def alive?; end
  def each(&block); end
  def events; end
  def events=(_); end
  def fiber; end
  def fiber=(_); end
  def invalidate; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def tail; end
  def tail=(_); end
  def transfer(events); end
end
module IO::Event::Debug
end
class IO::Event::Debug::Selector
  def close; end
  def initialize(selector); end
  def io_read(fiber, io, buffer, length); end
  def io_wait(fiber, io, events); end
  def io_write(fiber, io, buffer, length); end
  def process_wait(*arguments); end
  def push(fiber); end
  def raise(fiber, *arguments); end
  def ready?; end
  def resume(*arguments); end
  def select(duration = nil); end
  def transfer; end
  def wakeup; end
  def yield; end
end
class IO::Event::Selector::KQueue
  def close; end
  def initialize(arg0); end
  def io_read(arg0, arg1, arg2, arg3); end
  def io_wait(arg0, arg1, arg2); end
  def io_write(arg0, arg1, arg2, arg3); end
  def loop; end
  def process_wait(arg0, arg1, arg2); end
  def push(arg0); end
  def raise(*arg0); end
  def ready?; end
  def resume(*arg0); end
  def select(arg0); end
  def transfer; end
  def wakeup; end
  def yield; end
end
