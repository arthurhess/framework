# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `http_router` gem.
# Please instead update this file by running `bin/tapioca gem http_router`.

# :nodoc
class HttpRouter
  # Creates a new HttpRouter.
  # Can be called with either <tt>HttpRouter.new(proc{|env| ... }, { .. options .. })</tt> or with the first argument omitted.
  # If there is a proc first, then it's used as the default app in the case of a non-match.
  # Supported options are
  # * :default_app -- Default application used if there is a non-match on #call. Defaults to 404 generator.
  # * :ignore_trailing_slash -- Ignore a trailing / when attempting to match. Defaults to +true+.
  # * :redirect_trailing_slash -- On trailing /, redirect to the same path without the /. Defaults to +false+.
  #
  # @return [HttpRouter] a new instance of HttpRouter
  def initialize(*args, &blk); end

  # Adds a path to be recognized.
  #
  # To assign a part of the path to a specific variable, use :variable_name within the route.
  # For example, <tt>add('/path/:id')</tt> would match <tt>/path/test</tt>, with the variable <tt>:id</tt> having the value <tt>"test"</tt>.
  #
  # You can receive mulitple parts into a single variable by using the glob syntax.
  # For example, <tt>add('/path/*id')</tt> would match <tt>/path/123/456/789</tt>, with the variable <tt>:id</tt> having the value <tt>["123", "456", "789"]</tt>.
  #
  # As well, paths can end with two optional parts, <tt>*</tt> and <tt>/?</tt>. If it ends with a <tt>*</tt>, it will match partially, returning the part of the path unmatched in the PATH_INFO value of the env. The part matched to will be returned in the SCRIPT_NAME. If it ends with <tt>/?</tt>, then a trailing / on the path will be optionally matched for that specific route. As trailing /'s are ignored by default, you probably don't actually want to use this option that frequently.
  #
  # Routes can also contain optional parts. There are surrounded with <tt>( )</tt>'s. If you need to match on a bracket in the route itself, you can escape the parentheses with a backslash.
  #
  # As well, options can be passed in that modify the route in further ways. See HttpRouter::Route#with_options for details. Typically, you want to add further options to the route by calling additional methods on it. See HttpRouter::Route for further details.
  #
  # Returns the route object.
  def add(*args, &app); end

  def add_route(route); end

  # Rack compatible #call. If matching route is found, and +dest+ value responds to #call, processing will pass to the matched route. Otherwise,
  # the default application will be called. The router will be available in the env under the key <tt>router</tt>. And parameters matched will
  # be available under the key <tt>router.params</tt>.
  def call(env, &callback); end

  # Creates a deep-copy of the router.
  def clone(klass = T.unsafe(nil)); end

  # Rack compatible #call. If matching route is found, and +dest+ value responds to #call, processing will pass to the matched route. Otherwise,
  # the default application will be called. The router will be available in the env under the key <tt>router</tt>. And parameters matched will
  # be available under the key <tt>router.params</tt>.
  def compiling_call(env, &callback); end

  def compiling_path(route, *args); end

  # Generate a URL for a specified route. This will accept a list of variable values plus any other variable names named as a hash.
  # This first value must be either the Route object or the name of the route.
  #
  # Example:
  #   router = HttpRouter.new
  #   router.add('/:foo.:format', :name => :test).to{|env| [200, {}, []]}
  #   router.path(:test, 123, 'html')
  #   # ==> "/123.html"
  #   router.path(:test, 123, :format => 'html')
  #   # ==> "/123.html"
  #   router.path(:test, :foo => 123, :format => 'html')
  #   # ==> "/123.html"
  #   router.path(:test, :foo => 123, :format => 'html', :fun => 'inthesun')
  #   # ==> "/123.html?fun=inthesun"
  def compiling_url(route, *args); end

  def compiling_url_ns(route, *args); end

  # Assigns the default application.
  def default(app); end

  # Returns the value of attribute default_app.
  def default_app; end

  # Sets the attribute default_app
  #
  # @param value the value to set the attribute default_app to.
  def default_app=(_arg0); end

  # Returns the value of attribute default_host.
  def default_host; end

  # Sets the attribute default_host
  #
  # @param value the value to set the attribute default_host to.
  def default_host=(_arg0); end

  # Returns the value of attribute default_port.
  def default_port; end

  # Sets the attribute default_port
  #
  # @param value the value to set the attribute default_port to.
  def default_port=(_arg0); end

  # Returns the value of attribute default_scheme.
  def default_scheme; end

  # Sets the attribute default_scheme
  #
  # @param value the value to set the attribute default_scheme to.
  def default_scheme=(_arg0); end

  def delete(path, opts = T.unsafe(nil), &app); end

  # Extends the route class with custom features.
  #
  # Example:
  #   router = HttpRouter.new { extend_route { attr_accessor :controller } }
  #   router.add('/foo', :controller => :foo).to{|env| [200, {}, ['foo!']]}
  #   matches, other_methods = router.recognize(Rack::MockRequest.env_for('/foo'))
  #   matches.first.route.controller
  #   # ==> :foo
  def extend_route(&blk); end

  # Adds a path that only responds to the request method +GET+.
  #
  # Returns the route object.
  def get(path, opts = T.unsafe(nil), &app); end

  def head(path, opts = T.unsafe(nil), &app); end

  # Ignore trailing slash feature enabled? See #initialize for details.
  #
  # @return [Boolean]
  def ignore_trailing_slash?; end

  def inspect; end
  def link(path, opts = T.unsafe(nil), &app); end

  # Returns the value of attribute named_routes.
  def named_routes; end

  def no_response(request, env); end

  # Returns the value of attribute nodes.
  def nodes; end

  def options(path, opts = T.unsafe(nil), &app); end

  # This method defines what sort of responses are considered "passes", and thus, route processing will continue. Override
  # it to implement custom passing.
  def pass_on_response(response); end

  def patch(path, opts = T.unsafe(nil), &app); end
  def path(route, *args); end
  def post(path, opts = T.unsafe(nil), &app); end

  # This method is invoked when a Path object gets called with an env. Override it to implement custom path processing.
  def process_destination_path(path, env); end

  def put(path, opts = T.unsafe(nil), &app); end
  def raw_call(env, &blk); end
  def raw_path(route, *args); end
  def raw_url(route, *args); end
  def raw_url_ns(route, *args); end

  # Performs recoginition without actually calling the application and returns an array of all
  # matching routes or nil if no match was found.
  def recognize(env, &callback); end

  # Redirect trailing slash feature enabled? See #initialize for details.
  #
  # @return [Boolean]
  def redirect_trailing_slash?; end

  # Resets the router to a clean state.
  def reset!; end

  def rewrite_partial_path_info(env, request); end
  def rewrite_path_info(env, request); end

  # Returns the value of attribute root.
  def root; end

  def route_class; end

  # Sets the attribute route_class
  #
  # @param value the value to set the attribute route_class to.
  def route_class=(_arg0); end

  # Returns the value of attribute routes.
  def routes; end

  def to_s; end
  def trace(path, opts = T.unsafe(nil), &app); end
  def uncompile; end
  def unlink(path, opts = T.unsafe(nil), &app); end

  # Generate a URL for a specified route. This will accept a list of variable values plus any other variable names named as a hash.
  # This first value must be either the Route object or the name of the route.
  #
  # Example:
  #   router = HttpRouter.new
  #   router.add('/:foo.:format', :name => :test).to{|env| [200, {}, []]}
  #   router.path(:test, 123, 'html')
  #   # ==> "/123.html"
  #   router.path(:test, 123, :format => 'html')
  #   # ==> "/123.html"
  #   router.path(:test, :foo => 123, :format => 'html')
  #   # ==> "/123.html"
  #   router.path(:test, :foo => 123, :format => 'html', :fun => 'inthesun')
  #   # ==> "/123.html?fun=inthesun"
  def url(route, *args); end

  # Returns the value of attribute url_mount.
  def url_mount; end

  # Sets the attribute url_mount
  #
  # @param value the value to set the attribute url_mount to.
  def url_mount=(_arg0); end

  def url_ns(route, *args); end

  private

  def add_with_request_method(path, method, opts = T.unsafe(nil), &app); end
  def compile; end
end

# Raised when there are duplicate param names specified in a Path
class HttpRouter::AmbiguousVariableException < ::RuntimeError; end

# @api private
module HttpRouter::GenerationHelper
  # @api private
  def max_param_count; end

  # @api private
  def param_names; end

  # @api private
  def path(*args); end

  # @api private
  def url(*args); end

  # @api private
  def url_ns(*args); end
end

# @api private
class HttpRouter::Generator
  # @api private
  # @return [Generator] a new instance of Generator
  def initialize(route, paths); end

  # @api private
  def each_path; end

  # @api private
  def max_param_count; end

  # @api private
  def param_names; end

  # @api private
  def path(*args); end

  # @api private
  def url(*args); end

  # @api private
  def url_ns(*args); end

  private

  # @api private
  def append_querystring(uri, params); end

  # @api private
  def append_querystring_value(uri, key, value); end

  # @api private
  def matching_path(params, other_hash = T.unsafe(nil)); end

  # @api private
  def path_args_processing(args); end

  # @api private
  def path_with_params(*a); end

  # @api private
  def scheme_port; end
end

# @api private
class HttpRouter::Generator::PathGenerator
  # @api private
  # @return [PathGenerator] a new instance of PathGenerator
  def initialize(route, path, validation_regex = T.unsafe(nil)); end

  # @api private
  def param_names; end

  # @api private
  def param_names=(_arg0); end

  # @api private
  def path; end
end

# @api private
HttpRouter::Generator::SCHEME_PORTS = T.let(T.unsafe(nil), Hash)

# Raised an invalid request value is used
class HttpRouter::InvalidRequestValueError < ::RuntimeError; end

# Raised when a url is not able to be generated for the given parameters
class HttpRouter::InvalidRouteException < ::RuntimeError; end

# Raised when there are left over options
class HttpRouter::LeftOverOptions < ::RuntimeError; end

# Raised when a Route is not able to be generated due to a missing parameter.
class HttpRouter::MissingParameterException < ::RuntimeError; end

# @api private
class HttpRouter::Node
  # @api private
  # @return [Node] a new instance of Node
  def initialize(router, parent, matchers = T.unsafe(nil)); end

  # @api private
  def add_destination(route, path, param_names = T.unsafe(nil)); end

  # @api private
  def add_free_match(regexp); end

  # @api private
  def add_glob; end

  # @api private
  def add_glob_regexp(matcher); end

  # @api private
  def add_host(hosts); end

  # @api private
  def add_lookup(part); end

  # @api private
  def add_match(regexp, matching_indicies = T.unsafe(nil), splitting_indicies = T.unsafe(nil)); end

  # @api private
  def add_request_method(rm); end

  # @api private
  def add_scheme(scheme); end

  # @api private
  def add_spanning_match(regexp, matching_indicies = T.unsafe(nil), splitting_indicies = T.unsafe(nil)); end

  # @api private
  def add_user_agent(uas); end

  # @api private
  def add_variable; end

  # @api private
  def depth; end

  # @api private
  def inspect; end

  # @api private
  def inspect_label; end

  # @api private
  def inspect_matchers_body; end

  # @api private
  def router; end

  # @api private
  # @return [Boolean]
  def usable?(other); end

  private

  # @api private
  def add(matcher); end

  # @api private
  def inject_root_ivar(obj); end

  # @api private
  def inject_root_methods(code = T.unsafe(nil), &blk); end

  # @api private
  def root; end

  # @api private
  def to_code; end

  # @api private
  # @return [Boolean]
  def use_named_captures?; end
end

# @api private
class HttpRouter::Node::AbstractRequestNode < ::HttpRouter::Node
  # @api private
  # @return [AbstractRequestNode] a new instance of AbstractRequestNode
  def initialize(route, parent, tests, request_method); end

  # @api private
  def inspect_label; end

  # @api private
  def request_method; end

  # @api private
  def tests; end

  # @api private
  def to_code; end

  # @api private
  # @return [Boolean]
  def usable?(other); end
end

# @api private
class HttpRouter::Node::FreeRegex < ::HttpRouter::Node
  # @api private
  # @return [FreeRegex] a new instance of FreeRegex
  def initialize(router, parent, matcher); end

  # @api private
  def matcher; end

  # @api private
  def to_code; end

  # @api private
  # @return [Boolean]
  def usable?(other); end
end

# @api private
class HttpRouter::Node::Glob < ::HttpRouter::Node
  # @api private
  def to_code; end

  # @api private
  # @return [Boolean]
  def usable?(other); end

  private

  # @api private
  def node_to_code; end
end

# @api private
class HttpRouter::Node::GlobRegex < ::HttpRouter::Node::Glob
  # @api private
  # @return [GlobRegex] a new instance of GlobRegex
  def initialize(router, parent, matcher); end

  # @api private
  def matcher; end

  # @api private
  def to_code; end

  # @api private
  # @return [Boolean]
  def usable?(other); end
end

# @api private
class HttpRouter::Node::Host < ::HttpRouter::Node::AbstractRequestNode
  # @api private
  # @return [Host] a new instance of Host
  def initialize(router, parent, hosts); end
end

# @api private
class HttpRouter::Node::Lookup < ::HttpRouter::Node
  # @api private
  # @return [Lookup] a new instance of Lookup
  def initialize(router, parent); end

  # @api private
  def add(part); end

  # @api private
  def inspect_label; end

  # @api private
  def inspect_matchers_body; end

  # @api private
  def to_code; end

  # @api private
  # @return [Boolean]
  def usable?(other); end
end

# @api private
class HttpRouter::Node::Path < ::HttpRouter::Node
  # @api private
  # @raise [AmbiguousVariableException]
  # @return [Path] a new instance of Path
  def initialize(router, parent, route, path, param_names = T.unsafe(nil)); end

  # @api private
  def duplicates; end

  # @api private
  def dynamic; end

  # @api private
  def dynamic?; end

  # @api private
  def hashify_params(params); end

  # @api private
  def inspect_label; end

  # @api private
  def param_names; end

  # @api private
  def path; end

  # @api private
  def route; end

  # @api private
  def to_code; end

  # @api private
  # @return [Boolean]
  def usable?(other); end
end

# @api private
class HttpRouter::Node::Regex < ::HttpRouter::Node
  # @api private
  # @return [Regex] a new instance of Regex
  def initialize(router, parent, matcher, capturing_indicies, splitting_indicies = T.unsafe(nil)); end

  # @api private
  def capturing_indicies; end

  # @api private
  def matcher; end

  # @api private
  def ordered_indicies; end

  # @api private
  def param_capturing_code; end

  # @api private
  def splitting_indicies; end

  # @api private
  def to_code; end

  # @api private
  # @return [Boolean]
  def usable?(other); end

  private

  # @api private
  def node_to_code; end
end

# @api private
class HttpRouter::Node::RequestMethod < ::HttpRouter::Node::AbstractRequestNode
  # @api private
  # @return [RequestMethod] a new instance of RequestMethod
  def initialize(router, parent, request_methods); end

  # @api private
  def to_code; end
end

# @api private
class HttpRouter::Node::Root < ::HttpRouter::Node
  # @api private
  # @return [Root] a new instance of Root
  def initialize(router); end

  # @api private
  def compile(routes); end

  # @api private
  def compiled; end

  # @api private
  def compiled?; end

  # @api private
  def depth; end

  # @api private
  def inject_root_ivar(obj); end

  # @api private
  def inspect_label; end

  # @api private
  def methods_module; end

  # @api private
  def next_counter; end

  # @api private
  def uncompile; end

  private

  # @api private
  def add_complex_part(route, node, parts, path_generator); end

  # @api private
  def add_non_path_to_tree(route, node, path, param_names); end

  # @api private
  def add_normal_part(route, node, part, path_generator); end

  # @api private
  def add_route(route); end
end

# @api private
class HttpRouter::Node::Scheme < ::HttpRouter::Node::AbstractRequestNode
  # @api private
  # @return [Scheme] a new instance of Scheme
  def initialize(router, parent, schemes); end
end

# @api private
class HttpRouter::Node::SpanningRegex < ::HttpRouter::Node::Regex
  # @api private
  def to_code; end
end

# @api private
class HttpRouter::Node::UserAgent < ::HttpRouter::Node::AbstractRequestNode
  # @api private
  # @return [UserAgent] a new instance of UserAgent
  def initialize(router, parent, user_agents); end
end

# @api private
class HttpRouter::Node::Variable < ::HttpRouter::Node
  # @api private
  def to_code; end

  # @api private
  # @return [Boolean]
  def usable?(other); end
end

class HttpRouter::RecognizeResponse < ::Struct
  # Returns the value of attribute acceptable_methods
  #
  # @return [Object] the current value of acceptable_methods
  def acceptable_methods; end

  # Sets the attribute acceptable_methods
  #
  # @param value [Object] the value to set the attribute acceptable_methods to.
  # @return [Object] the newly set value
  def acceptable_methods=(_); end

  # Returns the value of attribute matches
  #
  # @return [Object] the current value of matches
  def matches; end

  # Sets the attribute matches
  #
  # @param value [Object] the value to set the attribute matches to.
  # @return [Object] the newly set value
  def matches=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# @api private
module HttpRouter::RegexRouteGeneration
  # @api private
  def url_with_params(*a); end
end

# @api private
class HttpRouter::Request
  # @api private
  # @return [Request] a new instance of Request
  def initialize(path, rack_request); end

  # @api private
  def acceptable_methods; end

  # @api private
  def called; end

  # @api private
  def called=(_arg0); end

  # @api private
  def called?; end

  # @api private
  def continue; end

  # @api private
  def continue=(_arg0); end

  # @api private
  def extra_env; end

  # @api private
  def extra_env=(_arg0); end

  # @api private
  def joined_path; end

  # @api private
  def params; end

  # @api private
  def params=(_arg0); end

  # @api private
  def passed_with; end

  # @api private
  def passed_with=(_arg0); end

  # @api private
  def path; end

  # @api private
  def path=(_arg0); end

  # @api private
  # @return [Boolean]
  def path_finished?; end

  # @api private
  def rack; end

  # @api private
  def rack_request; end

  # @api private
  def rack_request=(_arg0); end

  # @api private
  def to_s; end
end

# @api private
class HttpRouter::Response < ::Struct
  # @api private
  # @return [Response] a new instance of Response
  def initialize(request, path); end

  # @api private
  def param_values; end

  # @api private
  def params; end

  # @api private
  def route; end
end

# @api private
class HttpRouter::Route
  # @api private
  def create_clone(new_router); end

  # @api private
  def default_values; end

  # @api private
  def dest; end

  # @api private
  def dest=(_arg0); end

  # @api private
  def generator; end

  # @api private
  def generator=(_arg0); end

  # @api private
  def host; end

  # @api private
  def host=(_arg0); end

  # @api private
  def ignore_trailing_slash; end

  # @api private
  def ignore_trailing_slash=(_arg0); end

  # @api private
  def match_partially; end

  # @api private
  def match_partially=(_arg0); end

  # @api private
  def matches_with(var_name); end

  # @api private
  def name; end

  # @api private
  def name=(name); end

  # @api private
  def original_path; end

  # @api private
  def original_path=(_arg0); end

  # @api private
  def other_hosts; end

  # @api private
  def path_for_generation; end

  # @api private
  def path_for_generation=(_arg0); end

  # @api private
  def path_validation_regex; end

  # @api private
  def path_validation_regex=(_arg0); end

  # @api private
  def paths; end

  # @api private
  def request_methods; end

  # @api private
  def router; end

  # @api private
  def router=(_arg0); end

  # @api private
  def scheme; end

  # @api private
  def scheme=(_arg0); end

  # @api private
  def to_s; end

  # @api private
  def user_agent; end

  # @api private
  def user_agent=(_arg0); end
end

# The list of HTTP request methods supported by HttpRouter.
#
# @api private
HttpRouter::Route::VALID_HTTP_VERBS = T.let(T.unsafe(nil), Array)

# @api private
HttpRouter::Route::VALID_HTTP_VERBS_WITHOUT_GET = T.let(T.unsafe(nil), Array)

# @api private
module HttpRouter::RouteHelper
  # @api private
  def add_default_values(hash); end

  # @api private
  def add_match_with(matchers); end

  # @api private
  def add_other_host(hosts); end

  # @api private
  def add_path(path); end

  # @api private
  def add_request_method(methods); end

  def delete; end

  # @api private
  def get; end

  def head; end
  def link; end

  # @api private
  def name(name = T.unsafe(nil)); end

  def options; end
  def patch; end

  # @api private
  def path; end

  # @api private
  def path=(path); end

  def post; end

  # @api private
  def process_opts(opts); end

  def put; end

  # @api private
  # @raise [ArgumentError]
  def redirect(path, status = T.unsafe(nil)); end

  # Sets the destination of this route to serve static files from either a directory or a single file.
  #
  # @api private
  def static(root); end

  # @api private
  def to(dest = T.unsafe(nil), &dest_block); end

  def trace; end
  def unlink; end
end

# Raised when there are extra parameters passed in to #url
class HttpRouter::TooManyParametersException < ::RuntimeError; end

# @api private
module HttpRouter::Util; end
