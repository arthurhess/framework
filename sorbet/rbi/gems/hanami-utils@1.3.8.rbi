# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hanami-utils` gem.
# Please instead update this file by running `bin/tapioca gem hanami-utils`.

class Boolean; end

# Hanami - The web, with simplicity
#
# @since 0.1.0
module Hanami; end

# Ruby core extentions and Hanami utilities
#
# @since 0.1.0
module Hanami::Utils
  class << self
    # Recursively scans through the given directory and yields the given block
    # for each Ruby source file.
    #
    # If the directory is relative, it implies it's the path from current directory.
    # If the directory is absolute, it uses as it is.
    #
    # It respects file separator of the current operating system.
    # A pattern like <tt>"path/to/files"</tt> will work both on *NIX and Windows machines.
    #
    # @api private
    # @param directory [String, Pathname] the directory
    # @param blk [Proc] the block to yield
    # @since 1.0.0
    def for_each_file_in(directory, &blk); end

    # Checks if the current VM is JRuby
    #
    # @api private
    # @return [TrueClass, FalseClass] info whether the VM is JRuby or not
    # @since 0.3.1
    def jruby?; end

    # Recursively reloads Ruby files under the given directory.
    #
    # If the directory is relative, it implies it's the path from current directory.
    # If the directory is absolute, it uses as it is.
    #
    # It respects file separator of the current operating system.
    # A pattern like <tt>"path/to/files"</tt> will work both on *NIX and Windows machines.
    #
    # @api private
    # @param directory [String, Pathname] the directory
    # @since 1.0.0
    def reload!(directory); end

    # Recursively requires Ruby files under the given directory.
    #
    # If the directory is relative, it implies it's the path from current directory.
    # If the directory is absolute, it uses as it is.
    #
    # It respects file separator of the current operating system.
    # A pattern like <tt>"path/to/files"</tt> will work both on *NIX and Windows machines.
    #
    # @param directory [String, Pathname] the directory
    # @since 0.9.0
    def require!(directory); end

    # Checks if the current VM is Rubinius
    #
    # @api private
    # @return [TrueClass, FalseClass] info whether the VM is Rubinius or not
    # @since 0.3.1
    def rubinius?; end
  end
end

# Checks for blank
#
# @api private
# @since 0.8.0
class Hanami::Utils::Blank
  class << self
    # Checks if object is blank
    #
    # @api private
    # @example Basic Usage
    #   require 'hanami/utils/blank'
    #
    #   Hanami::Utils::Blank.blank?(Hanami::Utils::String.new('')) # => true
    #   Hanami::Utils::Blank.blank?('  ')                          # => true
    #   Hanami::Utils::Blank.blank?(nil)                           # => true
    #   Hanami::Utils::Blank.blank?(Hanami::Utils::Hash.new({}))   # => true
    #   Hanami::Utils::Blank.blank?(true)                          # => false
    #   Hanami::Utils::Blank.blank?(1)                             # => false
    # @param object the argument
    # @return [TrueClass, FalseClass] info, whether object is blank
    # @since 0.8.0
    def blank?(object); end

    # Checks if object is filled
    #
    # @api private
    # @example Basic Usage
    #   require 'hanami/utils/blank'
    #
    #   Hanami::Utils::Blank.filled?(true)                          # => true
    #   Hanami::Utils::Blank.filled?(1)                             # => true
    #   Hanami::Utils::Blank.filled?(Hanami::Utils::String.new('')) # => false
    #   Hanami::Utils::Blank.filled?('  ')                          # => false
    #   Hanami::Utils::Blank.filled?(nil)                           # => false
    #   Hanami::Utils::Blank.filled?(Hanami::Utils::Hash.new({}))   # => false
    # @param object the argument
    # @return [TrueClass, FalseClass] whether the object is filled
    # @since 1.0.0
    def filled?(object); end
  end
end

# Matcher for blank strings
#
# @api private
# @since 0.8.0
Hanami::Utils::Blank::STRING_MATCHER = T.let(T.unsafe(nil), Regexp)

# Class utilities
#
# @since 0.1.0
class Hanami::Utils::Class
  class << self
    # Loads a class for the given name, only if it's defined.
    #
    # @example
    #   require 'hanami/utils/class'
    #
    #   module App
    #   module Service
    #   class Endpoint
    #   end
    #   end
    #
    #   class ServiceEndpoint
    #   end
    #   end
    #
    #   # basic usage
    #   Hanami::Utils::Class.load('App::Service') # => App::Service
    #   Hanami::Utils::Class.load(App::Service)   # => App::Service
    #
    #   # with explicit namespace
    #   Hanami::Utils::Class.load('Service', App) # => App::Service
    # @param name [String, Class] the specific class name
    # @param namespace [Class, Module] the Ruby namespace where we want to perform the lookup.
    # @return [Class, Module, NilClass] the Ruby constant, or nil if not found.
    # @since 0.8.0
    def load(name, namespace = T.unsafe(nil)); end

    # Loads a class for the given name.
    #
    # @example
    #   require 'hanami/utils/class'
    #
    #   module App
    #   module Service
    #   class Endpoint
    #   end
    #   end
    #
    #   class ServiceEndpoint
    #   end
    #   end
    #
    #   # basic usage
    #   Hanami::Utils::Class.load!('App::Service') # => App::Service
    #   Hanami::Utils::Class.load!(App::Service)   # => App::Service
    #
    #   # with explicit namespace
    #   Hanami::Utils::Class.load!('Service', App) # => App::Service
    #
    #   # with missing constant
    #   Hanami::Utils::Class.load!('Unknown') # => raises NameError
    # @param name [String, Class] the specific class name
    # @param namespace [Class, Module] the Ruby namespace where we want to perform the lookup.
    # @raise [NameError] if no constant can be found.
    # @return [Class, Module] the found Ruby constant.
    # @since 0.1.0
    def load!(name, namespace = T.unsafe(nil)); end

    # Loads a class from the given pattern name and namespace
    #
    # @example
    #   require 'hanami/utils/class'
    #
    #   module App
    #   module Service
    #   class Endpoint
    #   end
    #   end
    #
    #   class ServiceEndpoint
    #   end
    #   end
    #
    #   # basic usage
    #   Hanami::Utils::Class.load_from_pattern!('App::Service') # => App::Service
    #
    #   # with explicit namespace
    #   Hanami::Utils::Class.load_from_pattern!('Service', App) # => App::Service
    #
    #   # with pattern
    #   Hanami::Utils::Class.load_from_pattern!('App::Service(::Endpoint|Endpoint)') # => App::Service::Endpoint
    #   Hanami::Utils::Class.load_from_pattern!('App::Service(Endpoint|::Endpoint)') # => App::ServiceEndpoint
    #
    #   # with missing constant
    #   Hanami::Utils::Class.load_from_pattern!('Unknown') # => raises NameError
    # @param pattern [String] the class name pattern
    # @param namespace [Class, Module] the Ruby namespace where we want to perform the lookup.
    # @raise [NameError] if no constant can be found.
    # @return [Class, Module] the found Ruby constant.
    # @see Hanami::Utils::String#tokenize
    # @since 0.3.1
    def load_from_pattern!(pattern, namespace = T.unsafe(nil)); end

    # @since 0.1.0
    def tokenize(pattern); end
  end
end

# Regexp for .tokenize
#
# @api private
# @since 1.3.0
Hanami::Utils::Class::TOKENIZE_REGEXP = T.let(T.unsafe(nil), Regexp)

# Separator for .tokenize
#
# @api private
# @since 1.3.0
Hanami::Utils::Class::TOKENIZE_SEPARATOR = T.let(T.unsafe(nil), String)

# Inheritable class level variable accessors.
#
# @see Hanami::Utils::ClassAttribute::ClassMethods
# @since 0.1.0
module Hanami::Utils::ClassAttribute
  mixes_in_class_methods ::Hanami::Utils::ClassAttribute::ClassMethods

  class << self
    # @api private
    # @since 0.1.0
    def included(base); end
  end
end

# @api private
# @since 0.1.0
module Hanami::Utils::ClassAttribute::ClassMethods
  # Defines a class level accessor for the given attribute(s).
  #
  # A value set for a superclass is automatically available by their
  # subclasses, unless a different value is explicitely set within the
  # inheritance chain.
  #
  # @api private
  # @example
  #   require 'hanami/utils/class_attribute'
  #
  #   class Vehicle
  #   include Hanami::Utils::ClassAttribute
  #   class_attribute :engines, :wheels
  #
  #   self.engines = 0
  #   self.wheels  = 0
  #   end
  #
  #   class Car < Vehicle
  #   self.engines = 1
  #   self.wheels  = 4
  #   end
  #
  #   class Airplane < Vehicle
  #   self.engines = 4
  #   self.wheels  = 16
  #   end
  #
  #   class SmallAirplane < Airplane
  #   self.engines = 2
  #   self.wheels  = 8
  #   end
  #
  #   Vehicle.engines # => 0
  #   Vehicle.wheels  # => 0
  #
  #   Car.engines # => 1
  #   Car.wheels  # => 4
  #
  #   Airplane.engines # => 4
  #   Airplane.wheels  # => 16
  #
  #   SmallAirplane.engines # => 2
  #   SmallAirplane.wheels  # => 8
  # @param attributes [Array<Symbol>] a single or multiple attribute name(s)
  # @return [void]
  # @since 0.1.0
  def class_attribute(*attributes); end

  protected

  # @api private
  # @see Class#inherited
  # @since 0.1.0
  def inherited(subclass); end

  private

  # Class accessor for class attributes.
  #
  # @api private
  # @since 0.1.0
  def class_attributes; end
end

# Prints a deprecation warning when initialized
#
# @since 0.3.1
class Hanami::Utils::Deprecation
  # Initialize a deprecation message and prints it to standard error.
  #
  # @example Direct usage
  #   require 'hanami/utils/deprecation'
  #
  #   class Engine
  #   def old_method
  #   Hanami::Utils::Deprecation.new('old_method is deprecated, please use new_method')
  #   new_method
  #   end
  #
  #   def new_method
  #   puts 'started'
  #   end
  #   end
  #
  #   Engine.new.old_method
  #   # => old_method is deprecated, please use new_method - called from: test.rb:14:in `<main>'.
  #   # => started
  # @example Indirect usage
  #   require 'hanami/utils/deprecation'
  #
  #   class Engine
  #   def old_method
  #   Hanami::Utils::Deprecation.new('old_method is deprecated, please use new_method')
  #   new_method
  #   end
  #
  #   def new_method
  #   puts 'started'
  #   end
  #   end
  #
  #   class Car
  #   def initialize
  #   @engine = Engine.new
  #   end
  #
  #   def start
  #   @engine.old_method
  #   end
  #   end
  #
  #   Car.new.start
  #   # => old_method is deprecated, please use new_method - called from: test.rb:20:in `start'.
  #   # => started
  # @param message [#to_s] a deprecation message
  # @return [Deprecation] a new instance of Deprecation
  # @since 0.3.1
  def initialize(message); end

  private

  # @api private
  # @since 0.3.1
  def caller_index; end
end

# Safe dup logic
#
# @since 0.6.0
module Hanami::Utils::Duplicable
  class << self
    # Duplicates the given value.
    #
    # It accepts a block to customize the logic.
    #
    # The following types aren't duped:
    #
    #   * <tt>NilClass</tt>
    #   * <tt>FalseClass</tt>
    #   * <tt>TrueClass</tt>
    #   * <tt>Symbol</tt>
    #   * <tt>Numeric</tt>
    #
    # All the other types are duped via <tt>#dup</tt>
    #
    # @example Basic Usage With Types That Can't Be Duped
    #   require 'hanami/utils/duplicable'
    #
    #   object = 23
    #   puts object.object_id # => 47
    #
    #   result = Hanami::Utils::Duplicable.dup(object)
    #
    #   puts result           # => 23
    #   puts result.object_id # => 47 - Same object, because numbers can't be duped
    # @example Basic Usage With Types That Can Be Duped
    #   require 'hanami/utils/duplicable'
    #
    #   object = "hello"
    #   puts object.object_id # => 70172661782360
    #
    #   result = Hanami::Utils::Duplicable.dup(object)
    #
    #   puts result           # => "hello"
    #   puts result.object_id # => 70172671467020 - Different object
    # @example Custom Logic
    #   require 'hanami/utils/duplicable'
    #   require 'hanami/utils/hash'
    #
    #   hash = { a: 1 }
    #   puts hash.object_id # => 70207105061680
    #
    #   result = Hanami::Utils::Duplicable.dup(hash) do |value|
    #   case value
    #   when Hanami::Utils::Hash
    #   value.deep_dup
    #   when ::Hash
    #   Hanami::Utils::Hash.new(value).deep_dup.to_h
    #   end
    #   end
    #
    #   puts result           # => "{:a=>1}"
    #   puts result.object_id # => 70207105185500 - Different object
    # @param value [Object] the value to duplicate
    # @param blk [Proc] the optional block to customize the logic
    # @return [Object] the duped value
    # @since 0.6.0
    def dup(value, &blk); end
  end
end

# Ordered file list, consistent across operating systems
#
# @since 0.9.0
module Hanami::Utils::FileList
  class << self
    # Returns an ordered list of files, consistent across operating systems
    #
    # It has the same signature of <tt>Dir.glob</tt>, it just guarantees to
    # order the results before to return them.
    #
    # @see https://ruby-doc.org/core/Dir.html#method-c-glob
    # @since 0.9.0
    def [](*args); end
  end
end

# @api private
# @since 0.3.1
Hanami::Utils::HANAMI_JRUBY = T.let(T.unsafe(nil), String)

# @api private
# @since 0.3.1
Hanami::Utils::HANAMI_RUBINIUS = T.let(T.unsafe(nil), String)

# Hash on steroids
#
# @since 0.1.0
class Hanami::Utils::Hash
  extend ::Transproc::Registry

  # Initialize the hash
  #
  # @deprecated
  # @example Passing a Hash
  #   require 'hanami/utils/hash'
  #
  #   hash = Hanami::Utils::Hash.new('l' => 23)
  #   hash['l'] # => 23
  # @example Passing a block for default
  #   require 'hanami/utils/hash'
  #
  #   hash = Hanami::Utils::Hash.new {|h,k| h[k] = [] }
  #   hash['foo'].push 'bar'
  #
  #   hash.to_h # => { 'foo' => ['bar'] }
  # @param blk [Proc] define the default value
  # @param hash [#to_h] the value we want to use to initialize this instance
  # @return [Hanami::Utils::Hash] self
  # @see http://www.ruby-doc.org/core/Hash.html#method-c-5B-5D
  # @since 0.1.0
  def initialize(hash = T.unsafe(nil), &blk); end

  # Equality
  #
  # @deprecated
  # @return [TrueClass, FalseClass]
  # @since 0.3.0
  def ==(other); end

  # Retrieves the value object corresponding to the key object.
  #
  # @deprecated
  # @param key [Object] the key
  # @return [Object, nil] the correspoding value, if present
  # @see http://www.ruby-doc.org/core/Hash.html#method-i-5B-5D
  # @since 0.3.0
  def [](key); end

  # Associates the value given by value with the key given by key.
  #
  # @deprecated
  # @param key [Object] the key to assign
  # @param value [Object] the value to assign
  # @see http://www.ruby-doc.org/core/Hash.html#method-i-5B-5D-3D
  # @since 0.3.0
  def []=(key, value); end

  # Returns a deep copy of the current Hanami::Utils::Hash
  #
  # @deprecated Use {Hanami::Utils::Hash.deep_dup}
  # @example
  #   require 'hanami/utils/hash'
  #
  #   hash = Hanami::Utils::Hash.new(
  #   'nil'        => nil,
  #   'false'      => false,
  #   'true'       => true,
  #   'symbol'     => :foo,
  #   'fixnum'     => 23,
  #   'bignum'     => 13289301283 ** 2,
  #   'float'      => 1.0,
  #   'complex'    => Complex(0.3),
  #   'bigdecimal' => BigDecimal('12.0001'),
  #   'rational'   => Rational(0.3),
  #   'string'     => 'foo bar',
  #   'hash'       => { a: 1, b: 'two', c: :three },
  #   'u_hash'     => Hanami::Utils::Hash.new({ a: 1, b: 'two', c: :three })
  #   )
  #
  #   duped = hash.deep_dup
  #
  #   hash.class  # => Hanami::Utils::Hash
  #   duped.class # => Hanami::Utils::Hash
  #
  #   hash.object_id  # => 70147385937100
  #   duped.object_id # => 70147385950620
  #
  #   # unduplicated values
  #   duped['nil']        # => nil
  #   duped['false']      # => false
  #   duped['true']       # => true
  #   duped['symbol']     # => :foo
  #   duped['fixnum']     # => 23
  #   duped['bignum']     # => 176605528590345446089
  #   duped['float']      # => 1.0
  #   duped['complex']    # => (0.3+0i)
  #   duped['bigdecimal'] # => #<BigDecimal:7f9ffe6e2fd0,'0.120001E2',18(18)>
  #   duped['rational']   # => 5404319552844595/18014398509481984)
  #
  #   # it duplicates values
  #   duped['string'].reverse!
  #   duped['string'] # => "rab oof"
  #   hash['string']  # => "foo bar"
  #
  #   # it deeply duplicates Hash, by preserving the class
  #   duped['hash'].class # => Hash
  #   duped['hash'].delete(:a)
  #   hash['hash'][:a]    # => 1
  #
  #   duped['hash'][:b].upcase!
  #   duped['hash'][:b] # => "TWO"
  #   hash['hash'][:b]  # => "two"
  #
  #   # it deeply duplicates Hanami::Utils::Hash, by preserving the class
  #   duped['u_hash'].class # => Hanami::Utils::Hash
  # @return [Hash] a deep duplicated self
  # @since 0.3.1
  def deep_dup; end

  # Converts in-place all the keys to Symbol instances, nested hashes are converted too.
  #
  # @deprecated Use {Hanami::Utils::Hash.deep_symbolize}
  # @example
  #   require 'hanami/utils/hash'
  #
  #   hash = Hanami::Utils::Hash.new 'a' => 23, 'b' => { 'c' => ['x','y','z'] }
  #   hash.deep_symbolize!
  #
  #   hash.keys    # => [:a, :b]
  #   hash.inspect # => {:a=>23, :b=>{:c=>["x", "y", "z"]}}
  # @return [Hash] self
  # @since 1.0.0
  def deep_symbolize!; end

  # Deletes the key-value pair and returns the value from hsh whose key is
  # equal to key.
  #
  # @deprecated
  # @param key [Object] the key to remove
  # @return [Object, nil] the value hold by the given key, if present
  # @see http://www.ruby-doc.org/core/Hash.html#method-i-keys
  # @since 0.3.0
  def delete(key); end

  # Equality
  #
  # @deprecated
  # @return [TrueClass, FalseClass]
  # @since 0.3.0
  def eql?(other); end

  # Returns the hash of the internal @hash
  #
  # @deprecated
  # @return [Fixnum]
  # @since 0.3.0
  def hash; end

  # Returns a string describing the internal @hash
  #
  # @deprecated
  # @return [String]
  # @since 0.3.0
  def inspect; end

  # Returns a new array populated with the keys from this hash
  #
  # @deprecated
  # @return [Array] the keys
  # @see http://www.ruby-doc.org/core/Hash.html#method-i-keys
  # @since 0.3.0
  def keys; end

  # Overrides Ruby's method_missing in order to provide ::Hash interface
  #
  # @api private
  # @raise [NoMethodError] If doesn't respond to the given method
  # @since 0.3.0
  def method_missing(method_name, *args, &blk); end

  # Converts in-place all the keys to Symbol instances, nested hashes are converted too.
  #
  # @deprecated Use {Hanami::Utils::Hash.stringify}
  # @example
  #   require 'hanami/utils/hash'
  #
  #   hash = Hanami::Utils::Hash.new a: 23, b: { c: ['x','y','z'] }
  #   hash.stringify!
  #
  #   hash.keys    # => [:a, :b]
  #   hash.inspect # => {"a"=>23, "b"=>{"c"=>["x", "y", "z"]}}
  # @return [Hash] self
  # @since 0.3.2
  def stringify!; end

  # Converts in-place all the keys to Symbol instances.
  #
  # @deprecated Use {Hanami::Utils::Hash.symbolize}
  # @example
  #   require 'hanami/utils/hash'
  #
  #   hash = Hanami::Utils::Hash.new 'a' => 23, 'b' => { 'c' => ['x','y','z'] }
  #   hash.symbolize!
  #
  #   hash.keys    # => [:a, :b]
  #   hash.inspect # => { :a => 23, :b => { 'c' => ["x", "y", "z"] } }
  # @return [Hash] self
  # @since 0.1.0
  def symbolize!; end

  # Converts into a nested array of [ key, value ] arrays.
  #
  # @deprecated
  # @return [::Array] the array
  # @see http://www.ruby-doc.org/core/Hash.html#method-i-to_a
  # @since 0.3.0
  def to_a; end

  # Returns a Ruby Hash as duplicated version of self
  #
  # @deprecated
  # @return [::Hash] the hash
  # @see http://www.ruby-doc.org/core/Hash.html#method-i-to_h
  # @since 0.3.0
  def to_h; end

  # Returns a Ruby Hash as duplicated version of self
  #
  # @deprecated
  # @return [::Hash] the hash
  # @see http://www.ruby-doc.org/core/Hash.html#method-i-to_h
  # @since 0.3.0
  def to_hash; end

  private

  # Overrides Ruby's respond_to_missing? in order to support ::Hash interface
  #
  # @api private
  # @return [Boolean]
  # @since 0.3.0
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  class << self
    # Deep duplicates hash values
    #
    # The output of this function is a deep duplicate of the input.
    # Any further modification on the input, won't be reflected on the output
    # and viceversa.
    #
    # @example Basic Usage
    #   require 'hanami/utils/hash'
    #
    #   input  = { "a" => { "b" => { "c" => [1, 2, 3] } } }
    #   output = Hanami::Utils::Hash.deep_dup(input)
    #   # => {"a"=>{"b"=>{"c"=>[1,2,3]}}}
    #
    #   output.class
    #   # => Hash
    #
    #   # mutations on input aren't reflected on output
    #
    #   input["a"]["b"]["c"] << 4
    #   output.dig("a", "b", "c")
    #   # => [1, 2, 3]
    #
    #   # mutations on output aren't reflected on input
    #
    #   output["a"].delete("b")
    #   input
    #   # => {"a"=>{"b"=>{"c"=>[1,2,3,4]}}}
    # @param input [::Hash] the input
    # @return [::Hash] the deep duplicate of input
    # @since 1.0.1
    def deep_dup(input); end

    # Deep serializes given object into a `Hash`
    #
    # Please note that the returning `Hash` will use symbols as keys.
    #
    # @example Basic Usage
    #   require 'hanami/utils/hash'
    #   require 'ostruct'
    #
    #   class Data < OpenStruct
    #   def to_hash
    #   to_h
    #   end
    #   end
    #
    #   input = Data.new("foo" => "bar", baz => [Data.new(hello: "world")])
    #
    #   Hanami::Utils::Hash.deep_serialize(input)
    #   # => {:foo=>"bar", :baz=>[{:hello=>"world"}]}
    # @param input [#to_hash] the input
    # @return [::Hash] the deep serialized hash
    # @since 1.1.0
    def deep_serialize(input); end

    # Deeply stringifies the given hash
    #
    # @example Basic Usage
    #   require "hanami/utils/hash"
    #
    #   hash = Hanami::Utils::Hash.deep_stringify(foo: "bar", baz: {a: 1})
    #   # => {"foo"=>"bar", "baz"=>{"a"=>1}}
    #
    #   hash.class
    #   # => Hash
    # @param input [::Hash] the input
    # @return [::Hash] the deep stringified hash
    # @since 1.1.1
    def deep_stringify(input); end

    # Performs deep symbolize on the given hash
    #
    # @example Basic Usage
    #   require 'hanami/utils/hash'
    #
    #   hash = Hanami::Utils::Hash.deep_symbolize("foo" => "bar", "baz" => {"a" => 1})
    #   # => {:foo=>"bar", :baz=>{a:=>1}}
    #
    #   hash.class
    #   # => Hash
    # @param input [::Hash] the input
    # @return [::Hash] the deep symbolized hash
    # @see .symbolize
    # @since 1.0.1
    def deep_symbolize(input); end

    # Stringifies the given hash
    #
    # @example Basic Usage
    #   require 'hanami/utils/hash'
    #
    #   hash = Hanami::Utils::Hash.stringify(foo: "bar", baz: {a: 1})
    #   # => {"foo"=>"bar", "baz"=>{:a=>1}}
    #
    #   hash.class
    #   # => Hash
    # @param input [::Hash] the input
    # @return [::Hash] the stringified hash
    # @since 1.0.1
    def stringify(input); end

    # Symbolize the given hash
    #
    # @example Basic Usage
    #   require 'hanami/utils/hash'
    #
    #   hash = Hanami::Utils::Hash.symbolize("foo" => "bar", "baz" => {"a" => 1})
    #   # => {:foo=>"bar", :baz=>{"a"=>1}}
    #
    #   hash.class
    #   # => Hash
    # @param input [::Hash] the input
    # @return [::Hash] the symbolized hash
    # @see .deep_symbolize
    # @since 1.0.1
    def symbolize(input); end
  end
end

# @api private
# @see Hanami::Utils::Hash#deep_dup
# @see Hanami::Utils::Duplicable
# @since 0.6.0
Hanami::Utils::Hash::DUPLICATE_LOGIC = T.let(T.unsafe(nil), Proc)

# String inflector
#
# @since 0.4.1
module Hanami::Utils::Inflector
  include ::Hanami::Utils::ClassAttribute
  extend ::Hanami::Utils::ClassAttribute::ClassMethods

  class << self
    # Since ROM uses Inflecto for it inferences, we need to add an exception to it
    #   when one is registered against our Inflector.
    #
    # @api private
    # @since 0.4.1
    def add_to_inflecto(singular, plural); end

    # Adds a custom inflection exception
    #
    # @example
    #   require 'hanami/utils/inflector'
    #
    #   Hanami::Utils::Inflector.inflections do
    #   exception 'alga', 'algae'
    #   end
    # @param singular [String] form
    # @param plural [String] form
    # @see Hanami::Utils::Inflector.inflections
    # @see Hanami::Utils::Inflector.uncountable
    # @since 0.6.0
    def exception(singular, plural); end

    # Block for custom inflection rules.
    #
    # @example
    #   require 'hanami/utils/inflector'
    #
    #   Hanami::Utils::Inflector.inflections do
    #   exception   'analysis', 'analyses'
    #   exception   'alga',     'algae'
    #   uncountable 'music', 'butter'
    #   end
    # @param blk [Proc] custom inflections
    # @see Hanami::Utils::Inflector.exception
    # @see Hanami::Utils::Inflector.uncountable
    # @since 0.6.0
    def inflections(&blk); end

    # Pluralizes the given string
    #
    #
    # @api private
    # @param string [String] a string to pluralize
    # @return [String, NilClass] the pluralized string, if present
    # @since 0.4.1
    def pluralize(string); end

    def plurals; end
    def plurals=(_arg0); end

    # Singularizes the given string
    #
    #
    # @api private
    # @param string [String] a string to singularize
    # @return [String, NilClass] the singularized string, if present
    # @since 0.4.1
    def singularize(string); end

    def singulars; end
    def singulars=(_arg0); end

    # Adds an uncountable word
    #
    # @example
    #   require 'hanami/utils/inflector'
    #
    #   Hanami::Utils::Inflector.inflections do
    #   uncountable 'music', 'art'
    #   end
    # @param words [Array<String>]
    # @see Hanami::Utils::Inflector.inflections
    # @see Hanami::Utils::Inflector.exception
    # @since 0.6.0
    def uncountable(*words); end
  end
end

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::A = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::CH = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::CHES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::EAUX = T.let(T.unsafe(nil), String)

# @api private
# @since 0.6.0
Hanami::Utils::Inflector::ES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::F = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::I = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::ICE = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::ICES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::IDES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::IES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::IFE = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::IS = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::IVES = T.let(T.unsafe(nil), String)

# Rules for irregular plurals
#
# @api private
# @since 0.6.0
class Hanami::Utils::Inflector::IrregularRules
  # @api private
  # @return [IrregularRules] a new instance of IrregularRules
  # @since 0.6.0
  def initialize(rules); end

  # @api private
  # @since 0.6.0
  def ===(other); end

  # @api private
  # @since 0.6.0
  def add(key, value); end

  # @api private
  # @since 0.6.0
  def apply(string); end

  private

  # @api private
  # @since 1.3.3
  def extract_last_alphanumeric_token(string); end
end

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::MA = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::MATA = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::MEN = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::MINA = T.let(T.unsafe(nil), String)

# @api private
# @since 0.6.0
Hanami::Utils::Inflector::NA = T.let(T.unsafe(nil), String)

# @api private
# @since 0.6.0
Hanami::Utils::Inflector::NON = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::O = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::OES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::OUSE = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::RSE = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::RSES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::S = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::SES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::SSES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.6.0
Hanami::Utils::Inflector::TA = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::UM = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::US = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::USES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::VES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::X = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::XES = T.let(T.unsafe(nil), String)

# @api private
# @since 0.4.1
Hanami::Utils::Inflector::Y = T.let(T.unsafe(nil), String)

# Kernel utilities
#
# @since 0.1.1
module Hanami::Utils::Kernel
  class << self
    # Coerces the argument to be an Array.
    #
    # It's similar to Ruby's Kernel.Array, but it applies further
    # transformations:
    #
    #   * flatten
    #   * compact
    #   * uniq
    #
    # @example Basic Usage
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Array(nil)              # => []
    #   Hanami::Utils::Kernel.Array(true)             # => [true]
    #   Hanami::Utils::Kernel.Array(false)            # => [false]
    #   Hanami::Utils::Kernel.Array(1)                # => [1]
    #   Hanami::Utils::Kernel.Array([1])              # => [1]
    #   Hanami::Utils::Kernel.Array([1, [2]])         # => [1,2]
    #   Hanami::Utils::Kernel.Array([1, [2, nil]])    # => [1,2]
    #   Hanami::Utils::Kernel.Array([1, [2, nil, 1]]) # => [1,2]
    # @example Array Interface
    #   require 'hanami/utils/kernel'
    #
    #   ResultSet = Struct.new(:records) do
    #   def to_a
    #   records.to_a.sort
    #   end
    #   end
    #
    #   Response = Struct.new(:status, :headers, :body) do
    #   def to_ary
    #   [status, headers, body]
    #   end
    #   end
    #
    #   set = ResultSet.new([2,1,3])
    #   Hanami::Utils::Kernel.Array(set)              # => [1,2,3]
    #
    #   response = Response.new(200, {}, 'hello')
    #   Hanami::Utils::Kernel.Array(response)         # => [200, {}, "hello"]
    # @param arg [Object] the input
    # @return [Array] the result of the coercion
    # @see http://www.ruby-doc.org/core/Kernel.html#method-i-Array
    # @see http://www.ruby-doc.org/core/Array.html#method-i-flatten
    # @see http://www.ruby-doc.org/core/Array.html#method-i-compact
    # @see http://www.ruby-doc.org/core/Array.html#method-i-uniq
    # @since 0.1.1
    def Array(arg); end

    # Coerces the argument to be a BigDecimal.
    #
    # @example Basic Usage
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.BigDecimal(1)                        # => 1
    #   Hanami::Utils::Kernel.BigDecimal(1.2)                      # => 1
    #   Hanami::Utils::Kernel.BigDecimal(011)                      # => 9
    #   Hanami::Utils::Kernel.BigDecimal(0xf5)                     # => 245
    #   Hanami::Utils::Kernel.BigDecimal("1")                      # => 1
    #   Hanami::Utils::Kernel.BigDecimal(Rational(0.3))            # => 0.3
    #   Hanami::Utils::Kernel.BigDecimal(Complex(0.3))             # => 0.3
    #   Hanami::Utils::Kernel.BigDecimal(BigDecimal(12.00001))     # => 12.00001
    #   Hanami::Utils::Kernel.BigDecimal(176605528590345446089)
    #   # => 176605528590345446089
    # @example BigDecimal Interface
    #   require 'hanami/utils/kernel'
    #
    #   UltimateAnswer = Struct.new(:question) do
    #   def to_d
    #   BigDecimal(42)
    #   end
    #   end
    #
    #   answer = UltimateAnswer.new('The Ultimate Question of Life')
    #   Hanami::Utils::Kernel.BigDecimal(answer)
    #   # => #<BigDecimal:7fabfd148588,'0.42E2',9(27)>
    # @example Unchecked exceptions
    #   require 'hanami/utils/kernel'
    #
    #   # When nil
    #   input = nil
    #   Hanami::Utils::Kernel.BigDecimal(nil) # => TypeError
    #
    #   # When true
    #   input = true
    #   Hanami::Utils::Kernel.BigDecimal(input) # => TypeError
    #
    #   # When false
    #   input = false
    #   Hanami::Utils::Kernel.BigDecimal(input) # => TypeError
    #
    #   # When Date
    #   input = Date.today
    #   Hanami::Utils::Kernel.BigDecimal(input) # => TypeError
    #
    #   # When DateTime
    #   input = DateTime.now
    #   Hanami::Utils::Kernel.BigDecimal(input) # => TypeError
    #
    #   # When Time
    #   input = Time.now
    #   Hanami::Utils::Kernel.BigDecimal(input) # => TypeError
    #
    #   # String that doesn't represent a big decimal
    #   input = 'hello'
    #   Hanami::Utils::Kernel.BigDecimal(input) # => TypeError
    #
    #   # Missing #respond_to?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.BigDecimal(input) # => TypeError
    # @param arg [Object] the argument
    # @raise [TypeError] if the argument can't be coerced
    # @return [BigDecimal] the result of the coercion
    # @see http://www.ruby-doc.org/stdlib/libdoc/bigdecimal/rdoc/BigDecimal.html
    # @since 0.3.0
    def BigDecimal(arg, precision = T.unsafe(nil)); end

    # Coerces the argument to be a Boolean.
    #
    # @example Basic Usage
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Boolean(nil)                      # => false
    #   Hanami::Utils::Kernel.Boolean(0)                        # => false
    #   Hanami::Utils::Kernel.Boolean(1)                        # => true
    #   Hanami::Utils::Kernel.Boolean('0')                      # => false
    #   Hanami::Utils::Kernel.Boolean('1')                      # => true
    #   Hanami::Utils::Kernel.Boolean(Object.new)               # => true
    # @example Boolean Interface
    #   require 'hanami/utils/kernel'
    #
    #   Answer = Struct.new(:answer) do
    #   def to_bool
    #   case answer
    #   when 'yes' then true
    #   else false
    #   end
    #   end
    #   end
    #
    #   answer = Answer.new('yes')
    #   Hanami::Utils::Kernel.Boolean(answer) # => true
    # @example Unchecked Exceptions
    #   require 'hanami/utils/kernel'
    #
    #   # Missing #respond_to?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.Boolean(input) # => TypeError
    # @param arg [Object] the argument
    # @raise [TypeError] if the argument can't be coerced
    # @return [true, false] the result of the coercion
    # @since 0.1.1
    def Boolean(arg); end

    # Coerces the argument to be a Date.
    #
    # @example Basic Usage
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Date(Date.today)
    #   # => #<Date: 2014-04-17 ((2456765j,0s,0n),+0s,2299161j)>
    #
    #   Hanami::Utils::Kernel.Date(DateTime.now)
    #   # => #<Date: 2014-04-17 ((2456765j,0s,0n),+0s,2299161j)>
    #
    #   Hanami::Utils::Kernel.Date(Time.now)
    #   # => #<Date: 2014-04-17 ((2456765j,0s,0n),+0s,2299161j)>
    #
    #   Hanami::Utils::Kernel.Date('2014-04-17')
    #   # => #<Date: 2014-04-17 ((2456765j,0s,0n),+0s,2299161j)>
    #
    #   Hanami::Utils::Kernel.Date('2014-04-17 22:37:15')
    #   # => #<Date: 2014-04-17 ((2456765j,0s,0n),+0s,2299161j)>
    # @example Date Interface
    #   require 'hanami/utils/kernel'
    #
    #   class Christmas
    #   def to_date
    #   Date.parse('Dec, 25')
    #   end
    #   end
    #
    #   Hanami::Utils::Kernel.Date(Christmas.new)
    #   # => #<Date: 2014-12-25 ((2457017j,0s,0n),+0s,2299161j)>
    # @example Unchecked Exceptions
    #   require 'hanami/utils/kernel'
    #
    #   # nil
    #   input = nil
    #   Hanami::Utils::Kernel.Date(input) # => TypeError
    #
    #   # Missing #respond_to?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.Date(input) # => TypeError
    #
    #   # Missing #to_s?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.Date(input) # => TypeError
    # @param arg [Object] the argument
    # @raise [TypeError] if the argument can't be coerced
    # @return [Date] the result of the coercion
    # @since 0.1.1
    def Date(arg); end

    # Coerces the argument to be a DateTime.
    #
    # @example Basic Usage
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.DateTime(3483943)
    #   # => Time.at(3483943).to_datetime
    #   # #<DateTime: 1970-02-10T08:45:43+01:00 ((2440628j,27943s,0n),+3600s,2299161j)>
    #
    #   Hanami::Utils::Kernel.DateTime(DateTime.now)
    #   # => #<DateTime: 2014-04-18T09:33:49+02:00 ((2456766j,27229s,690849000n),+7200s,2299161j)>
    #
    #   Hanami::Utils::Kernel.DateTime(Date.today)
    #   # => #<DateTime: 2014-04-18T00:00:00+00:00 ((2456766j,0s,0n),+0s,2299161j)>
    #
    #   Hanami::Utils::Kernel.Date(Time.now)
    #   # => #<DateTime: 2014-04-18T09:34:49+02:00 ((2456766j,27289s,832907000n),+7200s,2299161j)>
    #
    #   Hanami::Utils::Kernel.DateTime('2014-04-18')
    #   # => #<DateTime: 2014-04-18T00:00:00+00:00 ((2456766j,0s,0n),+0s,2299161j)>
    #
    #   Hanami::Utils::Kernel.DateTime('2014-04-18 09:35:42')
    #   # => #<DateTime: 2014-04-18T09:35:42+00:00 ((2456766j,34542s,0n),+0s,2299161j)>
    # @example DateTime Interface
    #   require 'hanami/utils/kernel'
    #
    #   class NewYearEve
    #   def to_datetime
    #   DateTime.parse('Jan, 1')
    #   end
    #   end
    #
    #   Hanami::Utils::Kernel.Date(NewYearEve.new)
    #   # => #<DateTime: 2014-01-01T00:00:00+00:00 ((2456659j,0s,0n),+0s,2299161j)>
    # @example Unchecked Exceptions
    #   require 'hanami/utils/kernel'
    #
    #   # When nil
    #   input = nil
    #   Hanami::Utils::Kernel.DateTime(input) # => TypeError
    #
    #   # Missing #respond_to?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.DateTime(input) # => TypeError
    #
    #   # Missing #to_s?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.DateTime(input) # => TypeError
    # @param arg [Object] the argument
    # @raise [TypeError] if the argument can't be coerced
    # @return [DateTime] the result of the coercion
    # @since 0.1.1
    def DateTime(arg); end

    # Coerces the argument to be a Float.
    #
    # It's similar to Ruby's Kernel.Float, but it doesn't stop at the first
    # error and raise an exception only when the argument can't be coerced.
    #
    # @example Basic Usage
    #   require 'bigdecimal'
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Float(1)                        # => 1.0
    #   Hanami::Utils::Kernel.Float(1.2)                      # => 1.2
    #   Hanami::Utils::Kernel.Float(011)                      # => 9.0
    #   Hanami::Utils::Kernel.Float(0xf5)                     # => 245.0
    #   Hanami::Utils::Kernel.Float("1")                      # => 1.0
    #   Hanami::Utils::Kernel.Float(Rational(0.3))            # => 0.3
    #   Hanami::Utils::Kernel.Float(Complex(0.3))             # => 0.3
    #   Hanami::Utils::Kernel.Float(BigDecimal(12.00001))     # => 12.00001
    #   Hanami::Utils::Kernel.Float(176605528590345446089)
    #   # => 176605528590345446089.0
    #
    #   Hanami::Utils::Kernel.Float(Time.now) # => 397750945.515169
    # @example Float Interface
    #   require 'hanami/utils/kernel'
    #
    #   class Pi
    #   def to_f
    #   3.14
    #   end
    #   end
    #
    #   pi = Pi.new
    #   Hanami::Utils::Kernel.Float(pi) # => 3.14
    # @example Error Handling
    #   require 'bigdecimal'
    #   require 'hanami/utils/kernel'
    #
    #   # nil
    #   Kernel.Float(nil)               # => TypeError
    #   Hanami::Utils::Kernel.Float(nil) # => 0.0
    #
    #   # float represented as a string
    #   Kernel.Float("23.4")               # => TypeError
    #   Hanami::Utils::Kernel.Float("23.4") # => 23.4
    #
    #   # rational represented as a string
    #   Kernel.Float("2/3")               # => TypeError
    #   Hanami::Utils::Kernel.Float("2/3") # => 2.0
    #
    #   # complex represented as a string
    #   Kernel.Float("2.5/1")               # => TypeError
    #   Hanami::Utils::Kernel.Float("2.5/1") # => 2.5
    #
    #   # bigdecimal infinity
    #   input = BigDecimal("Infinity")
    #   Hanami::Utils::Kernel.Float(input) # => Infinity
    #
    #   # bigdecimal NaN
    #   input = BigDecimal("NaN")
    #   Hanami::Utils::Kernel.Float(input) # => NaN
    # @example Unchecked Exceptions
    #   require 'date'
    #   require 'bigdecimal'
    #   require 'hanami/utils/kernel'
    #
    #   # Missing #to_f
    #   input = OpenStruct.new(color: 'purple')
    #   Hanami::Utils::Kernel.Float(input) # => TypeError
    #
    #   # When true
    #   input = true
    #   Hanami::Utils::Kernel.Float(input) # => TypeError
    #
    #   # When false
    #   input = false
    #   Hanami::Utils::Kernel.Float(input) # => TypeError
    #
    #   # When Date
    #   input = Date.today
    #   Hanami::Utils::Kernel.Float(input) # => TypeError
    #
    #   # When DateTime
    #   input = DateTime.now
    #   Hanami::Utils::Kernel.Float(input) # => TypeError
    #
    #   # Missing #nil?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.Float(input) # => TypeError
    #
    #   # String that doesn't represent a float
    #   input = 'hello'
    #   Hanami::Utils::Kernel.Float(input) # => TypeError
    #
    #   # big rational
    #   input = Rational(-8) ** Rational(1, 3)
    #   Hanami::Utils::Kernel.Float(input) # => TypeError
    #
    #   # big complex represented as a string
    #   input = Complex(2, 3)
    #   Hanami::Utils::Kernel.Float(input) # => TypeError
    # @param arg [Object] the argument
    # @raise [TypeError] if the argument can't be coerced
    # @return [Float] the result of the coercion
    # @see http://www.ruby-doc.org/core/Kernel.html#method-i-Float
    # @since 0.1.1
    def Float(arg); end

    # Coerces the argument to be a Hash.
    #
    # @example Basic Usage
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Hash(nil)                 # => {}
    #   Hanami::Utils::Kernel.Hash({a: 1})              # => { :a => 1 }
    #   Hanami::Utils::Kernel.Hash([[:a, 1]])           # => { :a => 1 }
    #   Hanami::Utils::Kernel.Hash(Set.new([[:a, 1]]))  # => { :a => 1 }
    # @example Hash Interface
    #   require 'hanami/utils/kernel'
    #
    #   Room = Class.new do
    #   def initialize(*args)
    #   @args = args
    #   end
    #
    #   def to_h
    #   Hash[*@args]
    #   end
    #   end
    #
    #   Record = Class.new do
    #   def initialize(attributes = {})
    #   @attributes = attributes
    #   end
    #
    #   def to_hash
    #   @attributes
    #   end
    #   end
    #
    #   room = Room.new(:key, 123456)
    #   Hanami::Utils::Kernel.Hash(room)        # => { :key => 123456 }
    #
    #   record = Record.new(name: 'L')
    #   Hanami::Utils::Kernel.Hash(record)      # => { :name => "L" }
    # @example Unchecked Exceptions
    #   require 'hanami/utils/kernel'
    #
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.Hash(input) # => TypeError
    # @param arg [Object] the input
    # @raise [TypeError] if arg can't be coerced
    # @return [Hash] the result of the coercion
    # @see http://www.ruby-doc.org/core/Kernel.html#method-i-Hash
    # @since 0.1.1
    def Hash(arg); end

    # Coerces the argument to be an Integer.
    #
    # It's similar to Ruby's Kernel.Integer, but it doesn't stop at the first
    # error and raise an exception only when the argument can't be coerced.
    #
    # @example Basic Usage
    #   require 'bigdecimal'
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Integer(1)                        # => 1
    #   Hanami::Utils::Kernel.Integer(1.2)                      # => 1
    #   Hanami::Utils::Kernel.Integer(011)                      # => 9
    #   Hanami::Utils::Kernel.Integer(0xf5)                     # => 245
    #   Hanami::Utils::Kernel.Integer("1")                      # => 1
    #   Hanami::Utils::Kernel.Integer(Rational(0.3))            # => 0
    #   Hanami::Utils::Kernel.Integer(Complex(0.3))             # => 0
    #   Hanami::Utils::Kernel.Integer(BigDecimal(12.00001))     # => 12
    #   Hanami::Utils::Kernel.Integer(176605528590345446089)
    #   # => 176605528590345446089
    #
    #   Hanami::Utils::Kernel.Integer(Time.now)                 # => 1396947161
    # @example Integer Interface
    #   require 'hanami/utils/kernel'
    #
    #   UltimateAnswer = Struct.new(:question) do
    #   def to_int
    #   42
    #   end
    #   end
    #
    #   answer = UltimateAnswer.new('The Ultimate Question of Life')
    #   Hanami::Utils::Kernel.Integer(answer) # => 42
    # @example Error Handling
    #   require 'hanami/utils/kernel'
    #
    #   # nil
    #   Kernel.Integer(nil)               # => TypeError
    #   Hanami::Utils::Kernel.Integer(nil) # => 0
    #
    #   # float represented as a string
    #   Kernel.Integer("23.4")               # => TypeError
    #   Hanami::Utils::Kernel.Integer("23.4") # => 23
    #
    #   # rational represented as a string
    #   Kernel.Integer("2/3")               # => TypeError
    #   Hanami::Utils::Kernel.Integer("2/3") # => 2
    #
    #   # complex represented as a string
    #   Kernel.Integer("2.5/1")               # => TypeError
    #   Hanami::Utils::Kernel.Integer("2.5/1") # => 2
    # @example Unchecked Exceptions
    #   require 'date'
    #   require 'bigdecimal'
    #   require 'hanami/utils/kernel'
    #
    #   # Missing #to_int and #to_i
    #   input = OpenStruct.new(color: 'purple')
    #   Hanami::Utils::Kernel.Integer(input) # => TypeError
    #
    #   # String that doesn't represent an integer
    #   input = 'hello'
    #   Hanami::Utils::Kernel.Integer(input) # => TypeError
    #
    #   # When true
    #   input = true
    #   Hanami::Utils::Kernel.Integer(input) # => TypeError
    #
    #   # When false
    #   input = false
    #   Hanami::Utils::Kernel.Integer(input) # => TypeError
    #
    #   # When Date
    #   input = Date.today
    #   Hanami::Utils::Kernel.Integer(input) # => TypeError
    #
    #   # When DateTime
    #   input = DateTime.now
    #   Hanami::Utils::Kernel.Integer(input) # => TypeError
    #
    #   # bigdecimal infinity
    #   input = BigDecimal("Infinity")
    #   Hanami::Utils::Kernel.Integer(input) # => TypeError
    #
    #   # bigdecimal NaN
    #   input = BigDecimal("NaN")
    #   Hanami::Utils::Kernel.Integer(input) # => TypeError
    #
    #   # big rational
    #   input = Rational(-8) ** Rational(1, 3)
    #   Hanami::Utils::Kernel.Integer(input) # => TypeError
    #
    #   # big complex represented as a string
    #   input = Complex(2, 3)
    #   Hanami::Utils::Kernel.Integer(input) # => TypeError
    # @param arg [Object] the argument
    # @raise [TypeError] if the argument can't be coerced
    # @return [Fixnum] the result of the coercion
    # @see http://www.ruby-doc.org/core/Kernel.html#method-i-Integer
    # @since 0.1.1
    def Integer(arg); end

    # Coerces the argument to be a Pathname.
    #
    # @example Basic Usage
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Pathname(Pathname.new('/path/to')) # => #<Pathname:/path/to>
    #   Hanami::Utils::Kernel.Pathname('/path/to')               # => #<Pathname:/path/to>
    # @example Pathname Interface
    #   require 'hanami/utils/kernel'
    #
    #   class HomePath
    #   def to_pathname
    #   Pathname.new Dir.home
    #   end
    #   end
    #
    #   Hanami::Utils::Kernel.Pathname(HomePath.new) # => #<Pathname:/Users/luca>
    # @example String Interface
    #   require 'hanami/utils/kernel'
    #
    #   class RootPath
    #   def to_str
    #   '/'
    #   end
    #   end
    #
    #   Hanami::Utils::Kernel.Pathname(RootPath.new) # => #<Pathname:/>
    # @example Unchecked Exceptions
    #   require 'hanami/utils/kernel'
    #
    #   # When nil
    #   input = nil
    #   Hanami::Utils::Kernel.Pathname(input) # => TypeError
    #
    #   # Missing #respond_to?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.Pathname(input) # => TypeError
    # @param arg [#to_pathname, #to_str] the argument
    # @raise [TypeError] if the argument can't be coerced
    # @return [Pathname] the result of the coercion
    # @since 0.1.2
    def Pathname(arg); end

    # Coerces the argument to be a Set.
    #
    # @example Basic Usage
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Set(nil)              # => #<Set: {}>
    #   Hanami::Utils::Kernel.Set(true)             # => #<Set: {true}>
    #   Hanami::Utils::Kernel.Set(false)            # => #<Set: {false}>
    #   Hanami::Utils::Kernel.Set(1)                # => #<Set: {1}>
    #   Hanami::Utils::Kernel.Set([1])              # => #<Set: {1}>
    #   Hanami::Utils::Kernel.Set([1, 1])           # => #<Set: {1}>
    #   Hanami::Utils::Kernel.Set([1, [2]])         # => #<Set: {1, [2]}>
    #   Hanami::Utils::Kernel.Set([1, [2, nil]])    # => #<Set: {1, [2, nil]}>
    #   Hanami::Utils::Kernel.Set({a: 1})           # => #<Set: {[:a, 1]}>
    # @example Set Interface
    #   require 'securerandom'
    #   require 'hanami/utils/kernel'
    #
    #   UuidSet = Class.new do
    #   def initialize(*uuids)
    #   @uuids = uuids
    #   end
    #
    #   def to_set
    #   Set.new.tap do |set|
    #   @uuids.each {|uuid| set.add(uuid) }
    #   end
    #   end
    #   end
    #
    #   uuids = UuidSet.new(SecureRandom.uuid)
    #   Hanami::Utils::Kernel.Set(uuids)
    #   # => #<Set: {"daa798b4-630c-4e11-b29d-92f0b1c7d075"}>
    # @example Unchecked Exceptions
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Set(BasicObject.new) # => TypeError
    # @param arg [Object] the input
    # @raise [TypeError] if arg doesn't implement #respond_to?
    # @return [Set] the result of the coercion
    # @since 0.1.1
    def Set(arg); end

    # Coerces the argument to be a String.
    #
    # Identical behavior of Ruby's Kernel.Array, still here because we want
    # to keep the interface consistent
    #
    # @example Basic Usage
    #   require 'date'
    #   require 'bigdecimal'
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.String('')                            # => ""
    #   Hanami::Utils::Kernel.String('ciao')                        # => "ciao"
    #
    #   Hanami::Utils::Kernel.String(true)                          # => "true"
    #   Hanami::Utils::Kernel.String(false)                         # => "false"
    #
    #   Hanami::Utils::Kernel.String(:hanami)                        # => "hanami"
    #
    #   Hanami::Utils::Kernel.String(Picture)                       # => "Picture" # class
    #   Hanami::Utils::Kernel.String(Hanami)                         # => "Hanami" # module
    #
    #   Hanami::Utils::Kernel.String([])                            # => "[]"
    #   Hanami::Utils::Kernel.String([1,2,3])                       # => "[1, 2, 3]"
    #   Hanami::Utils::Kernel.String(%w[a b c])                     # => "[\"a\", \"b\", \"c\"]"
    #
    #   Hanami::Utils::Kernel.String({})                            # => "{}"
    #   Hanami::Utils::Kernel.String({a: 1, 'b' => 'c'})            # => "{:a=>1, \"b\"=>\"c\"}"
    #
    #   Hanami::Utils::Kernel.String(Date.today)                    # => "2014-04-11"
    #   Hanami::Utils::Kernel.String(DateTime.now)                  # => "2014-04-11T10:15:06+02:00"
    #   Hanami::Utils::Kernel.String(Time.now)                      # => "2014-04-11 10:15:53 +0200"
    #
    #   Hanami::Utils::Kernel.String(1)                             # => "1"
    #   Hanami::Utils::Kernel.String(3.14)                          # => "3.14"
    #   Hanami::Utils::Kernel.String(013)                           # => "11"
    #   Hanami::Utils::Kernel.String(0xc0ff33)                      # => "12648243"
    #
    #   Hanami::Utils::Kernel.String(Rational(-22))                 # => "-22/1"
    #   Hanami::Utils::Kernel.String(Complex(11, 2))                # => "11+2i"
    #   Hanami::Utils::Kernel.String(BigDecimal(7944.2343, 10))     # => "0.79442343E4"
    #   Hanami::Utils::Kernel.String(BigDecimal('Infinity'))        # => "Infinity"
    #   Hanami::Utils::Kernel.String(BigDecimal('NaN'))             # => "Infinity"
    # @example String interface
    #   require 'hanami/utils/kernel'
    #
    #   SimpleObject = Class.new(BasicObject) do
    #   def to_s
    #   'simple object'
    #   end
    #   end
    #
    #   Isbn = Struct.new(:code) do
    #   def to_str
    #   code.to_s
    #   end
    #   end
    #
    #   simple = SimpleObject.new
    #   isbn   = Isbn.new(123)
    #
    #   Hanami::Utils::Kernel.String(simple) # => "simple object"
    #   Hanami::Utils::Kernel.String(isbn)   # => "123"
    # @example Comparison with Ruby
    #   require 'hanami/utils/kernel'
    #
    #   # nil
    #   Kernel.String(nil)               # => ""
    #   Hanami::Utils::Kernel.String(nil) # => ""
    # @example Unchecked Exceptions
    #   require 'hanami/utils/kernel'
    #
    #   # Missing #to_s or #to_str
    #   input = BaseObject.new
    #   Hanami::Utils::Kernel.String(input) # => TypeError
    # @param arg [Object] the argument
    # @raise [TypeError] if the argument can't be coerced
    # @return [String] the result of the coercion
    # @see http://www.ruby-doc.org/core/Kernel.html#method-i-String
    # @since 0.1.1
    def String(arg); end

    # Coerces the argument to be a Symbol.
    #
    # @example Basic Usage
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Symbol(:hello)  # => :hello
    #   Hanami::Utils::Kernel.Symbol('hello') # => :hello
    # @example Symbol Interface
    #   require 'hanami/utils/kernel'
    #
    #   class StatusSymbol
    #   def to_sym
    #   :success
    #   end
    #   end
    #
    #   Hanami::Utils::Kernel.Symbol(StatusSymbol.new) # => :success
    # @example Unchecked Exceptions
    #   require 'hanami/utils/kernel'
    #
    #   # When nil
    #   input = nil
    #   Hanami::Utils::Kernel.Symbol(input) # => TypeError
    #
    #   # When empty string
    #   input = ''
    #   Hanami::Utils::Kernel.Symbol(input) # => TypeError
    #
    #   # Missing #respond_to?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.Symbol(input) # => TypeError
    # @param arg [#to_sym] the argument
    # @raise [TypeError] if the argument can't be coerced
    # @return [Symbol] the result of the coercion
    # @since 0.2.0
    def Symbol(arg); end

    # Coerces the argument to be a Time.
    #
    # @example Basic Usage
    #   require 'hanami/utils/kernel'
    #
    #   Hanami::Utils::Kernel.Time(Time.now)
    #   # => 2014-04-18 15:56:39 +0200
    #
    #   Hanami::Utils::Kernel.Time(DateTime.now)
    #   # => 2014-04-18 15:56:39 +0200
    #
    #   Hanami::Utils::Kernel.Time(Date.today)
    #   # => 2014-04-18 00:00:00 +0200
    #
    #   Hanami::Utils::Kernel.Time('2014-04-18')
    #   # => 2014-04-18 00:00:00 +0200
    #
    #   Hanami::Utils::Kernel.Time('2014-04-18 15:58:02')
    #   # => 2014-04-18 15:58:02 +0200
    # @example Time Interface
    #   require 'hanami/utils/kernel'
    #
    #   class Epoch
    #   def to_time
    #   Time.at(0)
    #   end
    #   end
    #
    #   Hanami::Utils::Kernel.Time(Epoch.new)
    #   # => 1970-01-01 01:00:00 +0100
    # @example Unchecked Exceptions
    #   require 'hanami/utils/kernel'
    #
    #   # When nil
    #   input = nil
    #   Hanami::Utils::Kernel.Time(input) # => TypeError
    #
    #   # Missing #respond_to?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.Time(input) # => TypeError
    #
    #   # Missing #to_s?
    #   input = BasicObject.new
    #   Hanami::Utils::Kernel.Time(input) # => TypeError
    # @param arg [Object] the argument
    # @raise [TypeError] if the argument can't be coerced
    # @return [Time] the result of the coercion
    # @since 0.1.1
    def Time(arg); end

    # Checks if the given argument is a string representation of a number
    #
    # @api private
    # @param arg [Object] the input
    # @return [TrueClass, FalseClass]
    # @since 0.8.0
    def numeric?(arg); end

    private

    # Returns the most useful type error possible
    #
    # If the object does not respond_to?(:inspect), we return the class, else we
    # return nil. In all cases, this method is tightly bound to callers, as this
    # method appends the required space to make the error message look good.
    #
    # @api private
    # @since 0.4.3
    def inspect_type_error(arg); end
  end
end

# @api private
# @since 0.8.0
Hanami::Utils::Kernel::BOOLEAN_FALSE_STRING = T.let(T.unsafe(nil), String)

# @api private
# @since 0.8.0
Hanami::Utils::Kernel::BOOLEAN_TRUE_INTEGER = T.let(T.unsafe(nil), Integer)

# Matcher for numeric values
#
# @api private
# @see Hanami::Utils::Kernel.Integer
# @since 0.3.3
Hanami::Utils::Kernel::NUMERIC_MATCHER = T.let(T.unsafe(nil), Regexp)

# Prefixed string
#
# @since 0.1.0
class Hanami::Utils::PathPrefix < ::Hanami::Utils::String
  # Initialize the path prefix
  #
  # @param string [::String] the prefix value
  # @param separator [::String] the separator used between tokens
  # @return [PathPrefix] self
  # @see Hanami::Utils::PathPrefix::DEFAULT_SEPARATOR
  # @since 0.1.0
  def initialize(string = T.unsafe(nil), separator = T.unsafe(nil)); end

  # Joins self with the given token.
  # It cleans up all the `separator` repetitions.
  #
  # @example Single string
  #   require 'hanami/utils/path_prefix'
  #
  #   path_prefix = Hanami::Utils::PathPrefix.new('/posts')
  #   path_prefix.join('new').to_s  # => "/posts/new"
  #   path_prefix.join('/new').to_s # => "/posts/new"
  #
  #   path_prefix = Hanami::Utils::PathPrefix.new('posts')
  #   path_prefix.join('new').to_s  # => "/posts/new"
  #   path_prefix.join('/new').to_s # => "/posts/new"
  # @example Multiple strings
  #   require 'hanami/utils/path_prefix'
  #
  #   path_prefix = Hanami::Utils::PathPrefix.new('myapp')
  #   path_prefix.join('/assets', 'application.js').to_s
  #   # => "/myapp/assets/application.js"
  # @param strings [::String] the token(s) we want to join
  # @return [Hanami::Utils::PathPrefix] the joined string
  # @since 0.1.0
  def join(*strings); end

  # Joins self with the given token, without prefixing it with `separator`.
  # It cleans up all the `separator` repetitions.
  #
  # @example
  #   require 'hanami/utils/path_prefix'
  #
  #   path_prefix = Hanami::Utils::PathPrefix.new 'posts'
  #   path_prefix.relative_join('new').to_s      # => 'posts/new'
  #   path_prefix.relative_join('new', '_').to_s # => 'posts_new'
  # @param strings [::String] the tokens we want to join
  # @param separator [::String] the separator used between tokens
  # @raise [TypeError] if one of the argument can't be treated as a
  #   string
  # @return [Hanami::Utils::PathPrefix] the joined string
  # @since 0.1.0
  def relative_join(strings, separator = T.unsafe(nil)); end

  protected

  # Modifies the path prefix to have a prepended separator.
  #
  # @api private
  # @return [self]
  # @see #absolute
  # @since 0.3.1
  def absolute!; end

  # Returns whether the path prefix starts with its separator.
  #
  # @api private
  # @example
  #   require 'hanami/utils/path_prefix'
  #
  #   Hanami::Utils::PathPrefix.new('/posts').absolute? #=> true
  #   Hanami::Utils::PathPrefix.new('posts').absolute?  #=> false
  # @return [TrueClass, FalseClass]
  # @since 0.3.1
  def absolute?; end

  # Modifies the path prefix to remove the leading separator.
  #
  # @api private
  # @return [self]
  # @see #relative
  # @since 0.3.1
  def relative!; end

  private

  # @api private
  # @since 0.1.0
  def separator; end
end

# Path separator
#
# @api private
# @since 0.3.1
Hanami::Utils::PathPrefix::DEFAULT_SEPARATOR = T.let(T.unsafe(nil), String)

# String on steroids
#
# @since 0.1.0
class Hanami::Utils::String
  extend ::Transproc::Registry
  extend ::Transproc::Composer

  # Initialize the string
  #
  # @deprecated
  # @param string [::String, Symbol] the value we want to initialize
  # @return [Hanami::Utils::String] self
  # @since 0.1.0
  def initialize(string); end

  # Equality
  #
  # @deprecated
  # @return [TrueClass, FalseClass]
  # @since 0.3.0
  def ==(other); end

  # Returns a capitalized version of the string
  #
  # @deprecated Use {Hanami::Utils::String.capitalize}
  # @example
  #   require 'hanami/utils/string'
  #
  #   string = Hanami::Utils::String.new 'hanami'
  #   string.capitalize # => "Hanami"
  #
  #   string = Hanami::Utils::String.new 'hanami utils'
  #   string.capitalize # => "Hanami utils"
  #
  #   string = Hanami::Utils::String.new 'Hanami Utils'
  #   string.capitalize # => "Hanami utils"
  #
  #   string = Hanami::Utils::String.new 'hanami_utils'
  #   string.capitalize # => "Hanami utils"
  #
  #   string = Hanami::Utils::String.new 'hanami-utils'
  #   string.capitalize # => "Hanami utils"
  # @return [Hanami::Utils::String] the transformed string
  # @since 0.5.2
  def capitalize; end

  # Returns a CamelCase version of the string
  #
  # @deprecated Use {Hanami::Utils::String.classify}
  # @example
  #   require 'hanami/utils/string'
  #
  #   string = Hanami::Utils::String.new 'hanami_utils'
  #   string.classify # => 'HanamiUtils'
  # @return [Hanami::Utils::String] the transformed string
  # @since 0.1.0
  def classify; end

  # Returns a downcased and dash separated version of the string
  #
  # @deprecated Use {Hanami::Utils::String.dasherize}
  # @example
  #   require 'hanami/utils/string'
  #
  #   string = Hanami::Utils::String.new 'Hanami Utils'
  #   string.dasherize # => 'hanami-utils'
  #
  #   string = Hanami::Utils::String.new 'hanami_utils'
  #   string.dasherize # => 'hanami-utils'
  #
  #   string = Hanami::Utils::String.new 'HanamiUtils'
  #   string.dasherize # => "hanami-utils"
  # @return [Hanami::Utils::String] the transformed string
  # @since 0.4.0
  def dasherize; end

  # Returns the string without the Ruby namespace of the class
  #
  # @deprecated Use {Hanami::Utils::String.demodulize}
  # @example
  #   require 'hanami/utils/string'
  #
  #   string = Hanami::Utils::String.new 'Hanami::Utils::String'
  #   string.demodulize # => 'String'
  #
  #   string = Hanami::Utils::String.new 'String'
  #   string.demodulize # => 'String'
  # @return [Hanami::Utils::String] the transformed string
  # @since 0.1.0
  def demodulize; end

  # Equality
  #
  # @deprecated
  # @return [TrueClass, FalseClass]
  # @since 0.3.0
  def eql?(other); end

  # Replaces the given pattern with the given replacement
  #
  # @deprecated
  # @return [::String]
  # @see http://www.ruby-doc.org/core/String.html#method-i-gsub
  # @since 0.3.0
  def gsub(pattern, replacement = T.unsafe(nil), &blk); end

  # Returns the hash of the internal string
  #
  # @deprecated
  # @return [Integer]
  # @since 0.3.0
  def hash; end

  # Overrides Ruby's method_missing in order to provide ::String interface
  #
  # @api private
  # @raise [NoMethodError] If doesn't respond to the given method
  # @since 0.3.0
  def method_missing(method_name, *args, &blk); end

  # Returns the top level namespace name
  #
  # @deprecated Use {Hanami::Utils::String.namespace}
  # @example
  #   require 'hanami/utils/string'
  #
  #   string = Hanami::Utils::String.new 'Hanami::Utils::String'
  #   string.namespace # => 'Hanami'
  #
  #   string = Hanami::Utils::String.new 'String'
  #   string.namespace # => 'String'
  # @return [Hanami::Utils::String] the transformed string
  # @since 0.1.2
  def namespace; end

  # Returns a pluralized version of self.
  #
  # @api private
  # @deprecated
  # @return [Hanami::Utils::String] the pluralized string.
  # @see Hanami::Utils::Inflector
  # @since 0.4.1
  def pluralize; end

  # Replaces the rightmost match of `pattern` with `replacement`
  #
  # If the pattern cannot be matched, it returns the original string.
  #
  # This method does NOT mutate the original string.
  #
  # @deprecated Use {Hanami::Utils::String.rsub}
  # @example
  #   require 'hanami/utils/string'
  #
  #   string = Hanami::Utils::String.new('authors/books/index')
  #   result = string.rsub(/\//, '#')
  #
  #   puts string
  #   # => #<Hanami::Utils::String:0x007fdb41233ad8 @string="authors/books/index">
  #
  #   puts result
  #   # => #<Hanami::Utils::String:0x007fdb41232ed0 @string="authors/books#index">
  # @param pattern [Regexp, String] the pattern to find
  # @param replacement [String, Hanami::Utils::String] the string to replace
  # @return [Hanami::Utils::String] the replaced string
  # @since 0.6.0
  def rsub(pattern, replacement); end

  # Iterates through the string, matching the pattern.
  # Either return all those patterns, or pass them to the block.
  #
  # @deprecated
  # @return [Array<::String>]
  # @see http://www.ruby-doc.org/core/String.html#method-i-scan
  # @since 0.6.0
  def scan(pattern, &blk); end

  # Returns a singularized version of self.
  #
  # @api private
  # @deprecated
  # @return [Hanami::Utils::String] the singularized string.
  # @see Hanami::Utils::Inflector
  # @since 0.4.1
  def singularize; end

  # Splits the string with the given pattern
  #
  # @deprecated
  # @return [Array<::String>]
  # @see http://www.ruby-doc.org/core/String.html#method-i-split
  # @since 0.3.0
  def split(pattern, limit = T.unsafe(nil)); end

  # Returns a titleized version of the string
  #
  # @deprecated Use {Hanami::Utils::String.titleize}
  # @example
  #   require 'hanami/utils/string'
  #
  #   string = Hanami::Utils::String.new 'hanami utils'
  #   string.titleize # => "Hanami Utils"
  # @return [Hanami::Utils::String] the transformed string
  # @since 0.4.0
  def titleize; end

  # Returns a string representation
  #
  # @deprecated
  # @return [::String]
  # @since 0.3.0
  def to_s; end

  # Returns a string representation
  #
  # @deprecated
  # @return [::String]
  # @since 0.3.0
  def to_str; end

  # It iterates through the tokens and calls the given block.
  # A token is a substring wrapped by `()` and separated by `|`.
  #
  # @deprecated
  # @example
  #   require 'hanami/utils/string'
  #
  #   string = Hanami::Utils::String.new 'Hanami::(Utils|App)'
  #   string.tokenize do |token|
  #   puts token
  #   end
  #
  #   # =>
  #   'Hanami::Utils'
  #   'Hanami::App'
  # @return [void]
  # @since 0.1.0
  # @yield the block that is called for each token.
  def tokenize; end

  # Returns a downcased and underscore separated version of the string
  #
  # Revised version of `ActiveSupport::Inflector.underscore` implementation
  #
  # @deprecated Use {Hanami::Utils::String.underscore}
  # @example
  #   require 'hanami/utils/string'
  #
  #   string = Hanami::Utils::String.new 'HanamiUtils'
  #   string.underscore # => 'hanami_utils'
  # @return [Hanami::Utils::String] the transformed string
  # @see https://github.com/rails/rails/blob/feaa6e2048fe86bcf07e967d6e47b865e42e055b/activesupport/lib/active_support/inflector/methods.rb#L90
  # @since 0.1.0
  def underscore; end

  private

  # Overrides Ruby's respond_to_missing? in order to support ::String interface
  #
  # @api private
  # @return [Boolean]
  # @since 0.3.0
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  class << self
    def bind(value, binding, fun); end

    # Returns a capitalized version of the string
    #
    # @example
    #   require 'hanami/utils/string'
    #
    #   Hanami::Utils::String.capitalize('hanami') # => "Hanami"
    #
    #   Hanami::Utils::String.capitalize('hanami utils') # => "Hanami utils"
    #
    #   Hanami::Utils::String.capitalize('Hanami Utils') # => "Hanami utils"
    #
    #   Hanami::Utils::String.capitalize('hanami_utils') # => "Hanami utils"
    #
    #   Hanami::Utils::String.capitalize('hanami-utils') # => "Hanami utils"
    # @param input [::String] the input
    # @return [::String] the transformed string
    # @since 1.1.0
    def capitalize(input); end

    # Returns a CamelCase version of the string
    #
    # @example
    #   require 'hanami/utils/string'
    #
    #   Hanami::Utils::String.classify('hanami_utils') # => 'HanamiUtils'
    # @param input [::String] the input
    # @return [::String] the transformed string
    # @since 1.1.0
    def classify(input); end

    # Hanami::Utils::String.dasherize('hanami_utils') # => 'hanami-utils'
    #
    #   Hanami::Utils::String.dasherize('HanamiUtils') # => "hanami-utils"
    #
    # @since 0.1.0
    def dasherize(input); end

    # Returns the string without the Ruby namespace of the class
    #
    # @example
    #   require 'hanami/utils/string'
    #
    #   Hanami::Utils::String.demodulize('Hanami::Utils::String') # => 'String'
    #
    #   Hanami::Utils::String.demodulize('String') # => 'String'
    # @param input [::String] the input
    # @return [::String] the transformed string
    # @since 1.1.0
    def demodulize(input); end

    # Returns the top level namespace name
    #
    # @example
    #   require 'hanami/utils/string'
    #
    #   Hanami::Utils::String.namespace('Hanami::Utils::String') # => 'Hanami'
    #
    #   Hanami::Utils::String.namespace('String') # => 'String'
    # @param input [::String] the input
    # @return [::String] the transformed string
    # @since 1.1.0
    def namespace(input); end

    # Returns a pluralized version of self.
    #
    # @deprecated
    # @example
    #   require 'hanami/utils/string'
    #
    #   Hanami::Utils::String.pluralize('book') # => 'books'
    # @param input [::String] the input
    # @return [::String] the pluralized string.
    # @see Hanami::Utils::Inflector
    # @since 1.1.0
    def pluralize(input); end

    # Replaces the rightmost match of `pattern` with `replacement`
    #
    # If the pattern cannot be matched, it returns the original string.
    #
    # This method does NOT mutate the original string.
    #
    # @example
    #   require 'hanami/utils/string'
    #
    #   Hanami::Utils::String.rsub('authors/books/index', %r{/}, '#')
    #   # => 'authors/books#index'
    # @param input [::String] the input
    # @param pattern [Regexp, ::String] the pattern to find
    # @param replacement [String] the string to replace
    # @return [::String] the replaced string
    # @since 1.1.0
    def rsub(input, pattern, replacement); end

    # Returns a singularized version of self.
    #
    # @deprecated
    # @example
    #   require 'hanami/utils/string'
    #
    #   Hanami::Utils::String.singularize('books') # => 'book'
    # @param input [::String] the input
    # @return [::String] the singularized string.
    # @see Hanami::Utils::Inflector
    # @since 1.1.0
    def singularize(input); end

    # Returns a titleized version of the string
    #
    # @example
    #   require 'hanami/utils/string'
    #
    #   Hanami::Utils::String.titleize('hanami utils') # => "Hanami Utils"
    # @param input [::String] the input
    # @return [::String] the transformed string
    # @since 1.1.0
    def titleize(input); end

    # Applies the given transformation(s) to `input`
    #
    # It performs a pipeline of transformations, by applying the given
    # functions from `Hanami::Utils::String` and `::String`.
    # The transformations are applied in the given order.
    #
    # It doesn't mutate the input, unless you use destructive methods from `::String`
    #
    # @example Unkown transformation
    #   require "hanami/utils/string"
    #
    #   Hanami::Utils::String.transform("Sakura", :foo)
    #   # => NoMethodError: undefined method `:foo' for "Sakura":String
    # @example Basic usage
    #   require "hanami/utils/string"
    #
    #   Hanami::Utils::String.transform("hanami/utils", :underscore, :classify)
    #   # => "Hanami::Utils"
    #
    #   Hanami::Utils::String.transform("Hanami::Utils::String", [:gsub, /[aeiouy]/, "*"], :demodulize)
    #   # => "H*n*m*"
    #
    #   Hanami::Utils::String.transform("Hanami", ->(s) { s.upcase })
    #   # => "HANAMI"
    # @example Proc with arity not equal to 1
    #   require "hanami/utils/string"
    #
    #   Hanami::Utils::String.transform("Cherry", -> { "blossom" }))
    #   # => ArgumentError: wrong number of arguments (given 1, expected 0)
    # @param transformations [Array<Symbol,Proc,Array>] one or many
    #   transformations expressed as:
    #   * `Symbol` to reference a function from `Hanami::Utils::String` or `String`.
    #   * `Proc` an anonymous function that MUST accept one input
    #   * `Array` where the first element is a `Symbol` to reference a
    #   function from `Hanami::Utils::String` or `String` and the rest of
    #   the elements are the arguments to pass
    # @param input [::String] the string to be transformed
    # @raise [NoMethodError] if a `Hanami::Utils::String` and `::String`
    #   don't respond to a given method name
    # @raise [ArgumentError] if a Proc transformation has an arity not equal
    #   to 1
    # @return [::String] the result of the transformations
    # @since 1.1.0
    def transform(input, *transformations); end

    # Returns a downcased and underscore separated version of the string
    #
    # Revised version of `ActiveSupport::Inflector.underscore` implementation
    #
    # @example
    #   require 'hanami/utils/string'
    #
    #   Hanami::Utils::String.underscore('HanamiUtils') # => 'hanami_utils'
    # @param input [::String] the input
    # @return [::String] the transformed string
    # @see https://github.com/rails/rails/blob/feaa6e2048fe86bcf07e967d6e47b865e42e055b/activesupport/lib/active_support/inflector/methods.rb#L90
    # @since 1.1.0
    def underscore(input); end
  end
end

# Separator for #capitalize
#
# @api private
# @since 0.5.2
Hanami::Utils::String::CAPITALIZE_SEPARATOR = T.let(T.unsafe(nil), String)

# Separator for #classify
#
# @api private
# @since 0.3.0
Hanami::Utils::String::CLASSIFY_SEPARATOR = T.let(T.unsafe(nil), String)

# Regexp for #classify
#
# @api private
# @since 0.3.4
Hanami::Utils::String::CLASSIFY_WORD_SEPARATOR = T.let(T.unsafe(nil), Regexp)

# Separator for #dasherize
#
# @api private
# @since 0.4.0
Hanami::Utils::String::DASHERIZE_SEPARATOR = T.let(T.unsafe(nil), String)

# Empty string for #classify
#
# @api private
# @since 0.6.0
Hanami::Utils::String::EMPTY_STRING = T.let(T.unsafe(nil), String)

# Separator between Ruby namespaces
#
# @api private
# @since 0.1.0
Hanami::Utils::String::NAMESPACE_SEPARATOR = T.let(T.unsafe(nil), String)

# Separator for #titleize
#
# @api private
# @since 0.4.0
Hanami::Utils::String::TITLEIZE_SEPARATOR = T.let(T.unsafe(nil), String)

# Regexp for #tokenize
#
# @api private
# @since 0.3.0
Hanami::Utils::String::TOKENIZE_REGEXP = T.let(T.unsafe(nil), Regexp)

# Separator for #tokenize
#
# @api private
# @since 0.3.0
Hanami::Utils::String::TOKENIZE_SEPARATOR = T.let(T.unsafe(nil), String)

# gsub second parameter used in #underscore
#
# @api private
# @since 0.3.0
Hanami::Utils::String::UNDERSCORE_DIVISION_TARGET = T.let(T.unsafe(nil), String)

# Separator for #underscore
#
# @api private
# @since 0.3.0
Hanami::Utils::String::UNDERSCORE_SEPARATOR = T.let(T.unsafe(nil), String)

# Defines the version
#
# @since 0.1.0
Hanami::Utils::VERSION = T.let(T.unsafe(nil), String)
