# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `falcon` gem.
# Please instead update this file by running `bin/tapioca gem falcon`.

module Falcon; end
module Falcon::Adapters; end

# Wraps a streaming input body into the interface required by `rack.input`.
#
# The input stream is an `IO`-like object which contains the raw HTTP POST data. When applicable, its external encoding must be `ASCII-8BIT` and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to `gets`, `each`, `read` and `rewind`.
#
# This implementation is not always rewindable, to avoid buffering the input when handling large uploads. See {Rewindable} for more details.
class Falcon::Adapters::Input
  # Initialize the input wrapper.
  #
  # @return [Input] a new instance of Input
  def initialize(body); end

  # The input body.
  def body; end

  # Close and discard the remainder of the input stream.
  def close; end

  # Enumerate chunks of the request body.
  def each(&block); end

  # Has the input stream been read completely?
  #
  # @return [Boolean]
  def eof?; end

  # Read the next chunk of data from the input stream.
  #
  # `gets` must be called without arguments and return a `String`, or `nil` when the input stream has no more data.
  def gets; end

  # Read data from the input stream.
  #
  # `read` behaves like `IO#read`. Its signature is `read(length = nil, buffer = nil)`. If given, length must be a non-negative `Integer` (>= 0) or `nil`, and buffer must be a `String` and may not be nil. If `length` is given and not `nil`, then this method reads at most `length` bytes from the input stream. If `length` is not given or `nil`, then this method reads all data. When the end is reached, this method returns `nil` if `length` is given and not `nil`, or an empty `String` if `length` is not given or is `nil`. If `buffer` is given, then the read data will be placed into the `buffer` instead of a newly created `String` object.
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Rewind the input stream back to the start.
  #
  # `rewind` must be called without arguments. It rewinds the input stream back to the beginning. It must not raise Errno::ESPIPE: that is, it may not be a pipe or a socket. Therefore, handler developers must buffer the input data into some rewindable object if the underlying input stream is not rewindable.
  def rewind; end

  private

  def read_next; end
end

# Wraps the rack response body.
#
# The `rack` body must respond to `each` and must only yield `String` values. If the body responds to `close`, it will be called after iteration. If the body is replaced by a middleware after action, the original body must be closed first, if it responds to `close`. If the body responds to `to_path`, it must return a String identifying the location of a file whose contents are identical to that produced by calling `each`; this may be used by the server as an alternative, possibly more efficient way to transport the response. The body commonly is an `Array` of strings, the application instance itself, or a `File`-like object.
class Falcon::Adapters::Output < ::Protocol::HTTP::Body::Readable
  # Initialize the output wrapper.
  #
  # @return [Output] a new instance of Output
  def initialize(body, length); end

  # The rack response body.
  def body; end

  # Close the response body.
  def close(error = T.unsafe(nil)); end

  # Enumerate the response body.
  def each(&block); end

  # Whether the body is empty.
  #
  # @return [Boolean]
  def empty?; end

  def inspect; end

  # The content length of the rack response body.
  def length; end

  # Read the next chunk from the response body.
  def read; end

  # Whether the body can be read immediately.
  #
  # @return [Boolean]
  def ready?; end

  class << self
    # Wraps an array into a buffered body.
    def wrap(status, headers, body); end
  end
end

Falcon::Adapters::Output::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

class Falcon::Adapters::Rack
  # Initialize the rack adaptor middleware.
  #
  # @raise [ArgumentError]
  # @return [Rack] a new instance of Rack
  def initialize(app); end

  # Build a rack `env` from the incoming request and apply it to the rack middleware.
  def call(request); end

  # Generate a suitable response for the given exception.
  def failure_response(exception); end

  # Unwrap raw HTTP headers into the CGI-style expected by Rack middleware.
  #
  # Rack separates multiple headers with the same key, into a single field with multiple lines.
  def unwrap_headers(headers, env); end

  # Process the incoming request into a valid rack `env`.
  #
  # - Set the `env['CONTENT_TYPE']` and `env['CONTENT_LENGTH']` based on the incoming request body.
  # - Set the `env['HTTP_HOST']` header to the request authority.
  # - Set the `env['HTTP_X_FORWARDED_PROTO']` header to the request scheme.
  # - Set `env['REMOTE_ADDR']` to the request remote adress.
  def unwrap_request(request, env); end
end

# Async::HTTP specific metadata:
Falcon::Adapters::Rack::ASYNC_HTTP_REQUEST = T.let(T.unsafe(nil), String)

Falcon::Adapters::Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Raised back up through the middleware when the underlying connection is hijacked.
class Falcon::Adapters::Rack::FullHijack < ::StandardError; end

# CGI keys <https://tools.ietf.org/html/rfc3875#section-4.1>:
Falcon::Adapters::Rack::HTTP_HOST = T.let(T.unsafe(nil), String)

# Header constants:
Falcon::Adapters::Rack::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

Falcon::Adapters::Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# Rack environment variables:
Falcon::Adapters::Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

Falcon::Adapters::Rack::REMOTE_ADDR = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::REQUEST_URI = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Falcon::Adapters::Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# A wrapper for a `Rack` response.
#
# A Rack response consisting of `[status, headers, body]` includes various rack-specific elements, including:
#
# - A `headers['rack.hijack']` callback which bypasses normal response handling.
# - Potentially invalid content length.
# - Potentially invalid body when processing a `HEAD` request.
# - Newline-separated header values.
# - Other `rack.` specific header key/value pairs.
#
# This wrapper takes those issues into account and adapts the rack response tuple into a {Protocol::HTTP::Response}.
class Falcon::Adapters::Response < ::Protocol::HTTP::Response
  # Initialize the response wrapper.
  #
  # @return [Response] a new instance of Response
  def initialize(status, headers, body, protocol = T.unsafe(nil)); end

  class << self
    # Wrap a rack response.
    def wrap(status, headers, body, request = T.unsafe(nil)); end

    # Process the rack response headers into into a {Protocol::HTTP::Headers} instance, along with any extra `rack.` metadata.
    def wrap_headers(fields); end
  end
end

Falcon::Adapters::Response::IGNORE_HEADERS = T.let(T.unsafe(nil), Array)

# Content-type driven input buffering, specific to the needs of `rack`.
class Falcon::Adapters::Rewindable < ::Protocol::HTTP::Middleware
  # Initialize the rewindable middleware.
  #
  # @return [Rewindable] a new instance of Rewindable
  def initialize(app); end

  # Wrap the request body in a rewindable buffer if required.
  def call(request); end

  # Determine whether the request needs a rewindable body.
  #
  # @return [Boolean]
  def needs_rewind?(request); end
end

# Media types that require buffering.
Falcon::Adapters::Rewindable::BUFFERED_MEDIA_TYPES = T.let(T.unsafe(nil), Regexp)

Falcon::Adapters::Rewindable::POST = T.let(T.unsafe(nil), String)
module Falcon::Controller; end

# A generic controller for serving an application.
# Uses {Server} for handling incoming requests.
class Falcon::Controller::Serve < ::Async::Container::Controller
  # Initialize the server controller.
  #
  # @return [Serve] a new instance of Serve
  def initialize(command, **options); end

  # Create the controller as specified by the command.
  # e.g. `Async::Container::Forked`.
  def create_container; end

  # The endpoint the server will bind to.
  def endpoint; end

  def load_app; end

  # The name of the controller which is used for the process title.
  def name; end

  # Setup the container with the application instance.
  def setup(container); end

  # Prepare the bound endpoint for the server.
  def start; end

  # Close the bound endpoint.
  def stop(*_arg0); end
end

# An HTTP-specific endpoint which adds localhost TLS.
class Falcon::Endpoint < ::Async::HTTP::Endpoint
  # Build an appropriate SSL context for the given hostname.
  #
  # Uses {Localhost::Authority} to generate self-signed certficates.
  def build_ssl_context(hostname = T.unsafe(nil)); end

  # The SSL context to use, which invokes {build_ssl_context} if not otherwise specified.
  def ssl_context; end
end

module Falcon::Middleware; end

# A static middleware which always returns a 400 bad request response.
module Falcon::Middleware::BadRequest
  class << self
    def call(request); end
    def close; end
  end
end

# A HTTP middleware for proxying requests to a given set of hosts.
# Typically used for implementing virtual servers.
class Falcon::Middleware::Proxy < ::Protocol::HTTP::Middleware
  # Initialize the proxy middleware.
  #
  # @return [Proxy] a new instance of Proxy
  def initialize(app, hosts); end

  # Proxy the request if the authority matches a specific host.
  def call(request); end

  # Close all the connections to the upstream hosts.
  def close; end

  # Establish a connection to the specified upstream endpoint.
  def connect(endpoint); end

  # The number of requests that have been proxied.
  def count; end

  # Lookup the appropriate host for the given request.
  def lookup(request); end

  # Prepare the headers to be sent to an upstream host.
  # In particular, we delete all connection and hop headers.
  def prepare_headers(headers); end

  # Prepare the request to be proxied to the specified host.
  # In particular, we set appropriate {VIA}, {FORWARDED}, {X_FORWARDED_FOR} and {X_FORWARDED_PROTO} headers.
  def prepare_request(request, host); end
end

Falcon::Middleware::Proxy::CONNECTION = T.let(T.unsafe(nil), String)
Falcon::Middleware::Proxy::FORWARDED = T.let(T.unsafe(nil), String)

# HTTP hop headers which *should* not be passed through the proxy.
Falcon::Middleware::Proxy::HOP_HEADERS = T.let(T.unsafe(nil), Array)

Falcon::Middleware::Proxy::VIA = T.let(T.unsafe(nil), String)
Falcon::Middleware::Proxy::X_FORWARDED_FOR = T.let(T.unsafe(nil), String)
Falcon::Middleware::Proxy::X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# A HTTP middleware for logging requests and responses.
class Falcon::Middleware::Verbose < ::Protocol::HTTP::Middleware
  # Initialize the verbose middleware.
  #
  # @return [Verbose] a new instance of Verbose
  def initialize(app, logger = T.unsafe(nil)); end

  # Log details of the incoming request.
  def annotate(request); end

  # Log details of the incoming request using {annotate} and wrap the response to log response details too.
  def call(request); end
end

# A server listening on a specific endpoint, hosting a specific middleware.
class Falcon::Server < ::Async::HTTP::Server
  class << self
    # Wrap a rack application into a middleware suitable the server.
    def middleware(rack_app, verbose: T.unsafe(nil), cache: T.unsafe(nil)); end
  end
end

Falcon::VERSION = T.let(T.unsafe(nil), String)
