:ruby
  Heading = import("/app/components/Layout/Heading")
  Fieldset = import("/app/components/Form/Fieldset")
  Input = import("/app/components/Form/Input")
  Button = import("/app/components/Form/Button")
  Link = import("/app/components/UI/Link")
  GameGrid = import("./GameGrid")

  MAX_SIZE = 20

  def self.get_initial_state(initial_size: MAX_SIZE, **) = {
    size: initial_size,
    grid: Array.new(initial_size * initial_size, false),
    running: false,
  }

  def mount
    loop do
      if state[:running]
        handle_step
        sleep 0.25
      else
        sleep 0.5
      end
    end
  end

  def handle_mouseenter(event)
    event => { target: { value: } }
    index = value.to_i

    case event
    in { buttons: 0 }
      # noop. would be nice if these were never
      # sent from the client..
    in { buttons: 1 }
      set_cell_value(index, true)
    in { buttons: 2 }
      set_cell_value(index, false)
    end
  end

  def handle_reset(event)
    update do |size:|
      { grid: Array.new(size * size, false) }
    end
  end

  def handle_randomize(event)
    update do |size:|
      { grid: Array.new(size * size) { rand(2).zero? } }
    end
  end

  def handle_toggle(event)
    event => { target: { value: } }
    index = value.to_i

    update do |state|
      grid = state[:grid].dup
      grid[index] = !grid[index]
      { grid: }
    end
  end

  def set_cell_value(index, value)
    update do |state|
      grid = state[:grid].dup
      grid[index] = value
      { grid: }
    end
  end

  def handle_change_size(e)
    e => { target: { value: } }
    update_size(value.to_i)
  end

  def handle_step(*)
    update do |grid:, size:|
      { grid: step_grid(grid, size) }
    end
  end

  def handle_toggle_running(e)
    update do |running:|
      { running: !running }
    end
  end

  private

  def step_grid(grid, size)
    grid.map.with_index do |alive, i|
      y, x = i.divmod(size)

      neighbor_count = each_neighbor(grid, size, x, y).count { _1[:value] }

      if alive
        neighbor_count == 2 || neighbor_count == 3
      else
        neighbor_count == 3
      end
    end
  end

  def each_neighbor(grid, size, x, y)
    Enumerator.new do |enum|
      -1.upto(1) do |yoff|
        -1.upto(1) do |xoff|
          next if yoff.zero? && xoff.zero?
          value = get_value(grid, size, x + xoff, y + yoff)
          enum.yield(x:, y:, value:)
        end
      end
    end
  end

  def get_value(grid, size, x, y)
    grid[get_index(size, x, y)]
  end

  def get_index(size, x, y)
    (y % size) * size + x % size
  end

:css
  .buttons {
    display: flex;
    gap: 1em;
  }

:ruby
  state => grid:, size:, running:

%article
  %Heading(level=2) Game of life

  %p
    This is an implementation of
    %Link(href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank")< Conway's Game of Life
    \.
  %p Use the primary mouse button to draw and the secondary mouse button to erase.

  %Fieldset
    %legend Controls
    .buttons
      %Button(onclick=handle_reset) Reset
      %Button(onclick=handle_randomize) Randomize
      %Button(onclick=handle_step disabled=running) Step
      %Button(onclick=handle_toggle_running){
        color: running ? "var(--red)" : "var(--green)"
      }= running ? "Stop" : "Start"
  %GameGrid(grid=grid size=size onmousedown=handle_toggle onmouseenter=handle_mouseenter)
