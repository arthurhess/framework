:ruby
  Heading = require("/app/components/Layout/Heading")
  Fieldset = require("/app/components/Form/Fieldset")
  Input = require("/app/components/Form/Input")
  Button = require("/app/components/Form/Button")

  MAX_GRID_SIZE = 10

  def self.get_initial_state(initial_grid_size: 5, **)
    {
      x: nil,
      y: nil,
      grid_size: initial_grid_size,
    }
  end

  def handle_activate(_, x, y)
    update do |state|
      { x:, y: }
    end
  end

  def handle_change_size(e)
    update_grid_size(e.dig("target", "value").to_i)
  end

  def handle_click(e)
    case e.dig("target", "value")
    in "smaller"
      update_grid_size(state[:grid_size] - 1)
    in "larger"
      update_grid_size(state[:grid_size] + 1)
    end
  end

  private

  def update_grid_size(grid_size)
    update(grid_size: grid_size.clamp(1, MAX_GRID_SIZE))
  end

  def calculate_hue(x, y)
    size = state[:grid_size].to_f
    Math.cos(x / size * 2.0 - 1.0) * Math.sin(y / size * 2.0 - 1.0)
  end

:css
  .grid {
    user-select: none;
    display: grid;
    grid-template-columns: repeat(var(--grid-size), 1fr);
    margin: 1em;
    gap: 1em;
    transform-style: preserve-3d;
    touch-action: manipulation;
  }

  .cell {
    --perspective: 1000px;

    aspect-ratio: 1;
    border: 1px solid #0003;
    border-radius: 3px;
    background: hsl(var(--hue) 0% 90% / 1);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: .8em;
    transition:
      background 5s ease,
      transform 1s ease,
      rotate 2s ease;
    transform: perspective(var(--perspective)) translateZ(0);
  }

  .active {
    background: hsl(var(--hue) 100% 80% / 1);
    transition:
      background 100ms ease,
      transform 200ms ease,
      rotate 250ms ease;
    transform: perspective(var(--perspective)) translateZ(400px);
    rotate: z calc(var(--hue) / -4);
  }

  .buttons {
    margin: .5em 0;
    display: flex;
    gap: .5em;
  }

:ruby
  state => grid_size:

%article
  %Heading(level=2) onmouseenter grid

  %p
    This is a grid where every cell responds to onmouseenter.
    Good way to test performance I suppose.

  %Fieldset
    %legend Controls
    .buttons
      %button(onclick=handle_click value="smaller") Make smaller
      %button(onclick=handle_click value="larger") Make larger
    %Input(type="number" label="Grid size" onchange=handle_change_size min=1 max=MAX_GRID_SIZE){
      value: grid_size
    }

  %pre.pre
    x:
    %span<>= state[:x].inspect
    y:
    %span<= state[:y].inspect

  .grid{style: { "--grid-size": grid_size.to_s }}
    = grid_size.times.map do |y|
      = grid_size.times.map do |x|
        - is_active = state[:x] == x && state[:y] == y
        - klass = is_active && :active
        - style = { "--hue": "#{calculate_hue(x, y).round(2)}turn" }
        .cell(class=klass style=style){
          onmouseenter: handler(:handle_activate, x, y),
          ontouchstart: handler(:handle_activate, x, y),
        }
